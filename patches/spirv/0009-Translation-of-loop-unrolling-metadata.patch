From 9f2b0f21fb8ed4abfd400207f02c0b6eccd5e36c Mon Sep 17 00:00:00 2001
From: Viktoria Maksimova <viktoria.maksimova@intel.com>
Date: Tue, 2 Oct 2018 14:50:16 +0300
Subject: [PATCH 9/9] Translation of loop unrolling metadata

loop-simplify pass is added to simplify search of Continue Target operand of
OpLoopMerge instruction
---
 lib/SPIRV/SPIRVInternal.h             |   7 ++
 lib/SPIRV/SPIRVUtil.cpp               |  35 ++++++
 lib/SPIRV/SPIRVWriter.cpp             |  57 ++++++++--
 lib/SPIRV/libSPIRV/SPIRVBasicBlock.h  |   4 +
 lib/SPIRV/libSPIRV/SPIRVInstruction.h |  20 +++-
 lib/SPIRV/libSPIRV/SPIRVModule.cpp    |  19 ++--
 lib/SPIRV/libSPIRV/SPIRVModule.h      |   7 +-
 test/SPIRV/transcoding/LoopUnroll.ll  | 204 ++++++++++++++++++++++++++++++++++
 8 files changed, 326 insertions(+), 27 deletions(-)
 create mode 100644 test/SPIRV/transcoding/LoopUnroll.ll

diff --git a/lib/SPIRV/SPIRVInternal.h b/lib/SPIRV/SPIRVInternal.h
index f57a2c6..b528d32 100644
--- a/lib/SPIRV/SPIRVInternal.h
+++ b/lib/SPIRV/SPIRVInternal.h
@@ -909,6 +909,13 @@ template <> inline void SPIRVMap<std::string, Op, SPIRVOpaqueType>::init() {
   add(kSPIRVTypeName::SampledImg, OpTypeSampledImage);
 }
 
+// Check if the module contains llvm.loop.unroll.* metadata
+bool hasLoopUnrollMetadata(const Module* M);
+
+// If the branch instruction has !llvm.loop metadata, go through its operands
+// and find Loop Control mask and possible parameters.
+spv::LoopControlMask
+getLoopControl(const BranchInst *Branch, std::vector<SPIRVWord> &Parameters);
 } // namespace SPIRV
 
 #endif // SPIRV_SPIRVINTERNAL_H
diff --git a/lib/SPIRV/SPIRVUtil.cpp b/lib/SPIRV/SPIRVUtil.cpp
index 1257a6c..c8c47aa 100644
--- a/lib/SPIRV/SPIRVUtil.cpp
+++ b/lib/SPIRV/SPIRVUtil.cpp
@@ -1426,4 +1426,39 @@ llvm::Constant *getOCLNullClkEventPtr(Module *M) {
   return Constant::getNullValue(getOCLClkEventPtrType(M));
 }
 
+bool hasLoopUnrollMetadata(const Module *M) {
+  for (const Function &F : *M)
+    for (const BasicBlock &BB : F) {
+      const TerminatorInst *Term = BB.getTerminator();
+      if (!Term)
+        continue;
+      if (const MDNode *MD = Term->getMetadata("llvm.loop"))
+        for (const MDOperand &MDOp : MD->operands())
+          if (getMDOperandAsString(dyn_cast<MDNode>(MDOp), 0)
+                  .find("llvm.loop.unroll.") == 0)
+            return true;
+    }
+  return false;
+}
+
+spv::LoopControlMask
+getLoopControl(const BranchInst *Branch, std::vector<SPIRVWord> &Parameters) {
+  if (!Branch)
+    return spv::LoopControlMaskNone;
+  MDNode *LoopMD = Branch->getMetadata("llvm.loop");
+  if (!LoopMD)
+    return spv::LoopControlMaskNone;
+  for (const MDOperand &MDOp : LoopMD->operands()) {
+    if (MDNode *Node = dyn_cast<MDNode>(MDOp)) {
+      std::string S = getMDOperandAsString(Node, 0);
+      if (S == "llvm.loop.unroll.disable")
+        return spv::LoopControlDontUnrollMask;
+      // TODO Express partial unrolling in SPIRV.
+      if (S == "llvm.loop.unroll.count" || S == "llvm.loop.unroll.full")
+        return spv::LoopControlUnrollMask;
+    }
+  }
+  return spv::LoopControlMaskNone;
+}
+
 } // namespace SPIRV
diff --git a/lib/SPIRV/SPIRVWriter.cpp b/lib/SPIRV/SPIRVWriter.cpp
index 66eecc2..bd293a8 100644
--- a/lib/SPIRV/SPIRVWriter.cpp
+++ b/lib/SPIRV/SPIRVWriter.cpp
@@ -77,6 +77,7 @@
 #include "llvm/Support/ToolOutputFile.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Transforms/IPO.h"
+#include "llvm/Transforms/Utils.h" // loop-simplify pass
 
 #include <cstdlib>
 #include <functional>
@@ -879,18 +880,50 @@ SPIRVValue *LLVMToSPIRV::transValueWithoutDecoration(Value *V,
                              Pairs, BB));
   }
 
-  if (auto Branch = dyn_cast<BranchInst>(V)) {
-    if (Branch->isUnconditional())
-      return mapValue(V, BM->addBranchInst(static_cast<SPIRVLabel *>(transValue(
-                                               Branch->getSuccessor(0), BB)),
-                                           BB));
+  if (BranchInst *Branch = dyn_cast<BranchInst>(V)) {
+    SPIRVLabel *SuccessorTrue =
+        static_cast<SPIRVLabel *>(transValue(Branch->getSuccessor(0), BB));
+
+    /// Clang attaches !llvm.loop metadata to "latch" BB. This kind of blocks
+    /// has an edge directed to the loop header. Thus latch BB matching to
+    /// "Continue Target" per the SPIR-V spec. This statement is true only after
+    /// applying the loop-simplify pass to the LLVM module.
+    /// For "for" and "while" loops latch BB is terminated by an
+    /// unconditional branch. Also for this kind of loops "Merge Block" can
+    /// be found as block targeted by false edge of the "Header" BB.
+    /// For "do while" loop the latch is terminated by a conditional branch
+    /// with true edge going to the header and the false edge going out of
+    /// the loop, which corresponds to a "Merge Block" per the SPIR-V spec.
+    std::vector<SPIRVWord> Parameters;
+    spv::LoopControlMask LoopControl = getLoopControl(Branch, Parameters);
+
+    if (Branch->isUnconditional()) {
+      // For "for" and "while" loops llvm.loop metadata is attached to
+      // an unconditional branch instruction.
+      if (LoopControl != spv::LoopControlMaskNone) {
+        // SuccessorTrue is the loop header BB.
+        const SPIRVInstruction *Term = SuccessorTrue->getTerminateInstr();
+        if (Term && Term->getOpCode() == OpBranchConditional) {
+          const auto *Br = static_cast<const SPIRVBranchConditional *>(Term);
+          BM->addLoopMergeInst(Br->getFalseLabel()->getId(), // Merge Block
+                               BB->getId(),                  // Continue Target
+                               LoopControl, Parameters, SuccessorTrue);
+        }
+      }
+      return mapValue(V, BM->addBranchInst(SuccessorTrue, BB));
+    }
+    // For "do-while" loops llvm.loop metadata is attached to a conditional
+    // branch instructions
+    SPIRVLabel *SuccessorFalse =
+        static_cast<SPIRVLabel *>(transValue(Branch->getSuccessor(1), BB));
+    if (LoopControl != spv::LoopControlMaskNone)
+      // SuccessorTrue is the loop header BB.
+      BM->addLoopMergeInst(SuccessorFalse->getId(), // Merge Block
+                           BB->getId(),             // Continue Target
+                           LoopControl, Parameters, SuccessorTrue);
     return mapValue(
-        V,
-        BM->addBranchConditionalInst(
-            transValue(Branch->getCondition(), BB),
-            static_cast<SPIRVLabel *>(transValue(Branch->getSuccessor(0), BB)),
-            static_cast<SPIRVLabel *>(transValue(Branch->getSuccessor(1), BB)),
-            BB));
+        V, BM->addBranchConditionalInst(transValue(Branch->getCondition(), BB),
+                                        SuccessorTrue, SuccessorFalse, BB));
   }
 
   if (auto Phi = dyn_cast<PHINode>(V)) {
@@ -1653,6 +1686,8 @@ bool llvm::writeSpirv(Module *M, llvm::raw_ostream &OS, std::string &ErrMsg) {
   std::unique_ptr<SPIRVModule> BM(SPIRVModule::createSPIRVModule());
   legacy::PassManager PassMgr;
   addPassesForSPIRV(PassMgr);
+  if (hasLoopUnrollMetadata(M))
+    PassMgr.add(createLoopSimplifyPass());
   PassMgr.add(createLLVMToSPIRV(BM.get()));
   PassMgr.run(*M);
 
diff --git a/lib/SPIRV/libSPIRV/SPIRVBasicBlock.h b/lib/SPIRV/libSPIRV/SPIRVBasicBlock.h
index 867cd3a..0eb0b67 100644
--- a/lib/SPIRV/libSPIRV/SPIRVBasicBlock.h
+++ b/lib/SPIRV/libSPIRV/SPIRVBasicBlock.h
@@ -73,6 +73,10 @@ public:
       return nullptr;
     return *Loc;
   }
+  // Return the last instruction in the BB or nullptr if the BB is empty.
+  const SPIRVInstruction *getTerminateInstr() const {
+    return InstVec.empty() ? nullptr : InstVec.back();
+  }
 
   void setScope(SPIRVEntry *Scope) override;
   void setParent(SPIRVFunction *F) { ParentF = F; }
diff --git a/lib/SPIRV/libSPIRV/SPIRVInstruction.h b/lib/SPIRV/libSPIRV/SPIRVInstruction.h
index c6eedaf..6a70efe 100644
--- a/lib/SPIRV/libSPIRV/SPIRVInstruction.h
+++ b/lib/SPIRV/libSPIRV/SPIRVInstruction.h
@@ -1013,9 +1013,14 @@ public:
   static const SPIRVWord FixedWordCount = 4;
 
   SPIRVLoopMerge(SPIRVId TheMergeBlock, SPIRVId TheContinueTarget,
-                 SPIRVWord TheLoopControl, SPIRVBasicBlock *BB)
-      : SPIRVInstruction(FixedWordCount, OC, BB), MergeBlock(TheMergeBlock),
-        ContinueTarget(TheContinueTarget), LoopControl(TheLoopControl) {
+                 SPIRVWord TheLoopControl,
+                 std::vector<SPIRVWord> TheLoopControlParameters,
+                 SPIRVBasicBlock *BB)
+      : SPIRVInstruction(FixedWordCount + TheLoopControlParameters.size(), OC,
+                         BB),
+        MergeBlock(TheMergeBlock), ContinueTarget(TheContinueTarget),
+        LoopControl(TheLoopControl),
+        LoopControlParameters(TheLoopControlParameters) {
     validate();
     assert(BB && "Invalid BB");
   }
@@ -1030,12 +1035,19 @@ public:
   SPIRVId getMergeBlock() { return MergeBlock; }
   SPIRVId getContinueTarget() { return ContinueTarget; }
   SPIRVWord getLoopControl() { return LoopControl; }
-  _SPIRV_DEF_ENCDEC3(MergeBlock, ContinueTarget, LoopControl)
+
+  void setWordCount(SPIRVWord TheWordCount) override {
+    SPIRVEntry::setWordCount(TheWordCount);
+    LoopControlParameters.resize(TheWordCount - FixedWordCount);
+  }
+  _SPIRV_DEF_ENCDEC4(MergeBlock, ContinueTarget, LoopControl,
+                     LoopControlParameters)
 
 protected:
   SPIRVId MergeBlock;
   SPIRVId ContinueTarget;
   SPIRVWord LoopControl;
+  std::vector<SPIRVWord> LoopControlParameters;
 };
 
 class SPIRVSwitch : public SPIRVInstruction {
diff --git a/lib/SPIRV/libSPIRV/SPIRVModule.cpp b/lib/SPIRV/libSPIRV/SPIRVModule.cpp
index 7a800df..3b25b9a 100644
--- a/lib/SPIRV/libSPIRV/SPIRVModule.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVModule.cpp
@@ -318,9 +318,11 @@ public:
                                        SPIRVBasicBlock *) override;
   SPIRVInstruction *addSelectInst(SPIRVValue *, SPIRVValue *, SPIRVValue *,
                                   SPIRVBasicBlock *) override;
-  SPIRVInstruction *addLoopMergeInst(SPIRVId MergeBlock, SPIRVId ContinueTarget,
-                                     SPIRVWord LoopControl,
-                                     SPIRVBasicBlock *BB) override;
+  SPIRVInstruction *
+  addLoopMergeInst(SPIRVId MergeBlock, SPIRVId ContinueTarget,
+                   SPIRVWord LoopControl,
+                   std::vector<SPIRVWord> LoopControlParameters,
+                   SPIRVBasicBlock *BB) override;
   SPIRVInstruction *addSelectionMergeInst(SPIRVId MergeBlock,
                                           SPIRVWord SelectionControl,
                                           SPIRVBasicBlock *BB) override;
@@ -1187,12 +1189,13 @@ SPIRVInstruction *SPIRVModuleImpl::addSelectionMergeInst(
       new SPIRVSelectionMerge(MergeBlock, SelectionControl, BB), BB);
 }
 
-SPIRVInstruction *SPIRVModuleImpl::addLoopMergeInst(SPIRVId MergeBlock,
-                                                    SPIRVId ContinueTarget,
-                                                    SPIRVWord LoopControl,
-                                                    SPIRVBasicBlock *BB) {
+SPIRVInstruction *SPIRVModuleImpl::addLoopMergeInst(
+    SPIRVId MergeBlock, SPIRVId ContinueTarget, SPIRVWord LoopControl,
+    std::vector<SPIRVWord> LoopControlParameters, SPIRVBasicBlock *BB) {
   return addInstruction(
-      new SPIRVLoopMerge(MergeBlock, ContinueTarget, LoopControl, BB), BB);
+      new SPIRVLoopMerge(MergeBlock, ContinueTarget, LoopControl,
+                         LoopControlParameters, BB),
+      BB, const_cast<SPIRVInstruction *>(BB->getTerminateInstr()));
 }
 
 SPIRVInstruction *
diff --git a/lib/SPIRV/libSPIRV/SPIRVModule.h b/lib/SPIRV/libSPIRV/SPIRVModule.h
index bc3e9b2..c45fe83 100644
--- a/lib/SPIRV/libSPIRV/SPIRVModule.h
+++ b/lib/SPIRV/libSPIRV/SPIRVModule.h
@@ -333,10 +333,9 @@ public:
   virtual SPIRVInstruction *addSelectionMergeInst(SPIRVId MergeBlock,
                                                   SPIRVWord SelectionControl,
                                                   SPIRVBasicBlock *BB) = 0;
-  virtual SPIRVInstruction *addLoopMergeInst(SPIRVId MergeBlock,
-                                             SPIRVId ContinueTarget,
-                                             SPIRVWord LoopControl,
-                                             SPIRVBasicBlock *BB) = 0;
+  virtual SPIRVInstruction *addLoopMergeInst(
+      SPIRVId MergeBlock, SPIRVId ContinueTarget, SPIRVWord LoopControl,
+      std::vector<SPIRVWord> LoopControlParameters, SPIRVBasicBlock *BB) = 0;
   virtual SPIRVInstruction *addStoreInst(SPIRVValue *, SPIRVValue *,
                                          const std::vector<SPIRVWord> &,
                                          SPIRVBasicBlock *) = 0;
diff --git a/test/SPIRV/transcoding/LoopUnroll.ll b/test/SPIRV/transcoding/LoopUnroll.ll
new file mode 100644
index 0000000..20d2f79
--- /dev/null
+++ b/test/SPIRV/transcoding/LoopUnroll.ll
@@ -0,0 +1,204 @@
+; Source:
+; /*** for ***/
+; void for_count()
+; {
+;     __attribute__((opencl_unroll_hint(1)))
+;     for( int i = 0; i < 1024; ++i) {
+;        if(i%2) continue;
+;        int x = i;
+;     }
+; }
+;
+; /*** while ***/
+; void while_count()
+; {
+;     int i = 1024;
+;     __attribute__((opencl_unroll_hint(8)))
+;     while(i-->0) {
+;       if(i%2) continue;
+;       int x = i;
+;     }
+; }
+;
+; /*** do ***/
+; void do_count()
+; {
+;     int i = 1024;
+;     __attribute__((opencl_unroll_hint))
+;     do {
+;       if(i%2) continue;
+;       int x = i;
+;    } while(i--> 0);
+; }
+; Command:
+; clang -cc1 -triple spir64 -O0 LoopUnroll.cl -emit-llvm -o /test/SPIRV/transcoding/LoopUnroll.ll
+
+; RUN: llvm-as < %s > %t.bc
+; RUN: llvm-spirv %t.bc -o - -spirv-text | FileCheck %s --check-prefix=CHECK-SPIRV
+
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
+target triple = "spir64"
+
+; CHECK-SPIRV: Function
+; Function Attrs: noinline nounwind optnone
+define spir_func void @for_count() #0 {
+entry:
+; CHECK-SPIRV: Label
+  %i = alloca i32, align 4
+  %x = alloca i32, align 4
+  store i32 0, i32* %i, align 4
+  br label %for.cond
+
+for.cond:                                         ; preds = %for.inc, %entry
+; CHECK-SPIRV: Label [[Header:[0-9]+]]
+  %0 = load i32, i32* %i, align 4
+  %cmp = icmp slt i32 %0, 1024
+; Per SPIRV spec p3.23 "DontUnroll" loop control = 0x2
+; CHECK-SPIRV: 4 LoopMerge [[MergeBlock:[0-9]+]] [[ContinueTarget:[0-9]+]] 2
+; CHECK-SPIRV: BranchConditional {{[0-9]+}} {{[0-9]+}} [[MergeBlock]]
+  br i1 %cmp, label %for.body, label %for.end
+
+for.body:                                         ; preds = %for.cond
+; CHECK-SPIRV: Label
+  %1 = load i32, i32* %i, align 4
+  %rem = srem i32 %1, 2
+  %tobool = icmp ne i32 %rem, 0
+  br i1 %tobool, label %if.then, label %if.end
+
+if.then:                                          ; preds = %for.body
+; CHECK-SPIRV: Label
+  br label %for.inc
+
+if.end:                                           ; preds = %for.body
+; CHECK-SPIRV: Label
+  %2 = load i32, i32* %i, align 4
+  store i32 %2, i32* %x, align 4
+  br label %for.inc
+
+for.inc:                                          ; preds = %if.end, %if.then
+; CHECK-SPIRV: Label [[ContinueTarget]]
+  %3 = load i32, i32* %i, align 4
+  %inc = add nsw i32 %3, 1
+  store i32 %inc, i32* %i, align 4
+  br label %for.cond, !llvm.loop !5
+; CHECK-SPIRV: Branch [[Header]]
+
+for.end:                                          ; preds = %for.cond
+; CHECK-SPIRV: Label [[MergeBlock]]
+  ret void
+}
+
+; CHECK-SPIRV: Function
+; Function Attrs: noinline nounwind optnone
+define spir_func void @while_count() #0 {
+entry:
+; CHECK-SPIRV: Label
+  %i = alloca i32, align 4
+  %x = alloca i32, align 4
+  store i32 1024, i32* %i, align 4
+  br label %while.cond
+
+while.cond:                                       ; preds = %if.end, %if.then, %entry
+; CHECK-SPIRV: Label [[Header:[0-9]+]]
+  %0 = load i32, i32* %i, align 4
+  %dec = add nsw i32 %0, -1
+  store i32 %dec, i32* %i, align 4
+  %cmp = icmp sgt i32 %0, 0
+; Per SPIRV spec p3.23 "Unroll" loop control = 0x1
+; CHECK-SPIRV: 4 LoopMerge [[MergeBlock:[0-9]+]] [[ContinueTarget:[0-9]+]] 1
+; CHECK-SPIRV: BranchConditional {{[0-9]+}} {{[0-9]+}} [[MergeBlock]]
+  br i1 %cmp, label %while.body, label %while.end
+
+while.body:                                       ; preds = %while.cond
+; CHECK-SPIRV: Label
+  %1 = load i32, i32* %i, align 4
+  %rem = srem i32 %1, 2
+  %tobool = icmp ne i32 %rem, 0
+  br i1 %tobool, label %if.then, label %if.end
+
+if.then:                                          ; preds = %while.body
+; CHECK-SPIRV: Label
+  br label %while.cond, !llvm.loop !7
+
+; loop-simplify pass will create extra basic block which is the only one in
+; loop having a back-edge to the header
+; CHECK-SPIRV: [[ContinueTarget]]
+; CHECK-SPIRV: Branch [[Header]]
+
+if.end:                                           ; preds = %while.body
+; CHECK-SPIRV: Label
+  %2 = load i32, i32* %i, align 4
+  store i32 %2, i32* %x, align 4
+  br label %while.cond, !llvm.loop !7
+
+while.end:                                        ; preds = %while.cond
+; CHECK-SPIRV: [[MergeBlock]]
+  ret void
+}
+
+; CHECK-SPIRV: Function
+; Function Attrs: noinline nounwind optnone
+define spir_func void @do_count() #0 {
+entry:
+; CHECK-SPIRV: Label
+  %i = alloca i32, align 4
+  %x = alloca i32, align 4
+  store i32 1024, i32* %i, align 4
+  br label %do.body, !llvm.loop !9
+
+do.body:                                          ; preds = %do.cond, %entry
+; CHECK-SPIRV: Label [[Header:[0-9]+]]
+  %0 = load i32, i32* %i, align 4
+  %rem = srem i32 %0, 2
+  %tobool = icmp ne i32 %rem, 0
+; Per SPIRV spec p3.23 "Unroll" loop control = 0x1
+; CHECK-SPIRV: 4 LoopMerge [[MergeBlock:[0-9]+]] [[ContinueTarget:[0-9]+]] 1
+; CHECK-SPIRV: BranchConditional
+  br i1 %tobool, label %if.then, label %if.end
+
+if.then:                                          ; preds = %do.body
+; CHECK-SPIRV: Label
+  br label %do.cond
+
+if.end:                                           ; preds = %do.body
+; CHECK-SPIRV: Label
+  %1 = load i32, i32* %i, align 4
+  store i32 %1, i32* %x, align 4
+  br label %do.cond
+
+do.cond:                                          ; preds = %if.end, %if.then
+; CHECK-SPIRV: Label [[ContinueTarget]]
+  %2 = load i32, i32* %i, align 4
+  %dec = add nsw i32 %2, -1
+  store i32 %dec, i32* %i, align 4
+  %cmp = icmp sgt i32 %2, 0
+; CHECK-SPIRV: BranchConditional {{[0-9]+}} [[Header]] [[MergeBlock]]
+  br i1 %cmp, label %do.body, label %do.end, !llvm.loop !9
+
+do.end:                                           ; preds = %do.cond
+; CHECK-SPIRV: Label [[MergeBlock]]
+  ret void
+}
+
+attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.module.flags = !{!0}
+!opencl.enable.FP_CONTRACT = !{}
+!opencl.ocl.version = !{!1}
+!opencl.spir.version = !{!2}
+!opencl.used.extensions = !{!3}
+!opencl.used.optional.core.features = !{!3}
+!opencl.compiler.options = !{!3}
+!llvm.ident = !{!4}
+
+!0 = !{i32 1, !"wchar_size", i32 4}
+!1 = !{i32 1, i32 0}
+!2 = !{i32 1, i32 2}
+!3 = !{}
+!4 = !{!"clang version 5.0.1 (cfe/trunk)"}
+!5 = distinct !{!5, !6}
+!6 = !{!"llvm.loop.unroll.disable"}
+!7 = distinct !{!7, !8}
+!8 = !{!"llvm.loop.unroll.count", i32 8}
+!9 = distinct !{!9, !10}
+!10 = !{!"llvm.loop.unroll.full"}
-- 
1.8.3.1

