From 89cd88009156f9df21b060cf7cccccd975027278 Mon Sep 17 00:00:00 2001
From: Alexey Sotkin <alexey.sotkin@intel.com>
Date: Wed, 17 Jan 2018 12:03:18 +0300
Subject: [PATCH 7/9] Support of debug info in SPIR-V

Format of debug info for SPIR-V is described in the specification:
https://www.khronos.org/registry/spir-v/specs/1.0/DebugInfo.html

Debug info in LLVM is represented as metadata. Every debug info entry in LLVM
implemented as a class inhereted from MDNode. Translation of debug info should
be separated from translation of regrular instructions in order to avoid
circular dependencies. For debug info intrinsics which interleave with regular
instructions, we create placeholder instructions in SPIRV BB, which will be
ammended later, after debug info metadata translation. For debug info entries
represented as metadata we use llvm::DebugInfoFinder to collect them, then
iterate over and translate one by one. Translation of every entry goes through
transDbgEntry method, which caches the entry and call transDbgEntryImpl.
transDbgEntryImpl selects a corresponding method for translation of the debug
entry to SPIRV. Opcodes, flags, indices of operands, etc are descried in
SPIRV.debug.h There is enum for operand indices for each SPIRV debug
instruction. To avoid name clashes each enum is declared in a separate namespace
corresponding to the instruction.

Translation back to LLVM IR is done similarly: We go over debug instructions
stored in SPIRVModuleImpl::DebugInstVec and translate them with
SPIRVToLLVMDbgTran::transDebugInst, which also cache debug instructions and call
SPIRVToLLVMDbgTran::transDebugInstImpl. SPIRVToLLVMDbgTran::transDebugInstImpl
selects corresponding method to translate the debug instruction. SPIRV Debug
info instructions representing intrinsics are translated after other debug
instrucions.

With this commit I also split SPIRVWriter and SPIRVReader to .h and .cpp files.

Change-Id: I0bf76d67c9908f59a4675c59772492de3ed36a73
---
 .clang-tidy                                        |   2 +-
 lib/SPIRV/CMakeLists.txt                           |   2 +
 lib/SPIRV/LLVMToSPIRVDbgTran.cpp                   | 921 +++++++++++++++++++++
 lib/SPIRV/LLVMToSPIRVDbgTran.h                     | 166 ++++
 lib/SPIRV/OCL20ToSPIRV.cpp                         |   4 -
 lib/SPIRV/OCLUtil.h                                |  15 +
 lib/SPIRV/SPIRVInternal.h                          |   8 +
 lib/SPIRV/SPIRVReader.cpp                          | 433 +++-------
 lib/SPIRV/SPIRVReader.h                            | 265 ++++++
 lib/SPIRV/SPIRVRegularizeLLVM.cpp                  |   3 +-
 lib/SPIRV/SPIRVToLLVMDbgTran.cpp                   | 893 ++++++++++++++++++++
 lib/SPIRV/SPIRVToLLVMDbgTran.h                     | 178 ++++
 lib/SPIRV/SPIRVUtil.cpp                            |  16 +-
 lib/SPIRV/SPIRVWriter.cpp                          | 249 ++----
 lib/SPIRV/SPIRVWriter.h                            | 184 ++++
 lib/SPIRV/libSPIRV/SPIRV.debug.h                   | 503 +++++++++++
 lib/SPIRV/libSPIRV/SPIRVBasicBlock.cpp             |  10 +-
 lib/SPIRV/libSPIRV/SPIRVBasicBlock.h               |   4 +-
 lib/SPIRV/libSPIRV/SPIRVEntry.cpp                  |  23 +-
 lib/SPIRV/libSPIRV/SPIRVEntry.h                    |   5 +-
 lib/SPIRV/libSPIRV/SPIRVEnum.h                     |   2 +
 lib/SPIRV/libSPIRV/SPIRVExtInst.h                  |  43 +-
 lib/SPIRV/libSPIRV/SPIRVFunction.cpp               |  19 +-
 lib/SPIRV/libSPIRV/SPIRVInstruction.cpp            |  23 +-
 lib/SPIRV/libSPIRV/SPIRVInstruction.h              |  50 +-
 lib/SPIRV/libSPIRV/SPIRVModule.cpp                 | 118 ++-
 lib/SPIRV/libSPIRV/SPIRVModule.h                   |  23 +-
 lib/SPIRV/libSPIRV/SPIRVOpCode.h                   |   3 +-
 lib/SPIRV/libSPIRV/SPIRVStream.cpp                 |   1 +
 lib/SPIRV/libSPIRV/SPIRVStream.h                   |   1 +
 test/CMakeLists.txt                                |   5 +
 test/DebugInfo/COFF/global-dllimport.ll            |  36 +
 test/DebugInfo/COFF/no-cus.ll                      |  29 +
 .../Generic/2009-11-05-DeadGlobalVariable.ll       |  36 +
 .../Generic/2009-11-06-NamelessGlobalVariable.ll   |  22 +
 test/DebugInfo/Generic/2009-11-10-CurrentFn.ll     |  36 +
 test/DebugInfo/Generic/2010-01-05-DbgScope.ll      |  30 +
 test/DebugInfo/Generic/2010-03-12-llc-crash.ll     |  29 +
 test/DebugInfo/Generic/2010-04-19-FramePtr.ll      |  45 +
 .../Generic/2010-06-29-InlinedFnLocalVar.ll        |  70 ++
 test/DebugInfo/Generic/2010-10-01-crash.ll         |  32 +
 test/DebugInfo/Generic/PR20038.ll                  | 177 ++++
 test/DebugInfo/Generic/bug_null_debuginfo.ll       |  14 +
 test/DebugInfo/Generic/constant-pointers.ll        |  56 ++
 test/DebugInfo/Generic/dead-argument-order.ll      |  86 ++
 test/DebugInfo/Generic/def-line.ll                 |  98 +++
 test/DebugInfo/Generic/discriminator.ll            |  57 ++
 test/DebugInfo/Generic/dwarf-public-names.ll       | 145 ++++
 test/DebugInfo/Generic/enum.ll                     |  89 ++
 test/DebugInfo/Generic/global.ll                   |  50 ++
 test/DebugInfo/Generic/gmlt_profiling.ll           |  38 +
 test/DebugInfo/Generic/imported-name-inlined.ll    |  72 ++
 .../Generic/incorrect-variable-debugloc1.ll        |  86 ++
 test/DebugInfo/Generic/inline-scopes.ll            | 135 +++
 test/DebugInfo/Generic/inlined-arguments.ll        |  84 ++
 test/DebugInfo/Generic/inlined-vars.ll             |  61 ++
 test/DebugInfo/Generic/linear-dbg-value.ll         |  82 ++
 test/DebugInfo/Generic/linkage-name-abstract.ll    | 138 +++
 test/DebugInfo/Generic/member-order.ll             |  71 ++
 .../DebugInfo/Generic/missing-abstract-variable.ll | 182 ++++
 test/DebugInfo/Generic/multiline.ll                |  86 ++
 .../Generic/namespace_function_definition.ll       |  49 ++
 .../namespace_inline_function_definition.ll        | 100 +++
 test/DebugInfo/Generic/noscopes.ll                 |  39 +
 test/DebugInfo/Generic/ptrsize.ll                  |  52 ++
 test/DebugInfo/Generic/restrict.ll                 |  58 ++
 test/DebugInfo/Generic/template-recursive-void.ll  |  70 ++
 test/DebugInfo/Generic/tu-member-pointer.ll        |  39 +
 test/DebugInfo/Generic/two-cus-from-same-file.ll   |  76 ++
 test/DebugInfo/Generic/typedef.ll                  |  40 +
 test/DebugInfo/Generic/version.ll                  |  37 +
 test/DebugInfo/X86/2010-04-13-PubType.ll           |  59 ++
 test/DebugInfo/X86/2011-12-16-BadStructRef.ll      | 171 ++++
 test/DebugInfo/X86/DW_AT_byte_size.ll              |  51 ++
 test/DebugInfo/X86/DW_AT_linkage_name.ll           | 117 +++
 test/DebugInfo/X86/DW_AT_specification.ll          |  49 ++
 test/DebugInfo/X86/DW_AT_stmt_list_sec_offset.ll   |  47 ++
 test/DebugInfo/X86/InlinedFnLocalVar.ll            |  70 ++
 test/DebugInfo/X86/abstract_origin.ll              |  61 ++
 test/DebugInfo/X86/aligned_stack_var.ll            |  48 ++
 test/DebugInfo/X86/arguments.ll                    |  80 ++
 test/DebugInfo/X86/coff_debug_info_type.ll         |  50 ++
 test/DebugInfo/X86/coff_relative_names.ll          |  42 +
 test/DebugInfo/X86/constant-aggregate.ll           | 121 +++
 test/DebugInfo/X86/constant-loclist.ll             |  78 ++
 test/DebugInfo/X86/cu-ranges.ll                    |  80 ++
 test/DebugInfo/X86/data_member_location.ll         |  61 ++
 test/DebugInfo/X86/dbg-byval-parameter.ll          |  57 ++
 test/DebugInfo/X86/dbg-declare-alloca.ll           |  66 ++
 test/DebugInfo/X86/dbg-declare-arg.ll              | 149 ++++
 test/DebugInfo/X86/dbg-declare.ll                  |  73 ++
 test/DebugInfo/X86/dbg-prolog-end.ll               |  68 ++
 test/DebugInfo/X86/dbg-value-const-byref.ll        |  95 +++
 test/DebugInfo/X86/dbg-value-frame-index.ll        |  49 ++
 test/DebugInfo/X86/dbg-value-isel.ll               | 107 +++
 test/DebugInfo/X86/dbg-value-location.ll           |  82 ++
 test/DebugInfo/X86/dbg-value-range.ll              |  67 ++
 test/DebugInfo/X86/debug-dead-local-var.ll         |  59 ++
 test/DebugInfo/X86/debug-info-access.ll            | 157 ++++
 test/DebugInfo/X86/debug_frame.ll                  |  28 +
 test/DebugInfo/X86/default-subrange-array.ll       |  59 ++
 test/DebugInfo/X86/discriminator2.ll               |  67 ++
 test/DebugInfo/X86/discriminator3.ll               |  80 ++
 test/DebugInfo/X86/double-declare.ll               |  50 ++
 test/DebugInfo/X86/dw_op_minus_direct.ll           |  62 ++
 .../DebugInfo/X86/dwarf-aranges-no-dwarf-labels.ll |  95 +++
 test/DebugInfo/X86/dwarf-linkage-names.ll          |  80 ++
 test/DebugInfo/X86/dwarf-pubnames-split.ll         |  43 +
 test/DebugInfo/X86/earlydup-crash.ll               |  99 +++
 test/DebugInfo/X86/ending-run.ll                   |  53 ++
 test/DebugInfo/X86/enum-class.ll                   |  55 ++
 test/DebugInfo/X86/fi-expr.ll                      |  42 +
 test/DebugInfo/X86/float_const.ll                  |  58 ++
 test/DebugInfo/X86/frame-register.ll               |  62 ++
 test/DebugInfo/X86/ghost-sdnode-dbgvalues.ll       | 110 +++
 test/DebugInfo/X86/header.ll                       |  34 +
 test/DebugInfo/X86/inline-member-function.ll       | 105 +++
 test/DebugInfo/X86/inlined-formal-parameter.ll     |  79 ++
 test/DebugInfo/X86/isel-cse-line.ll                | 109 +++
 test/DebugInfo/X86/lexical_block.ll                |  72 ++
 test/DebugInfo/X86/linkage-name.ll                 |  67 ++
 test/DebugInfo/X86/live-debug-variables.ll         |  87 ++
 test/DebugInfo/X86/low-pc-cu.ll                    |  51 ++
 test/DebugInfo/X86/mi-print.ll                     |  59 ++
 test/DebugInfo/X86/missing-file-line.ll            |  60 ++
 test/DebugInfo/X86/mixed-nodebug-cu.ll             |  52 ++
 test/DebugInfo/X86/partial-constant.ll             |  87 ++
 test/DebugInfo/X86/pr13303.ll                      |  34 +
 test/DebugInfo/X86/processes-relocations.ll        |  27 +
 test/DebugInfo/X86/reference-argument.ll           | 111 +++
 test/DebugInfo/X86/rematerialize.ll                | 100 +++
 test/DebugInfo/X86/single-dbg_value.ll             |  75 ++
 test/DebugInfo/X86/single-fi.ll                    |  46 +
 test/DebugInfo/X86/split-dwarf-multiple-cu-hash.ll |  50 ++
 test/DebugInfo/X86/split-dwarf-omit-empty.ll       |  61 ++
 test/DebugInfo/X86/static_member_array.ll          |  78 ++
 test/DebugInfo/X86/stmt-list.ll                    |  29 +
 test/DebugInfo/X86/subrange-type.ll                |  45 +
 test/DebugInfo/X86/tail-merge.ll                   |  80 ++
 test/DebugInfo/X86/this-stack_value.ll             | 127 +++
 test/DebugInfo/X86/type_units_with_addresses.ll    | 163 ++++
 test/DebugInfo/X86/unattached-global.ll            |  27 +
 test/DebugInfo/X86/union-const.ll                  |  69 ++
 test/DebugInfo/X86/union-template.ll               |  70 ++
 test/DebugInfo/X86/vector.ll                       |  37 +
 test/DebugInfo/X86/xray-split-dwarf-interaction.ll |  89 ++
 test/DebugInfo/lit.local.cfg                       |   2 +
 test/DebugInfo/omit-empty.ll                       |  26 +
 test/SingleOpLine.ll                               |  45 +
 test/lit.cfg.py                                    |   2 +-
 150 files changed, 11788 insertions(+), 628 deletions(-)
 create mode 100644 lib/SPIRV/LLVMToSPIRVDbgTran.cpp
 create mode 100644 lib/SPIRV/LLVMToSPIRVDbgTran.h
 create mode 100644 lib/SPIRV/SPIRVReader.h
 create mode 100644 lib/SPIRV/SPIRVToLLVMDbgTran.cpp
 create mode 100644 lib/SPIRV/SPIRVToLLVMDbgTran.h
 create mode 100644 lib/SPIRV/SPIRVWriter.h
 create mode 100644 lib/SPIRV/libSPIRV/SPIRV.debug.h
 create mode 100644 test/DebugInfo/COFF/global-dllimport.ll
 create mode 100644 test/DebugInfo/COFF/no-cus.ll
 create mode 100644 test/DebugInfo/Generic/2009-11-05-DeadGlobalVariable.ll
 create mode 100644 test/DebugInfo/Generic/2009-11-06-NamelessGlobalVariable.ll
 create mode 100644 test/DebugInfo/Generic/2009-11-10-CurrentFn.ll
 create mode 100644 test/DebugInfo/Generic/2010-01-05-DbgScope.ll
 create mode 100644 test/DebugInfo/Generic/2010-03-12-llc-crash.ll
 create mode 100644 test/DebugInfo/Generic/2010-04-19-FramePtr.ll
 create mode 100644 test/DebugInfo/Generic/2010-06-29-InlinedFnLocalVar.ll
 create mode 100644 test/DebugInfo/Generic/2010-10-01-crash.ll
 create mode 100644 test/DebugInfo/Generic/PR20038.ll
 create mode 100644 test/DebugInfo/Generic/bug_null_debuginfo.ll
 create mode 100644 test/DebugInfo/Generic/constant-pointers.ll
 create mode 100644 test/DebugInfo/Generic/dead-argument-order.ll
 create mode 100644 test/DebugInfo/Generic/def-line.ll
 create mode 100644 test/DebugInfo/Generic/discriminator.ll
 create mode 100644 test/DebugInfo/Generic/dwarf-public-names.ll
 create mode 100644 test/DebugInfo/Generic/enum.ll
 create mode 100644 test/DebugInfo/Generic/global.ll
 create mode 100644 test/DebugInfo/Generic/gmlt_profiling.ll
 create mode 100644 test/DebugInfo/Generic/imported-name-inlined.ll
 create mode 100644 test/DebugInfo/Generic/incorrect-variable-debugloc1.ll
 create mode 100644 test/DebugInfo/Generic/inline-scopes.ll
 create mode 100644 test/DebugInfo/Generic/inlined-arguments.ll
 create mode 100644 test/DebugInfo/Generic/inlined-vars.ll
 create mode 100644 test/DebugInfo/Generic/linear-dbg-value.ll
 create mode 100644 test/DebugInfo/Generic/linkage-name-abstract.ll
 create mode 100644 test/DebugInfo/Generic/member-order.ll
 create mode 100644 test/DebugInfo/Generic/missing-abstract-variable.ll
 create mode 100644 test/DebugInfo/Generic/multiline.ll
 create mode 100644 test/DebugInfo/Generic/namespace_function_definition.ll
 create mode 100644 test/DebugInfo/Generic/namespace_inline_function_definition.ll
 create mode 100644 test/DebugInfo/Generic/noscopes.ll
 create mode 100755 test/DebugInfo/Generic/ptrsize.ll
 create mode 100644 test/DebugInfo/Generic/restrict.ll
 create mode 100644 test/DebugInfo/Generic/template-recursive-void.ll
 create mode 100644 test/DebugInfo/Generic/tu-member-pointer.ll
 create mode 100644 test/DebugInfo/Generic/two-cus-from-same-file.ll
 create mode 100644 test/DebugInfo/Generic/typedef.ll
 create mode 100644 test/DebugInfo/Generic/version.ll
 create mode 100644 test/DebugInfo/X86/2010-04-13-PubType.ll
 create mode 100644 test/DebugInfo/X86/2011-12-16-BadStructRef.ll
 create mode 100644 test/DebugInfo/X86/DW_AT_byte_size.ll
 create mode 100644 test/DebugInfo/X86/DW_AT_linkage_name.ll
 create mode 100644 test/DebugInfo/X86/DW_AT_specification.ll
 create mode 100644 test/DebugInfo/X86/DW_AT_stmt_list_sec_offset.ll
 create mode 100644 test/DebugInfo/X86/InlinedFnLocalVar.ll
 create mode 100644 test/DebugInfo/X86/abstract_origin.ll
 create mode 100644 test/DebugInfo/X86/aligned_stack_var.ll
 create mode 100644 test/DebugInfo/X86/arguments.ll
 create mode 100644 test/DebugInfo/X86/coff_debug_info_type.ll
 create mode 100644 test/DebugInfo/X86/coff_relative_names.ll
 create mode 100644 test/DebugInfo/X86/constant-aggregate.ll
 create mode 100644 test/DebugInfo/X86/constant-loclist.ll
 create mode 100644 test/DebugInfo/X86/cu-ranges.ll
 create mode 100644 test/DebugInfo/X86/data_member_location.ll
 create mode 100644 test/DebugInfo/X86/dbg-byval-parameter.ll
 create mode 100644 test/DebugInfo/X86/dbg-declare-alloca.ll
 create mode 100644 test/DebugInfo/X86/dbg-declare-arg.ll
 create mode 100644 test/DebugInfo/X86/dbg-declare.ll
 create mode 100644 test/DebugInfo/X86/dbg-prolog-end.ll
 create mode 100644 test/DebugInfo/X86/dbg-value-const-byref.ll
 create mode 100644 test/DebugInfo/X86/dbg-value-frame-index.ll
 create mode 100644 test/DebugInfo/X86/dbg-value-isel.ll
 create mode 100644 test/DebugInfo/X86/dbg-value-location.ll
 create mode 100644 test/DebugInfo/X86/dbg-value-range.ll
 create mode 100644 test/DebugInfo/X86/debug-dead-local-var.ll
 create mode 100644 test/DebugInfo/X86/debug-info-access.ll
 create mode 100644 test/DebugInfo/X86/debug_frame.ll
 create mode 100644 test/DebugInfo/X86/default-subrange-array.ll
 create mode 100644 test/DebugInfo/X86/discriminator2.ll
 create mode 100644 test/DebugInfo/X86/discriminator3.ll
 create mode 100644 test/DebugInfo/X86/double-declare.ll
 create mode 100644 test/DebugInfo/X86/dw_op_minus_direct.ll
 create mode 100644 test/DebugInfo/X86/dwarf-aranges-no-dwarf-labels.ll
 create mode 100644 test/DebugInfo/X86/dwarf-linkage-names.ll
 create mode 100644 test/DebugInfo/X86/dwarf-pubnames-split.ll
 create mode 100644 test/DebugInfo/X86/earlydup-crash.ll
 create mode 100644 test/DebugInfo/X86/ending-run.ll
 create mode 100644 test/DebugInfo/X86/enum-class.ll
 create mode 100644 test/DebugInfo/X86/fi-expr.ll
 create mode 100644 test/DebugInfo/X86/float_const.ll
 create mode 100644 test/DebugInfo/X86/frame-register.ll
 create mode 100644 test/DebugInfo/X86/ghost-sdnode-dbgvalues.ll
 create mode 100644 test/DebugInfo/X86/header.ll
 create mode 100644 test/DebugInfo/X86/inline-member-function.ll
 create mode 100644 test/DebugInfo/X86/inlined-formal-parameter.ll
 create mode 100644 test/DebugInfo/X86/isel-cse-line.ll
 create mode 100644 test/DebugInfo/X86/lexical_block.ll
 create mode 100644 test/DebugInfo/X86/linkage-name.ll
 create mode 100644 test/DebugInfo/X86/live-debug-variables.ll
 create mode 100644 test/DebugInfo/X86/low-pc-cu.ll
 create mode 100644 test/DebugInfo/X86/mi-print.ll
 create mode 100644 test/DebugInfo/X86/missing-file-line.ll
 create mode 100644 test/DebugInfo/X86/mixed-nodebug-cu.ll
 create mode 100644 test/DebugInfo/X86/partial-constant.ll
 create mode 100644 test/DebugInfo/X86/pr13303.ll
 create mode 100644 test/DebugInfo/X86/processes-relocations.ll
 create mode 100644 test/DebugInfo/X86/reference-argument.ll
 create mode 100644 test/DebugInfo/X86/rematerialize.ll
 create mode 100644 test/DebugInfo/X86/single-dbg_value.ll
 create mode 100644 test/DebugInfo/X86/single-fi.ll
 create mode 100644 test/DebugInfo/X86/split-dwarf-multiple-cu-hash.ll
 create mode 100644 test/DebugInfo/X86/split-dwarf-omit-empty.ll
 create mode 100644 test/DebugInfo/X86/static_member_array.ll
 create mode 100644 test/DebugInfo/X86/stmt-list.ll
 create mode 100644 test/DebugInfo/X86/subrange-type.ll
 create mode 100644 test/DebugInfo/X86/tail-merge.ll
 create mode 100644 test/DebugInfo/X86/this-stack_value.ll
 create mode 100644 test/DebugInfo/X86/type_units_with_addresses.ll
 create mode 100644 test/DebugInfo/X86/unattached-global.ll
 create mode 100644 test/DebugInfo/X86/union-const.ll
 create mode 100644 test/DebugInfo/X86/union-template.ll
 create mode 100644 test/DebugInfo/X86/vector.ll
 create mode 100644 test/DebugInfo/X86/xray-split-dwarf-interaction.ll
 create mode 100644 test/DebugInfo/lit.local.cfg
 create mode 100644 test/DebugInfo/omit-empty.ll
 create mode 100644 test/SingleOpLine.ll

diff --git a/.clang-tidy b/.clang-tidy
index aff99a0..fa3928b 100644
--- a/.clang-tidy
+++ b/.clang-tidy
@@ -14,4 +14,4 @@ CheckOptions:
     value:           CamelCase
   - key:             readability-identifier-naming.VariableCase
     value:           CamelCase
-
+LineFilter: [{"name":"lib/SPIRV/libSPIRV/SPIRV.debug.h","lines":[10,450]}]
diff --git a/lib/SPIRV/CMakeLists.txt b/lib/SPIRV/CMakeLists.txt
index 9fca450..f9da60e 100644
--- a/lib/SPIRV/CMakeLists.txt
+++ b/lib/SPIRV/CMakeLists.txt
@@ -4,6 +4,7 @@ if(SPIRV_USE_LLVM_API)
 endif(SPIRV_USE_LLVM_API)
 
 add_llvm_library(LLVMSPIRVLib
+  LLVMToSPIRVDbgTran.cpp
   Mangler/FunctionDescriptor.cpp
   Mangler/Mangler.cpp
   Mangler/ManglingUtils.cpp
@@ -20,6 +21,7 @@ add_llvm_library(LLVMSPIRVLib
   SPIRVLowerSPIRBlocks.cpp
   SPIRVReader.cpp
   SPIRVRegularizeLLVM.cpp
+  SPIRVToLLVMDbgTran.cpp
   SPIRVToOCL20.cpp
   SPIRVUtil.cpp
   SPIRVWriter.cpp
diff --git a/lib/SPIRV/LLVMToSPIRVDbgTran.cpp b/lib/SPIRV/LLVMToSPIRVDbgTran.cpp
new file mode 100644
index 0000000..363b26c
--- /dev/null
+++ b/lib/SPIRV/LLVMToSPIRVDbgTran.cpp
@@ -0,0 +1,921 @@
+//===- LLVMToSPIRVDbgTran.cpp - Converts debug info to SPIR-V ---*- C++ -*-===//
+//
+//                     The LLVM/SPIR-V Translator
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+// Copyright (c) 2018 Intel Corporation. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the "Software"),
+// to deal with the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// Redistributions of source code must retain the above copyright notice,
+// this list of conditions and the following disclaimers.
+// Redistributions in binary form must reproduce the above copyright notice,
+// this list of conditions and the following disclaimers in the documentation
+// and/or other materials provided with the distribution.
+// Neither the names of Intel Corporation, nor the names of its
+// contributors may be used to endorse or promote products derived from this
+// Software without specific prior written permission.
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
+// THE SOFTWARE.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements translation of debug info from LLVM metadata to SPIR-V
+//
+//===----------------------------------------------------------------------===//
+#include "LLVMToSPIRVDbgTran.h"
+#include "SPIRVWriter.h"
+
+#include "llvm/IR/DebugInfo.h"
+
+using namespace SPIRV;
+
+// Public interface
+
+/// This function is looking for debug information in the LLVM module
+/// and translates it to SPIRV
+void LLVMToSPIRVDbgTran::transDebugMetadata() {
+  DIF.processModule(*M);
+  if (DIF.compile_unit_count() == 0)
+    return;
+
+  DICompileUnit *CU = *DIF.compile_units().begin();
+  transDbgEntry(CU);
+
+  for (const DIType *T : DIF.types())
+    transDbgEntry(T);
+
+  for (const DIScope *S : DIF.scopes())
+    transDbgEntry(S);
+
+  for (const DIGlobalVariableExpression *G : DIF.global_variables()) {
+    transDbgEntry(G->getVariable());
+  }
+
+  for (const DISubprogram *F : DIF.subprograms())
+    transDbgEntry(F);
+
+  for (const DbgDeclareInst *DDI : DbgDeclareIntrinsics)
+    finalizeDebugDeclare(DDI);
+
+  for (const DbgValueInst *DVI : DbgValueIntrinsics)
+    finalizeDebugValue(DVI);
+
+  transLocationInfo();
+}
+
+// llvm.dbg.declare intrinsic.
+
+SPIRVValue *
+LLVMToSPIRVDbgTran::createDebugDeclarePlaceholder(const DbgDeclareInst *DbgDecl,
+                                                  SPIRVBasicBlock *BB) {
+  if (!DbgDecl->getAddress())
+    return nullptr; // The variable is dead.
+
+  DbgDeclareIntrinsics.push_back(DbgDecl);
+  using namespace SPIRVDebug::Operand::DebugDeclare;
+  SPIRVWordVec Ops(OperandCount, getDebugInfoNone()->getId());
+  SPIRVId ExtSetId = BM->getExtInstSetId(SPIRVEIS_Debug);
+  return BM->addExtInst(getVoidTy(), ExtSetId, SPIRVDebug::Declare, Ops, BB);
+}
+
+void LLVMToSPIRVDbgTran::finalizeDebugDeclare(const DbgDeclareInst *DbgDecl) {
+  SPIRVValue *V = SPIRVWriter->getTranslatedValue(DbgDecl);
+  assert(V && "llvm.dbg.declare intrinsic isn't mapped to a SPIRV instruction");
+  assert(V->isExtInst(SPIRV::SPIRVEIS_Debug, SPIRVDebug::Declare) &&
+         "llvm.dbg.declare intrinsic has been translated wrong!");
+  if (!V || !V->isExtInst(SPIRV::SPIRVEIS_Debug, SPIRVDebug::Declare))
+    return;
+  SPIRVExtInst *DD = static_cast<SPIRVExtInst *>(V);
+  SPIRVBasicBlock *BB = DD->getBasicBlock();
+  llvm::Value *Alloca = DbgDecl->getAddress();
+
+  using namespace SPIRVDebug::Operand::DebugDeclare;
+  SPIRVWordVec Ops(OperandCount);
+  Ops[DebugLocalVarIdx] = transDbgEntry(DbgDecl->getVariable())->getId();
+  Ops[VariableIdx] = SPIRVWriter->transValue(Alloca, BB)->getId();
+  Ops[ExpressionIdx] = transDbgEntry(DbgDecl->getExpression())->getId();
+  DD->setArguments(Ops);
+}
+
+// llvm.dbg.value intrinsic.
+
+SPIRVValue *
+LLVMToSPIRVDbgTran::createDebugValuePlaceholder(const DbgValueInst *DbgValue,
+                                                SPIRVBasicBlock *BB) {
+  if (!DbgValue->getValue())
+    return nullptr; // It is pointless without new value
+
+  DbgValueIntrinsics.push_back(DbgValue);
+  using namespace SPIRVDebug::Operand::DebugValue;
+  SPIRVWordVec Ops(MinOperandCount, getDebugInfoNone()->getId());
+  SPIRVId ExtSetId = BM->getExtInstSetId(SPIRVEIS_Debug);
+  return BM->addExtInst(getVoidTy(), ExtSetId, SPIRVDebug::Value, Ops, BB);
+}
+
+void LLVMToSPIRVDbgTran::finalizeDebugValue(const DbgValueInst *DbgValue) {
+  SPIRVValue *V = SPIRVWriter->getTranslatedValue(DbgValue);
+  assert(V && "llvm.dbg.value intrinsic isn't mapped to a SPIRV instruction");
+  assert(V->isExtInst(SPIRV::SPIRVEIS_Debug, SPIRVDebug::Value) &&
+         "llvm.dbg.value intrinsic has been translated wrong!");
+  if (!V || !V->isExtInst(SPIRV::SPIRVEIS_Debug, SPIRVDebug::Value))
+    return;
+  SPIRVExtInst *DV = static_cast<SPIRVExtInst *>(V);
+  SPIRVBasicBlock *BB = DV->getBasicBlock();
+  Value *Val = DbgValue->getValue();
+
+  using namespace SPIRVDebug::Operand::DebugValue;
+  SPIRVWordVec Ops(MinOperandCount);
+  Ops[DebugLocalVarIdx] = transDbgEntry(DbgValue->getVariable())->getId();
+  Ops[ValueIdx] = SPIRVWriter->transValue(Val, BB)->getId();
+  Ops[ExpressionIdx] = transDbgEntry(DbgValue->getExpression())->getId();
+  DV->setArguments(Ops);
+}
+
+// Emitting DebugScope and OpLine instructions
+
+void LLVMToSPIRVDbgTran::transLocationInfo() {
+  for (const Function &F : *M) {
+    for (const BasicBlock &BB : F) {
+      SPIRVValue *V = SPIRVWriter->getTranslatedValue(&BB);
+      assert(V && V->isBasicBlock() &&
+             "Basic block is expected to be translated");
+      SPIRVBasicBlock *SBB = static_cast<SPIRVBasicBlock *>(V);
+      MDNode *DbgScope = nullptr;
+      MDNode *InlinedAt = nullptr;
+      SPIRVString *File = nullptr;
+      unsigned LineNo = 0;
+      unsigned Col = 0;
+      for (const Instruction &I : BB) {
+        const DebugLoc &DL = I.getDebugLoc();
+        if (!DL.get()) {
+          if (DbgScope || InlinedAt) { // Emit DebugNoScope
+            DbgScope = nullptr;
+            InlinedAt = nullptr;
+            V = SPIRVWriter->getTranslatedValue(&I);
+            transDebugLoc(DL, SBB, static_cast<SPIRVInstruction *>(V));
+          }
+          continue;
+        }
+        // Once scope or inlining has changed emit another DebugScope
+        if (DL.getScope() != DbgScope || DL.getInlinedAt() != InlinedAt) {
+          DbgScope = DL.getScope();
+          InlinedAt = DL.getInlinedAt();
+          V = SPIRVWriter->getTranslatedValue(&I);
+          transDebugLoc(DL, SBB, static_cast<SPIRVInstruction *>(V));
+        }
+        // If any component of OpLine has changed emit another OpLine
+        SPIRVString *DirAndFile = BM->getString(getFullPath(DL.get()));
+        if (File != DirAndFile || LineNo != DL.getLine() ||
+            Col != DL.getCol()) {
+          File = DirAndFile;
+          LineNo = DL.getLine();
+          Col = DL.getCol();
+          V = SPIRVWriter->getTranslatedValue(&I);
+          BM->addLine(V, File->getId(), LineNo, Col);
+        }
+      } // Instructions
+    }   // Basic Blocks
+  }     // Functions
+}
+
+// Translation of single debug entry
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgEntry(const MDNode *DIEntry) {
+  // Caching
+  auto it = MDMap.find(DIEntry);
+  if (it != MDMap.end()) {
+    assert(it->second && "Invalid SPIRVEntry is cached!");
+    return it->second;
+  }
+  SPIRVEntry *Res = transDbgEntryImpl(DIEntry);
+  assert(Res && "Translation failure");
+  MDMap[DIEntry] = Res;
+  return Res;
+}
+
+template <typename T>
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgEntryRef(const TypedDINodeRef<T> &Ref,
+                                                 SPIRVEntry *Alternate) {
+  T *Resolved = Ref.resolve();
+  if (!Resolved && Alternate)
+    return Alternate;
+  return transDbgEntry(Resolved);
+}
+
+// Dispatcher implementation
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgEntryImpl(const MDNode *MDN) {
+  if (!MDN)
+    return BM->addDebugInfo(SPIRVDebug::DebugInfoNone, getVoidTy(),
+                            SPIRVWordVec());
+  if (const DINode *DIEntry = dyn_cast<DINode>(MDN)) {
+    switch (DIEntry->getTag()) {
+    // Types
+    case dwarf::DW_TAG_base_type:
+    case dwarf::DW_TAG_unspecified_type:
+      return transDbgBaseType(cast<DIBasicType>(DIEntry));
+
+    case dwarf::DW_TAG_reference_type:
+    case dwarf::DW_TAG_rvalue_reference_type:
+    case dwarf::DW_TAG_pointer_type:
+      return transDbgPointerType(cast<DIDerivedType>(DIEntry));
+
+    case dwarf::DW_TAG_array_type:
+      return transDbgArrayType(cast<DICompositeType>(DIEntry));
+
+    case dwarf::DW_TAG_const_type:
+    case dwarf::DW_TAG_restrict_type:
+    case dwarf::DW_TAG_volatile_type:
+      return transDbgQualifiedType(cast<DIDerivedType>(DIEntry));
+
+    case dwarf::DW_TAG_subroutine_type:
+      return transDbgSubroutineType(cast<DISubroutineType>(DIEntry));
+
+    case dwarf::DW_TAG_class_type:
+    case dwarf::DW_TAG_structure_type:
+    case dwarf::DW_TAG_union_type:
+      return transDbgCompositeType(cast<DICompositeType>(DIEntry));
+
+    case dwarf::DW_TAG_member:
+      return transDbgMemberType(cast<DIDerivedType>(DIEntry));
+
+    case dwarf::DW_TAG_inheritance:
+      return transDbgInheritance(cast<DIDerivedType>(DIEntry));
+
+    case dwarf::DW_TAG_enumeration_type:
+      return transDbgEnumType(cast<DICompositeType>(DIEntry));
+
+    case dwarf::DW_TAG_file_type:
+      return transDbgFileType(cast<DIFile>(DIEntry));
+
+    case dwarf::DW_TAG_typedef:
+      return transDbgTypeDef(cast<DIDerivedType>(DIEntry));
+
+    case dwarf::DW_TAG_ptr_to_member_type:
+      return transDbgPtrToMember(cast<DIDerivedType>(DIEntry));
+
+    // Scope
+    case dwarf::DW_TAG_namespace:
+    case dwarf::DW_TAG_lexical_block:
+      return transDbgScope(cast<DIScope>(DIEntry));
+
+    // Function
+    case dwarf::DW_TAG_subprogram:
+      return transDbgFunction(cast<DISubprogram>(DIEntry));
+
+    // Variables
+    case dwarf::DW_TAG_variable:
+      if (const DILocalVariable *LV = dyn_cast<DILocalVariable>(DIEntry))
+        return transDbgLocalVariable(LV);
+      if (const DIGlobalVariable *GV = dyn_cast<DIGlobalVariable>(DIEntry))
+        return transDbgGlobalVariable(GV);
+      llvm_unreachable("Unxpected debug info type for variable");
+    case dwarf::DW_TAG_formal_parameter:
+      return transDbgLocalVariable(cast<DILocalVariable>(DIEntry));
+
+    // Compilation unit
+    case dwarf::DW_TAG_compile_unit:
+      return transDbgCompilationUnit(cast<DICompileUnit>(DIEntry));
+
+    // Templates
+    case dwarf::DW_TAG_template_type_parameter:
+    case dwarf::DW_TAG_template_value_parameter:
+      return transDbgTemplateParameter(cast<DITemplateParameter>(DIEntry));
+    case dwarf::DW_TAG_GNU_template_template_param:
+      return transDbgTemplateTemplateParameter(
+          cast<DITemplateValueParameter>(DIEntry));
+    case dwarf::DW_TAG_GNU_template_parameter_pack:
+      return transDbgTemplateParameterPack(
+          cast<DITemplateValueParameter>(DIEntry));
+
+    default:
+      return getDebugInfoNone();
+    }
+  }
+  if (const DIExpression *Expr = dyn_cast<DIExpression>(MDN))
+    return transDbgExpression(Expr);
+
+  if (const DILocation *Loc = dyn_cast<DILocation>(MDN)) {
+    return transDbgInlinedAt(Loc);
+  }
+  llvm_unreachable("Not implemented debug info entry!");
+}
+
+// Helper methods
+
+SPIRVType *LLVMToSPIRVDbgTran::getVoidTy() {
+  if (!VoidT) {
+    assert(M && "Pointer to LLVM Module is expected to be initialized!");
+    // Cache void type in a member.
+    VoidT = SPIRVWriter->transType(Type::getVoidTy(M->getContext()));
+  }
+  return VoidT;
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::getScope(DIScopeRef SR) {
+  if (DIScope *S = SR.resolve())
+    return transDbgEntry(S);
+  else {
+    assert(SPIRVCU && "Compilation unit must already be translated!");
+    return SPIRVCU;
+  }
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::getScope(DIScope *S) {
+  if (S)
+    return transDbgEntry(S);
+  else {
+    assert(SPIRVCU && "Compile unit is expected to be already translated");
+    return SPIRVCU;
+  }
+}
+
+SPIRVWord mapDebugFlags(DINode::DIFlags DFlags) {
+  SPIRVWord Flags = 0;
+  if ((DFlags & DINode::FlagAccessibility) == DINode::FlagPublic)
+    Flags |= SPIRVDebug::FlagIsPublic;
+  if ((DFlags & DINode::FlagAccessibility) == DINode::FlagProtected)
+    Flags |= SPIRVDebug::FlagIsProtected;
+  if ((DFlags & DINode::FlagAccessibility) == DINode::FlagPrivate)
+    Flags |= SPIRVDebug::FlagIsPrivate;
+
+  if (DFlags & DINode::FlagFwdDecl)
+    Flags |= SPIRVDebug::FlagIsFwdDecl;
+  if (DFlags & DINode::FlagArtificial)
+    Flags |= SPIRVDebug::FlagIsArtificial;
+  if (DFlags & DINode::FlagExplicit)
+    Flags |= SPIRVDebug::FlagIsExplicit;
+  if (DFlags & DINode::FlagPrototyped)
+    Flags |= SPIRVDebug::FlagIsPrototyped;
+  if (DFlags & DINode::FlagObjectPointer)
+    Flags |= SPIRVDebug::FlagIsObjectPointer;
+  if (DFlags & DINode::FlagStaticMember)
+    Flags |= SPIRVDebug::FlagIsStaticMember;
+  // inderect variable flag ?
+  if (DFlags & DINode::FlagLValueReference)
+    Flags |= SPIRVDebug::FlagIsLValueReference;
+  if (DFlags & DINode::FlagRValueReference)
+    Flags |= SPIRVDebug::FlagIsRValueReference;
+  return Flags;
+}
+
+SPIRVWord transDebugFlags(const DINode *DN) {
+  SPIRVWord Flags = 0;
+  if (const DIGlobalVariable *GV = dyn_cast<DIGlobalVariable>(DN)) {
+    if (GV->isLocalToUnit())
+      Flags |= SPIRVDebug::FlagIsLocal;
+    if (GV->isDefinition())
+      Flags |= SPIRVDebug::FlagIsDefinition;
+  }
+  if (const DISubprogram *DS = dyn_cast<DISubprogram>(DN)) {
+    if (DS->isLocalToUnit())
+      Flags |= SPIRVDebug::FlagIsLocal;
+    if (DS->isOptimized())
+      Flags |= SPIRVDebug::FlagIsOptimized;
+    if (DS->isDefinition())
+      Flags |= SPIRVDebug::FlagIsDefinition;
+    Flags |= mapDebugFlags(DS->getFlags());
+  }
+  if (DN->getTag() == dwarf::DW_TAG_reference_type)
+    Flags |= SPIRVDebug::FlagIsLValueReference;
+  if (DN->getTag() == dwarf::DW_TAG_rvalue_reference_type)
+    Flags |= SPIRVDebug::FlagIsRValueReference;
+  if (const DIType *DT = dyn_cast<DIType>(DN))
+    Flags |= mapDebugFlags(DT->getFlags());
+  if (const DILocalVariable *DLocVar = dyn_cast<DILocalVariable>(DN))
+    Flags |= mapDebugFlags(DLocVar->getFlags());
+
+  return Flags;
+}
+
+/// The following methods (till the end of the file) implement translation of
+/// debug instrtuctions described in the spec.
+
+// Absent Debug Info
+
+SPIRVEntry *LLVMToSPIRVDbgTran::getDebugInfoNone() {
+  if (!DebugInfoNone) {
+    DebugInfoNone = transDbgEntry(nullptr);
+  }
+  return DebugInfoNone;
+}
+
+SPIRVId LLVMToSPIRVDbgTran::getDebugInfoNoneId() {
+  return getDebugInfoNone()->getId();
+}
+
+// Compilation unit
+
+SPIRVEntry *
+LLVMToSPIRVDbgTran::transDbgCompilationUnit(const DICompileUnit *CU) {
+  using namespace SPIRVDebug::Operand::CompilationUnit;
+  SPIRVWordVec Ops(OperandCount);
+  Ops[SPIRVDebugInfoVersionIdx] = SPIRVDebug::DebugInfoVersion;
+  Ops[DWARFVersionIdx] = M->getDwarfVersion();
+  Ops[SourceIdx] = getSource(CU)->getId();
+  SPIRVCU = static_cast<SPIRVExtInst *>(
+      BM->addDebugInfo(SPIRVDebug::CompilationUnit, getVoidTy(), Ops));
+  return SPIRVCU;
+}
+
+// Types
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgBaseType(const DIBasicType *BT) {
+  using namespace SPIRVDebug::Operand::TypeBasic;
+  SPIRVWordVec Ops(OperandCount);
+  Ops[NameIdx] = BM->getString(BT->getName())->getId();
+  ConstantInt *Size = getUInt(M, BT->getSizeInBits());
+  Ops[SizeIdx] = SPIRVWriter->transValue(Size, nullptr)->getId();
+  auto Encoding = static_cast<dwarf::TypeKind>(BT->getEncoding());
+  Ops[EncodingIdx] = SPIRV::DbgEncodingMap::map(Encoding);
+  return BM->addDebugInfo(SPIRVDebug::TypeBasic, getVoidTy(), Ops);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgPointerType(const DIDerivedType *PT) {
+  using namespace SPIRVDebug::Operand::TypePointer;
+  SPIRVWordVec Ops(OperandCount);
+  SPIRVEntry *Base = transDbgEntryRef(PT->getBaseType(), getVoidTy());
+  Ops[BaseTypeIdx] = Base->getId();
+  Ops[StorageClassIdx] = ~0U; // all ones denote no address space
+  Optional<unsigned> AS = PT->getDWARFAddressSpace();
+  if (AS.hasValue()) {
+    SPIRAddressSpace SPIRAS = static_cast<SPIRAddressSpace>(AS.getValue());
+    Ops[StorageClassIdx] = SPIRSPIRVAddrSpaceMap::map(SPIRAS);
+  }
+  Ops[FlagsIdx] = transDebugFlags(PT);
+  SPIRVEntry *Res = BM->addDebugInfo(SPIRVDebug::TypePointer, getVoidTy(), Ops);
+  return Res;
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgQualifiedType(const DIDerivedType *QT) {
+  using namespace SPIRVDebug::Operand::TypeQualifier;
+  SPIRVWordVec Ops(OperandCount);
+  SPIRVEntry *Base = transDbgEntryRef(QT->getBaseType());
+  Ops[BaseTypeIdx] = Base->getId();
+  Ops[QualifierIdx] = SPIRV::DbgTypeQulifierMap::map(
+      static_cast<llvm::dwarf::Tag>(QT->getTag()));
+  return BM->addDebugInfo(SPIRVDebug::TypeQualifier, getVoidTy(), Ops);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgArrayType(const DICompositeType *AT) {
+  using namespace SPIRVDebug::Operand::TypeArray;
+  SPIRVWordVec Ops(MinOperandCount);
+  SPIRVEntry *Base = transDbgEntryRef(AT->getBaseType());
+  Ops[BaseTypeIdx] = Base->getId();
+
+  DINodeArray AR(AT->getElements());
+  // For N-dimensianal arrays AR.getNumElements() == N
+  const unsigned N = AR.size();
+  Ops.resize(ComponentCountIdx + N);
+  for (unsigned i = 0; i < N; ++i) {
+    DISubrange *SR = cast<DISubrange>(AR[i]);
+    ConstantInt *Count = SR->getCount().get<ConstantInt *>();
+    if (AT->isVector()) {
+      assert(N == 1 && "Multidimensional vector is not expected!");
+      Ops[ComponentCountIdx] = static_cast<SPIRVWord>(Count->getZExtValue());
+      return BM->addDebugInfo(SPIRVDebug::TypeVector, getVoidTy(), Ops);
+    }
+    SPIRVValue *C = SPIRVWriter->transValue(Count, nullptr);
+    Ops[ComponentCountIdx + i] = C->getId();
+  }
+  return BM->addDebugInfo(SPIRVDebug::TypeArray, getVoidTy(), Ops);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgTypeDef(const DIDerivedType *DT) {
+  using namespace SPIRVDebug::Operand::Typedef;
+  SPIRVWordVec Ops(OperandCount);
+  Ops[NameIdx] = BM->getString(DT->getName())->getId();
+  SPIRVEntry *BaseTy = transDbgEntryRef(DT->getBaseType());
+  assert(BaseTy && "Couldn't translate base type!");
+  Ops[BaseTypeIdx] = BaseTy->getId();
+  Ops[SourceIdx] = getSource(DT)->getId();
+  Ops[LineIdx] = 0;   // This version of DIDerivedType has no line number
+  Ops[ColumnIdx] = 0; // This version of DIDerivedType has no column number
+  SPIRVEntry *Scope = getScope(DT->getScope());
+  assert(Scope && "Couldn't translate scope!");
+  Ops[ParentIdx] = Scope->getId();
+  return BM->addDebugInfo(SPIRVDebug::Typedef, getVoidTy(), Ops);
+}
+
+SPIRVEntry *
+LLVMToSPIRVDbgTran::transDbgSubroutineType(const DISubroutineType *FT) {
+  using namespace SPIRVDebug::Operand::TypeFunction;
+  SPIRVWordVec Ops(MinOperandCount);
+
+  DITypeRefArray Types = FT->getTypeArray();
+  const size_t NumElements = Types.size();
+  if (NumElements) {
+    Ops.resize(NumElements);
+    // First element of the TypeArray is the type of the return value,
+    // followed by types of the function arguments' types.
+    // The same order is preserved in SPIRV.
+    for (unsigned i = 0; i < NumElements; ++i)
+      Ops[ReturnTypeIdx + i] = transDbgEntryRef(Types[i], getVoidTy())->getId();
+  } else { // void foo();
+    Ops[ReturnTypeIdx] = getVoidTy()->getId();
+  }
+
+  return BM->addDebugInfo(SPIRVDebug::TypeFunction, getVoidTy(), Ops);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgEnumType(const DICompositeType *ET) {
+  using namespace SPIRVDebug::Operand::TypeEnum;
+  SPIRVWordVec Ops(MinOperandCount);
+
+  SPIRVEntry *UnderlyingType = getVoidTy();
+  if (DITypeRef DerivedFrom = ET->getBaseType())
+    UnderlyingType = transDbgEntryRef(DerivedFrom);
+  ConstantInt *Size = getUInt(M, ET->getSizeInBits());
+
+  Ops[NameIdx] = BM->getString(ET->getName())->getId();
+  Ops[UnderlyingTypeIdx] = UnderlyingType->getId();
+  Ops[SourceIdx] = getSource(ET)->getId();
+  Ops[LineIdx] = ET->getLine();
+  Ops[ColumnIdx] = 0; // This version of DICompositeType has no column number
+  Ops[ParentIdx] = getScope(ET->getScope())->getId();
+  Ops[SizeIdx] = SPIRVWriter->transValue(Size, nullptr)->getId();
+  Ops[FlagsIdx] = transDebugFlags(ET);
+
+  DINodeArray Elements = ET->getElements();
+  size_t ElemCount = Elements.size();
+  for (unsigned i = 0; i < ElemCount; ++i) {
+    DIEnumerator *E = cast<DIEnumerator>(Elements[i]);
+    ConstantInt *EnumValue = getInt(M, E->getValue());
+    SPIRVValue *Val = SPIRVWriter->transValue(EnumValue, nullptr);
+    assert(Val->getOpCode() == OpConstant &&
+           "LLVM constant must be translated to SPIRV constant");
+    Ops.push_back(Val->getId());
+    SPIRVString *Name = BM->getString(E->getName());
+    Ops.push_back(Name->getId());
+  }
+  return BM->addDebugInfo(SPIRVDebug::TypeEnum, getVoidTy(), Ops);
+}
+
+SPIRVEntry *
+LLVMToSPIRVDbgTran::transDbgCompositeType(const DICompositeType *CT) {
+  using namespace SPIRVDebug::Operand::TypeComposite;
+  SPIRVWordVec Ops(MinOperandCount);
+
+  SPIRVForward *tmp = BM->addForward(nullptr);
+  MDMap.insert(std::make_pair(CT, tmp));
+
+  auto Tag = static_cast<dwarf::Tag>(CT->getTag());
+  ConstantInt *Size = getUInt(M, CT->getSizeInBits());
+
+  Ops[NameIdx] = BM->getString(CT->getName())->getId();
+  Ops[TagIdx] = SPIRV::DbgCompositeTypeMap::map(Tag);
+  Ops[SourceIdx] = getSource(CT)->getId();
+  Ops[LineIdx] = CT->getLine();
+  Ops[ColumnIdx] = 0; // This version of DICompositeType has no column number
+  Ops[ParentIdx] = getScope(CT->getScope())->getId();
+  Ops[SizeIdx] = SPIRVWriter->transValue(Size, nullptr)->getId();
+  Ops[FlagsIdx] = transDebugFlags(CT);
+
+  for (DINode *N : CT->getElements()) {
+    Ops.push_back(transDbgEntry(N)->getId());
+  }
+
+  SPIRVEntry *Res =
+      BM->addDebugInfo(SPIRVDebug::TypeComposite, getVoidTy(), Ops);
+  BM->replaceForward(tmp, Res);
+
+  // Translate template parameters.
+  if (DITemplateParameterArray TP = CT->getTemplateParams()) {
+    const unsigned int NumTParams = TP.size();
+    SPIRVWordVec Args(1 + NumTParams);
+    Args[0] = Res->getId();
+    for (unsigned int i = 0; i < NumTParams; ++i) {
+      Args[i + 1] = transDbgEntry(TP[i])->getId();
+    }
+    Res = BM->addDebugInfo(SPIRVDebug::TypeTemplate, getVoidTy(), Args);
+  }
+  MDMap[CT] = Res;
+  return Res;
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgMemberType(const DIDerivedType *MT) {
+  using namespace SPIRVDebug::Operand::TypeMember;
+  SPIRVWordVec Ops(MinOperandCount);
+
+  Ops[NameIdx] = BM->getString(MT->getName())->getId();
+  Ops[TypeIdx] = transDbgEntryRef(MT->getBaseType())->getId();
+  Ops[SourceIdx] = getSource(MT)->getId();
+  Ops[LineIdx] = MT->getLine();
+  Ops[ColumnIdx] = 0; // This version of DIDerivedType has no column number
+  Ops[ParentIdx] = transDbgEntryRef(MT->getScope())->getId();
+  ConstantInt *Offset = getUInt(M, MT->getOffsetInBits());
+  Ops[OffsetIdx] = SPIRVWriter->transValue(Offset, nullptr)->getId();
+  ConstantInt *Size = getUInt(M, MT->getSizeInBits());
+  Ops[SizeIdx] = SPIRVWriter->transValue(Size, nullptr)->getId();
+  Ops[FlagsIdx] = transDebugFlags(MT);
+  if (MT->isStaticMember()) {
+    if (llvm::Constant *C = MT->getConstant()) {
+      SPIRVValue *Val = SPIRVWriter->transValue(C, nullptr);
+      assert(isConstantOpCode(Val->getOpCode()) &&
+             "LLVM constant must be translated to SPIRV constant");
+      Ops.push_back(Val->getId());
+    }
+  }
+  return BM->addDebugInfo(SPIRVDebug::TypeMember, getVoidTy(), Ops);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgInheritance(const DIDerivedType *DT) {
+  using namespace SPIRVDebug::Operand::TypeInheritance;
+  SPIRVWordVec Ops(OperandCount);
+  Ops[ChildIdx] = transDbgEntryRef(DT->getScope())->getId();
+  Ops[ParentIdx] = transDbgEntryRef(DT->getBaseType())->getId();
+  ConstantInt *Offset = getUInt(M, DT->getOffsetInBits());
+  Ops[OffsetIdx] = SPIRVWriter->transValue(Offset, nullptr)->getId();
+  ConstantInt *Size = getUInt(M, DT->getSizeInBits());
+  Ops[SizeIdx] = SPIRVWriter->transValue(Size, nullptr)->getId();
+  Ops[FlagsIdx] = transDebugFlags(DT);
+  return BM->addDebugInfo(SPIRVDebug::Inheritance, getVoidTy(), Ops);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgPtrToMember(const DIDerivedType *DT) {
+  using namespace SPIRVDebug::Operand::PtrToMember;
+  SPIRVWordVec Ops(OperandCount);
+  Ops[MemberTypeIdx] = transDbgEntryRef(DT->getBaseType())->getId();
+  Ops[ParentIdx] = transDbgEntryRef(DT->getClassType())->getId();
+  return BM->addDebugInfo(SPIRVDebug::TypePtrToMember, getVoidTy(), Ops);
+}
+
+// Templates
+SPIRVEntry *
+LLVMToSPIRVDbgTran::transDbgTemplateParams(DITemplateParameterArray TPA,
+                                           const SPIRVEntry *Target) {
+  using namespace SPIRVDebug::Operand::Template;
+  SPIRVWordVec Ops(MinOperandCount);
+  Ops[TargetIdx] = Target->getId();
+  for (DITemplateParameter *TP : TPA) {
+    Ops.push_back(transDbgEntry(TP)->getId());
+  }
+  return BM->addDebugInfo(SPIRVDebug::TypeTemplate, getVoidTy(), Ops);
+}
+
+SPIRVEntry *
+LLVMToSPIRVDbgTran::transDbgTemplateParameter(const DITemplateParameter *TP) {
+  using namespace SPIRVDebug::Operand::TemplateParameter;
+  SPIRVWordVec Ops(OperandCount);
+  Ops[NameIdx] = BM->getString(TP->getName())->getId();
+  Ops[TypeIdx] = transDbgEntryRef(TP->getType(), getVoidTy())->getId();
+  Ops[ValueIdx] = getDebugInfoNoneId();
+  if (TP->getTag() == dwarf::DW_TAG_template_value_parameter) {
+    const DITemplateValueParameter *TVP = cast<DITemplateValueParameter>(TP);
+    Constant *C = cast<ConstantAsMetadata>(TVP->getValue())->getValue();
+    Ops[ValueIdx] = SPIRVWriter->transValue(C, nullptr)->getId();
+  }
+  Ops[SourceIdx] = getDebugInfoNoneId();
+  Ops[LineIdx] = 0;   // This version of DITemplateParameter has no line number
+  Ops[ColumnIdx] = 0; // This version of DITemplateParameter has no column info
+  return BM->addDebugInfo(SPIRVDebug::TypeTemplateParameter, getVoidTy(), Ops);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgTemplateTemplateParameter(
+    const DITemplateValueParameter *TVP) {
+  using namespace SPIRVDebug::Operand::TemplateTemplateParameter;
+  SPIRVWordVec Ops(OperandCount);
+  assert(isa<MDString>(TVP->getValue()));
+  MDString *Val = cast<MDString>(TVP->getValue());
+  Ops[NameIdx] = BM->getString(TVP->getName())->getId();
+  Ops[TemplateNameIdx] = BM->getString(Val->getString())->getId();
+  Ops[SourceIdx] = getDebugInfoNoneId();
+  Ops[LineIdx] = 0; // This version of DITemplateValueParameter has no line info
+  Ops[ColumnIdx] = 0; // This version of DITemplateValueParameter has no column
+  return BM->addDebugInfo(SPIRVDebug::TypeTemplateTemplateParameter,
+                          getVoidTy(), Ops);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgTemplateParameterPack(
+    const DITemplateValueParameter *TVP) {
+  using namespace SPIRVDebug::Operand::TemplateParameterPack;
+  SPIRVWordVec Ops(MinOperandCount);
+  assert(isa<MDNode>(TVP->getValue()));
+  MDNode *Params = cast<MDNode>(TVP->getValue());
+
+  Ops[NameIdx] = BM->getString(TVP->getName())->getId();
+  Ops[SourceIdx] = getDebugInfoNoneId();
+  Ops[LineIdx] = 0; // This version of DITemplateValueParameter has no line info
+  Ops[ColumnIdx] = 0; // This version of DITemplateValueParameter has no column
+
+  for (const MDOperand &Op : Params->operands()) {
+    SPIRVEntry *P = transDbgEntry(cast<DINode>(Op.get()));
+    Ops.push_back(P->getId());
+  }
+  return BM->addDebugInfo(SPIRVDebug::TypeTemplateParameterPack, getVoidTy(),
+                          Ops);
+}
+
+// Global objects
+
+SPIRVEntry *
+LLVMToSPIRVDbgTran::transDbgGlobalVariable(const DIGlobalVariable *GV) {
+  using namespace SPIRVDebug::Operand::GlobalVariable;
+  SPIRVWordVec Ops(MinOperandCount);
+  Ops[NameIdx] = BM->getString(GV->getName())->getId();
+  Ops[TypeIdx] = transDbgEntryRef(GV->getType())->getId();
+  Ops[SourceIdx] = getSource(GV)->getId();
+  Ops[LineIdx] = GV->getLine();
+  Ops[ColumnIdx] = 0; // This version of DIGlobalVariable has no column number
+
+  // Parent scope
+  DIScope *Context = GV->getScope();
+  SPIRVEntry *Parent = SPIRVCU;
+  // Global variable may be declared in scope of a namespace or it may be a
+  // static variable declared in scope of a function
+  if (Context && (isa<DINamespace>(Context) || isa<DISubprogram>(Context)))
+    Parent = transDbgEntry(Context);
+  Ops[ParentIdx] = Parent->getId();
+  Ops[LinkageNameIdx] = BM->getString(GV->getLinkageName())->getId();
+
+  // Variable
+  SPIRVEntry *Var = getDebugInfoNone();
+  llvm::GlobalVariable *V = M->getGlobalVariable(GV->getName());
+  if (!V)
+    V = M->getGlobalVariable(GV->getLinkageName());
+  if (V)
+    Var = SPIRVWriter->transValue(V, nullptr);
+  Ops[VariableIdx] = Var->getId();
+
+  Ops[FlagsIdx] = transDebugFlags(GV);
+  if (DIDerivedType *StaticMember = GV->getStaticDataMemberDeclaration())
+    Ops.push_back(transDbgEntry(StaticMember)->getId());
+  return BM->addDebugInfo(SPIRVDebug::GlobalVariable, getVoidTy(), Ops);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgFunction(const DISubprogram *Func) {
+  auto it = MDMap.find(Func);
+  if (it != MDMap.end())
+    return static_cast<SPIRVValue *>(it->second);
+
+  // As long as indexes of FunctionDeclaration operands match with Function
+  using namespace SPIRVDebug::Operand::FunctionDeclaration;
+  SPIRVWordVec Ops(OperandCount);
+  Ops[NameIdx] = BM->getString(Func->getName())->getId();
+  Ops[TypeIdx] = transDbgEntry(Func->getType())->getId();
+  Ops[SourceIdx] = getSource(Func)->getId();
+  Ops[LineIdx] = Func->getLine();
+  Ops[ColumnIdx] = 0; // This version of DISubprogram has no column number
+  Ops[ParentIdx] = getScope(Func->getScope())->getId();
+  Ops[LinkageNameIdx] = BM->getString(Func->getLinkageName())->getId();
+  Ops[FlagsIdx] = transDebugFlags(Func);
+
+  SPIRVEntry *DebugFunc = nullptr;
+  if (!Func->isDefinition()) {
+    DebugFunc = BM->addDebugInfo(SPIRVDebug::FunctionDecl, getVoidTy(), Ops);
+  } else {
+    // Here we add operands specific function definition
+    using namespace SPIRVDebug::Operand::Function;
+    Ops.resize(MinOperandCount);
+    Ops[ScopeLineIdx] = Func->getScopeLine();
+
+    llvm::Function *F = M->getFunction(Func->getName());
+    if (!F)
+      F = M->getFunction(Func->getLinkageName());
+    if (F) {
+      SPIRVValue *SPIRVFunc = SPIRVWriter->getTranslatedValue(F);
+      assert(SPIRVFunc && "All function must be already translated");
+      Ops[FunctionIdIdx] = SPIRVFunc->getId();
+    } else {
+      Ops[FunctionIdIdx] = getDebugInfoNoneId();
+    }
+
+    if (DISubprogram *FuncDecl = Func->getDeclaration())
+      Ops.push_back(transDbgEntry(FuncDecl)->getId());
+    else
+      Ops.push_back(getDebugInfoNoneId());
+
+    DebugFunc = BM->addDebugInfo(SPIRVDebug::Function, getVoidTy(), Ops);
+    MDMap.insert(std::make_pair(Func, DebugFunc));
+    // Functions local variable might be not refered to anywhere else, except
+    // here.
+    // Just translate them.
+    for (const DINode *Var : Func->getRetainedNodes())
+      transDbgEntry(Var);
+  }
+  // If the function has template parameters the function *is* a template.
+  if (DITemplateParameterArray TPA = Func->getTemplateParams()) {
+    DebugFunc = transDbgTemplateParams(TPA, DebugFunc);
+  }
+  return DebugFunc;
+}
+
+// Location information
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgScope(const DIScope *S) {
+  if (const DILexicalBlockFile *LBF = dyn_cast<DILexicalBlockFile>(S)) {
+    using namespace SPIRVDebug::Operand::LexicalBlockDiscriminator;
+    SPIRVWordVec Ops(OperandCount);
+    Ops[SourceIdx] = getSource(S)->getId();
+    Ops[DiscriminatorIdx] = LBF->getDiscriminator();
+    Ops[ParentIdx] = getScope(S->getScope())->getId();
+    return BM->addDebugInfo(SPIRVDebug::LexicalBlockDiscriminator, getVoidTy(),
+                            Ops);
+  }
+  using namespace SPIRVDebug::Operand::LexicalBlock;
+  SPIRVWordVec Ops(MinOperandCount);
+  Ops[SourceIdx] = getSource(S)->getId();
+  Ops[ParentIdx] = getScope(S->getScope())->getId();
+  if (const DILexicalBlock *LB = dyn_cast<DILexicalBlock>(S)) {
+    Ops[LineIdx] = LB->getLine();
+    Ops[ColumnIdx] = LB->getColumn();
+  } else if (const DINamespace *NS = dyn_cast<DINamespace>(S)) {
+    Ops[LineIdx] = 0;   // This version of DINamespace has no line number
+    Ops[ColumnIdx] = 0; // This version of DINamespace has no column number
+    Ops.push_back(BM->getString(NS->getName())->getId());
+  }
+  return BM->addDebugInfo(SPIRVDebug::LexicalBlock, getVoidTy(), Ops);
+}
+
+// Generating DebugScope and DebugNoScope instructions. They can interleave with
+// core instructions.
+SPIRVEntry *LLVMToSPIRVDbgTran::transDebugLoc(const DebugLoc &Loc,
+                                              SPIRVBasicBlock *BB,
+                                              SPIRVInstruction *InsertBefore) {
+  SPIRVId ExtSetId = BM->getExtInstSetId(SPIRVEIS_Debug);
+  if (!Loc.get())
+    return BM->addExtInst(getVoidTy(), ExtSetId, SPIRVDebug::NoScope,
+                          std::vector<SPIRVWord>(), BB, InsertBefore);
+
+  using namespace SPIRVDebug::Operand::Scope;
+  SPIRVWordVec Ops(MinOperandCount);
+  Ops[ScopeIdx] = getScope(static_cast<DIScope *>(Loc.getScope()))->getId();
+  if (DILocation *IA = Loc.getInlinedAt())
+    Ops.push_back(transDbgEntry(IA)->getId());
+  return BM->addExtInst(getVoidTy(), ExtSetId, SPIRVDebug::Scope, Ops, BB,
+                        InsertBefore);
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgInlinedAt(const DILocation *Loc) {
+  using namespace SPIRVDebug::Operand::InlinedAt;
+  SPIRVWordVec Ops(MinOperandCount);
+  Ops[LineIdx] = Loc->getLine();
+  Ops[ScopeIdx] = getScope(Loc->getScope())->getId();
+  if (DILocation *IA = Loc->getInlinedAt())
+    Ops.push_back(transDbgEntry(IA)->getId());
+  return BM->addDebugInfo(SPIRVDebug::InlinedAt, getVoidTy(), Ops);
+}
+
+template <class T>
+SPIRVExtInst *LLVMToSPIRVDbgTran::getSource(const T *DIEntry) {
+  // By the spec we should return OpSource and then get its id.
+  // But this is a bug (in the spec), because OpSource has no id!
+  return static_cast<SPIRVExtInst *>(getDebugInfoNone());
+}
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgFileType(const DIFile *F) {
+  return BM->getString(getFullPath(F));
+}
+
+// Local variables
+
+SPIRVEntry *
+LLVMToSPIRVDbgTran::transDbgLocalVariable(const DILocalVariable *Var) {
+  using namespace SPIRVDebug::Operand::LocalVariable;
+  SPIRVWordVec Ops(MinOperandCount);
+
+  Ops[NameIdx] = BM->getString(Var->getName())->getId();
+  Ops[TypeIdx] = transDbgEntryRef(Var->getType())->getId();
+  Ops[SourceIdx] = getSource(Var->getFile())->getId();
+  Ops[LineIdx] = Var->getLine();
+  Ops[ColumnIdx] = 0; // This version of DILocalVariable has no column number
+  Ops[ParentIdx] = getScope(Var->getScope())->getId();
+  if (SPIRVWord argNumber = Var->getArg())
+    Ops.push_back(argNumber);
+  return BM->addDebugInfo(SPIRVDebug::LocalVariable, getVoidTy(), Ops);
+}
+
+// DWARF Operations and expressions
+
+SPIRVEntry *LLVMToSPIRVDbgTran::transDbgExpression(const DIExpression *Expr) {
+  SPIRVWordVec Operations;
+  for (unsigned I = 0, N = Expr->getNumElements(); I < N; ++I) {
+    using namespace SPIRVDebug::Operand::Operation;
+    auto DWARFOpCode = static_cast<dwarf::LocationAtom>(Expr->getElement(I));
+    SPIRVDebug::ExpressionOpCode OC =
+        SPIRV::DbgExpressionOpCodeMap::map(DWARFOpCode);
+    assert(OpCountMap.find(OC) != OpCountMap.end() &&
+           "unhandled opcode found in DIExpression");
+    unsigned OpCount = OpCountMap[OC];
+    SPIRVWordVec Op(OpCount);
+    Op[OpCodeIdx] = OC;
+    for (unsigned j = 1; j < OpCount; ++j)
+      Op[j] = Expr->getElement(++I);
+    auto *Operation = BM->addDebugInfo(SPIRVDebug::Operation, getVoidTy(), Op);
+    Operations.push_back(Operation->getId());
+  }
+  return BM->addDebugInfo(SPIRVDebug::Expression, getVoidTy(), Operations);
+}
diff --git a/lib/SPIRV/LLVMToSPIRVDbgTran.h b/lib/SPIRV/LLVMToSPIRVDbgTran.h
new file mode 100644
index 0000000..f27b06b
--- /dev/null
+++ b/lib/SPIRV/LLVMToSPIRVDbgTran.h
@@ -0,0 +1,166 @@
+//===- LLVMToSPIRVDbgTran.h - Converts LLVM DebugInfo to SPIR-V -*- C++ -*-===//
+//
+//                     The LLVM/SPIR-V Translator
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+// Copyright (c) 2018 Intel Corporation. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the "Software"),
+// to deal with the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// Redistributions of source code must retain the above copyright notice,
+// this list of conditions and the following disclaimers.
+// Redistributions in binary form must reproduce the above copyright notice,
+// this list of conditions and the following disclaimers in the documentation
+// and/or other materials provided with the distribution.
+// Neither the names of Intel Corporation, nor the names of its
+// contributors may be used to endorse or promote products derived from this
+// Software without specific prior written permission.
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
+// THE SOFTWARE.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements translation of debug info from LLVM metadata to SPIR-V
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVMTOSPIRVDBGTRAN_HPP_
+#define LLVMTOSPIRVDBGTRAN_HPP_
+
+#include "SPIRVModule.h"
+#include "llvm/IR/DebugInfo.h"
+#include "llvm/IR/Module.h"
+
+#include <memory>
+
+using namespace llvm;
+
+namespace SPIRV {
+class LLVMToSPIRV;
+
+class LLVMToSPIRVDbgTran {
+public:
+  typedef std::vector<SPIRVWord> SPIRVWordVec;
+
+  LLVMToSPIRVDbgTran(Module *TM = nullptr, SPIRVModule *TBM = nullptr,
+                     LLVMToSPIRV *Writer = nullptr)
+      : BM(TBM), M(TM), SPIRVWriter(Writer), VoidT(nullptr),
+        DebugInfoNone(nullptr) {}
+  void transDebugMetadata();
+  void setModule(Module *Mod) { M = Mod; }
+
+  // Mixing translation of regular instructions and debug info creates a mess.
+  // To avoid it we translate debug info intrinsics in two steps:
+  // 1. First time we meet debug info intrinsic during translation of a basic
+  //   block. At this time we create corresponding SPIRV debug info instruction,
+  //   but with dummy operands. Doing so we a) map llvm value to spirv value,
+  //   b) get a place for SPIRV debug info intrinsic in SPIRV basic block.
+  //   We also remember all debug intrinsics.
+  SPIRVValue *createDebugDeclarePlaceholder(const DbgDeclareInst *DbgDecl,
+                                            SPIRVBasicBlock *BB);
+  SPIRVValue *createDebugValuePlaceholder(const DbgValueInst *DbgValue,
+                                          SPIRVBasicBlock *BB);
+
+private:
+  // 2. After translation of all regular instructions we deal with debug info.
+  //   We iterate over debug intrinsics stored on the first step, get its mapped
+  //   SPIRV instruction and tweak the operands.
+  void finalizeDebugDeclare(const DbgDeclareInst *DbgDecl);
+  void finalizeDebugValue(const DbgValueInst *DbgValue);
+
+  // Emit DebugScope and OpLine instructions
+  void transLocationInfo();
+
+  // Dispatcher
+  SPIRVEntry *transDbgEntry(const MDNode *DIEntry);
+  SPIRVEntry *transDbgEntryImpl(const MDNode *MDN);
+  template <typename T>
+  SPIRVEntry *transDbgEntryRef(const TypedDINodeRef<T> &Ref,
+                               SPIRVEntry *Alternate = nullptr);
+
+  // Helper methods
+  SPIRVType *getVoidTy();
+  SPIRVEntry *getScope(DIScopeRef SR);
+  SPIRVEntry *getScope(DIScope *SR);
+
+  // No debug info
+  SPIRVEntry *getDebugInfoNone();
+  SPIRVId getDebugInfoNoneId();
+
+  // Compilation unit
+  SPIRVEntry *transDbgCompilationUnit(const DICompileUnit *CU);
+
+  /// The following methods (till the end of the file) implement translation
+  /// of debug instrtuctions described in the spec.
+
+  // Types
+  SPIRVEntry *transDbgBaseType(const DIBasicType *BT);
+  SPIRVEntry *transDbgPointerType(const DIDerivedType *PT);
+  SPIRVEntry *transDbgQualifiedType(const DIDerivedType *QT);
+  SPIRVEntry *transDbgArrayType(const DICompositeType *AT);
+  SPIRVEntry *transDbgTypeDef(const DIDerivedType *D);
+  SPIRVEntry *transDbgSubroutineType(const DISubroutineType *FT);
+  SPIRVEntry *transDbgEnumType(const DICompositeType *ET);
+  SPIRVEntry *transDbgCompositeType(const DICompositeType *CT);
+  SPIRVEntry *transDbgMemberType(const DIDerivedType *MT);
+  SPIRVEntry *transDbgInheritance(const DIDerivedType *DT);
+  SPIRVEntry *transDbgPtrToMember(const DIDerivedType *DT);
+
+  // Templates
+  SPIRVEntry *transDbgTemplateParams(DITemplateParameterArray TPA,
+                                     const SPIRVEntry *Target);
+  SPIRVEntry *transDbgTemplateParameter(const DITemplateParameter *TP);
+  SPIRVEntry *
+  transDbgTemplateTemplateParameter(const DITemplateValueParameter *TP);
+  SPIRVEntry *transDbgTemplateParameterPack(const DITemplateValueParameter *TP);
+
+  // Global objects
+  SPIRVEntry *transDbgGlobalVariable(const DIGlobalVariable *GV);
+  SPIRVEntry *transDbgFunction(const DISubprogram *Func);
+
+  // Location information
+  SPIRVEntry *transDbgScope(const DIScope *S);
+  SPIRVEntry *transDebugLoc(const DebugLoc &Loc, SPIRVBasicBlock *BB,
+                            SPIRVInstruction *InsertBefore = nullptr);
+  SPIRVEntry *transDbgInlinedAt(const DILocation *D);
+
+  template <class T> SPIRVExtInst *getSource(const T *DIEntry);
+  SPIRVEntry *transDbgFileType(const DIFile *F);
+
+  // Local Variables
+  SPIRVEntry *transDbgLocalVariable(const DILocalVariable *Var);
+
+  // DWARF expressions
+  SPIRVEntry *transDbgExpression(const DIExpression *Expr);
+
+  // Imported declarations and modules
+  SPIRVEntry *transDbgImportedEntry(const DIImportedEntity *IE);
+
+  SPIRVModule *BM;
+  Module *M;
+  LLVMToSPIRV *SPIRVWriter;
+  std::unordered_map<const MDNode *, SPIRVEntry *> MDMap;
+  std::unordered_map<std::string, SPIRVExtInst *> FileMap;
+  DebugInfoFinder DIF;
+  SPIRVType *VoidT;
+  SPIRVEntry *DebugInfoNone;
+  SPIRVExtInst *SPIRVCU;
+  std::vector<const DbgDeclareInst *> DbgDeclareIntrinsics;
+  std::vector<const DbgValueInst *> DbgValueIntrinsics;
+}; // class LLVMToSPIRVDbgTran
+
+} // namespace SPIRV
+
+#endif // LLVMTOSPIRVDBGTRAN_HPP_
diff --git a/lib/SPIRV/OCL20ToSPIRV.cpp b/lib/SPIRV/OCL20ToSPIRV.cpp
index c8f7d9d..a831c1f 100644
--- a/lib/SPIRV/OCL20ToSPIRV.cpp
+++ b/lib/SPIRV/OCL20ToSPIRV.cpp
@@ -275,10 +275,6 @@ public:
   void visitSubgroupImageMediaBlockINTEL(CallInst *CI,
                                          const std::string &DemangledName);
 
-  void visitDbgInfoIntrinsic(DbgInfoIntrinsic &I) {
-    I.dropAllReferences();
-    I.eraseFromParent();
-  }
   static char ID;
 
 private:
diff --git a/lib/SPIRV/OCLUtil.h b/lib/SPIRV/OCLUtil.h
index 27810c2..b721b71 100644
--- a/lib/SPIRV/OCLUtil.h
+++ b/lib/SPIRV/OCLUtil.h
@@ -40,6 +40,8 @@
 #define SPIRV_OCLUTIL_H
 
 #include "SPIRVInternal.h"
+#include "llvm/IR/DebugInfoMetadata.h"
+#include "llvm/Support/Path.h"
 
 #include <functional>
 #include <tuple>
@@ -316,6 +318,19 @@ decodeOCLVer(unsigned Ver);
 /// Decode a MDNode assuming it contains three integer constants.
 void decodeMDNode(MDNode *N, unsigned &X, unsigned &Y, unsigned &Z);
 
+/// Get full path from debug info metadata
+/// Return empty string if the path is not available.
+template <typename T> std::string getFullPath(const T *Scope) {
+  if (!Scope)
+    return std::string();
+  std::string Filename = Scope->getFilename().str();
+  if (sys::path::is_absolute(Filename))
+    return Filename;
+  SmallString<16> DirName = Scope->getDirectory();
+  sys::path::append(DirName, Filename);
+  return DirName.str().str();
+}
+
 /// Decode OpenCL vector type hint MDNode and encode it as SPIR-V execution
 /// mode VecTypeHint.
 unsigned transVecTypeHint(MDNode *Node);
diff --git a/lib/SPIRV/SPIRVInternal.h b/lib/SPIRV/SPIRVInternal.h
index ccb8ec5..f57a2c6 100644
--- a/lib/SPIRV/SPIRVInternal.h
+++ b/lib/SPIRV/SPIRVInternal.h
@@ -732,6 +732,14 @@ ConstantInt *getInt32(Module *M, int Value);
 /// Get a 32 bit unsigned integer constant.
 ConstantInt *getUInt32(Module *M, unsigned Value);
 
+/// Get 32 bit integer constant if the value fits in 32 bits,
+/// return 64 bit integer constant otherwise
+ConstantInt *getInt(Module *M, int64_t Value);
+
+/// Get 32 bit unsigned integer constant if the value fits in 32 bits,
+/// return 64 bit unsigned integer constant otherwise
+ConstantInt *getUInt(Module *M, uint64_t Value);
+
 /// Get a 16 bit unsigned integer constant.
 ConstantInt *getUInt16(Module *M, unsigned short Value);
 
diff --git a/lib/SPIRV/SPIRVReader.cpp b/lib/SPIRV/SPIRVReader.cpp
index fd0c676..1f5ab65 100644
--- a/lib/SPIRV/SPIRVReader.cpp
+++ b/lib/SPIRV/SPIRVReader.cpp
@@ -36,6 +36,7 @@
 /// This file implements conversion of SPIR-V binary to LLVM IR.
 ///
 //===----------------------------------------------------------------------===//
+#include "SPIRVReader.h"
 #include "OCLUtil.h"
 #include "SPIRVBasicBlock.h"
 #include "SPIRVExtInst.h"
@@ -44,6 +45,7 @@
 #include "SPIRVInternal.h"
 #include "SPIRVMDBuilder.h"
 #include "SPIRVModule.h"
+#include "SPIRVToLLVMDbgTran.h"
 #include "SPIRVType.h"
 #include "SPIRVUtil.h"
 #include "SPIRVValue.h"
@@ -52,7 +54,6 @@
 #include "llvm/ADT/StringSwitch.h"
 #include "llvm/BinaryFormat/Dwarf.h"
 #include "llvm/IR/Constants.h"
-#include "llvm/IR/DIBuilder.h"
 #include "llvm/IR/DerivedTypes.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/Instructions.h"
@@ -177,335 +178,6 @@ static void addOCLKernelArgumentMetadata(
   Fn->setMetadata(MDName, MDNode::get(*Context, ValueVec));
 }
 
-class SPIRVToLLVMDbgTran {
-public:
-  SPIRVToLLVMDbgTran(SPIRVModule *TBM, Module *TM)
-      : BM(TBM), M(TM), SpDbg(BM), Builder(*M) {
-    Enable = BM->hasDebugInfo();
-  }
-
-  void createCompileUnit() {
-    if (!Enable)
-      return;
-    auto File = SpDbg.getEntryPointFileStr(ExecutionModelKernel, 0);
-    std::string BaseName;
-    std::string Path;
-    splitFileName(File, BaseName, Path);
-    Builder.createCompileUnit(dwarf::DW_LANG_C99,
-                              Builder.createFile(BaseName, Path), "spirv",
-                              false, "", 0, "", DICompileUnit::LineTablesOnly);
-  }
-
-  void addDbgInfoVersion() {
-    if (!Enable)
-      return;
-    M->addModuleFlag(Module::Warning, "Dwarf Version", dwarf::DWARF_VERSION);
-    M->addModuleFlag(Module::Warning, "Debug Info Version",
-                     DEBUG_METADATA_VERSION);
-  }
-
-  DIFile *getDIFile(const std::string &FileName) {
-    return getOrInsert(FileMap, FileName, [=]() -> DIFile * {
-      std::string BaseName;
-      std::string Path;
-      splitFileName(FileName, BaseName, Path);
-      if (!BaseName.empty())
-        return Builder.createFile(BaseName, Path);
-      else
-        return nullptr;
-    });
-  }
-
-  DISubprogram *getDISubprogram(SPIRVFunction *SF, Function *F) {
-    return getOrInsert(FuncMap, F, [=]() {
-      auto DF = getDIFile(SpDbg.getFunctionFileStr(SF));
-      auto FN = F->getName();
-      auto LN = SpDbg.getFunctionLineNo(SF);
-      return Builder.createFunction(
-          DF, FN, FN, DF, LN,
-          Builder.createSubroutineType(Builder.getOrCreateTypeArray(None)),
-          Function::isInternalLinkage(F->getLinkage()), true, LN);
-    });
-  }
-
-  void transDbgInfo(SPIRVValue *SV, Value *V) {
-    if (!Enable || !SV->hasLine())
-      return;
-    if (auto I = dyn_cast<Instruction>(V)) {
-      assert(SV->isInst() && "Invalid instruction");
-      auto SI = static_cast<SPIRVInstruction *>(SV);
-      assert(SI->getParent() && SI->getParent()->getParent() &&
-             "Invalid instruction");
-      auto Line = SV->getLine();
-      I->setDebugLoc(
-          DebugLoc::get(Line->getLine(), Line->getColumn(),
-                        getDISubprogram(SI->getParent()->getParent(),
-                                        I->getParent()->getParent())));
-    }
-  }
-
-  void finalize() {
-    if (!Enable)
-      return;
-    Builder.finalize();
-  }
-
-private:
-  SPIRVModule *BM;
-  Module *M;
-  SPIRVDbgInfo SpDbg;
-  DIBuilder Builder;
-  bool Enable;
-  std::unordered_map<std::string, DIFile *> FileMap;
-  std::unordered_map<Function *, DISubprogram *> FuncMap;
-
-  void splitFileName(const std::string &FileName, std::string &BaseName,
-                     std::string &Path) {
-    auto Loc = FileName.find_last_of("/\\");
-    if (Loc != std::string::npos) {
-      BaseName = FileName.substr(Loc + 1);
-      Path = FileName.substr(0, Loc);
-    } else {
-      BaseName = FileName;
-      Path = ".";
-    }
-  }
-};
-
-class SPIRVToLLVM {
-public:
-  SPIRVToLLVM(Module *LLVMModule, SPIRVModule *TheSPIRVModule)
-      : M(LLVMModule), BM(TheSPIRVModule), DbgTran(BM, M) {
-    assert(M);
-    Context = &M->getContext();
-  }
-
-  std::string getOCLBuiltinName(SPIRVInstruction *BI);
-  std::string getOCLConvertBuiltinName(SPIRVInstruction *BI);
-  std::string getOCLGenericCastToPtrName(SPIRVInstruction *BI);
-
-  Type *transType(SPIRVType *BT, bool IsClassMember = false);
-  std::string transTypeToOCLTypeName(SPIRVType *BT, bool IsSigned = true);
-  std::vector<Type *> transTypeVector(const std::vector<SPIRVType *> &);
-  bool translate();
-  bool transAddressingModel();
-
-  Value *transValue(SPIRVValue *, Function *F, BasicBlock *,
-                    bool CreatePlaceHolder = true);
-  Value *transValueWithoutDecoration(SPIRVValue *, Function *F, BasicBlock *,
-                                     bool CreatePlaceHolder = true);
-  Value *transDeviceEvent(SPIRVValue *BV, Function *F, BasicBlock *BB);
-  bool transDecoration(SPIRVValue *, Value *);
-  bool transAlign(SPIRVValue *, Value *);
-  Instruction *transOCLBuiltinFromExtInst(SPIRVExtInst *BC, BasicBlock *BB);
-  std::vector<Value *> transValue(const std::vector<SPIRVValue *> &,
-                                  Function *F, BasicBlock *);
-  Function *transFunction(SPIRVFunction *F);
-  Value *transBlockInvoke(SPIRVValue *Invoke, BasicBlock *BB);
-  Instruction *transEnqueueKernelBI(SPIRVInstruction *BI, BasicBlock *BB);
-  Instruction *transWGSizeQueryBI(SPIRVInstruction *BI, BasicBlock *BB);
-  Instruction *transSGSizeQueryBI(SPIRVInstruction *BI, BasicBlock *BB);
-  bool transFPContractMetadata();
-  bool transKernelMetadata();
-  bool transNonTemporalMetadata(Instruction *I);
-  bool transSourceLanguage();
-  bool transSourceExtension();
-  void transGeneratorMD();
-  Value *transConvertInst(SPIRVValue *BV, Function *F, BasicBlock *BB);
-  Instruction *transBuiltinFromInst(const std::string &FuncName,
-                                    SPIRVInstruction *BI, BasicBlock *BB);
-  Instruction *transOCLBuiltinFromInst(SPIRVInstruction *BI, BasicBlock *BB);
-  Instruction *transSPIRVBuiltinFromInst(SPIRVInstruction *BI, BasicBlock *BB);
-  Instruction *transOCLBarrierFence(SPIRVInstruction *BI, BasicBlock *BB);
-  void transOCLVectorLoadStore(std::string &UnmangledName,
-                               std::vector<SPIRVWord> &BArgs);
-
-  /// Post-process translated LLVM module for OpenCL.
-  bool postProcessOCL();
-
-  /// \brief Post-process OpenCL builtin functions returning struct type.
-  ///
-  /// Some OpenCL builtin functions are translated to SPIR-V instructions with
-  /// struct type result, e.g. NDRange creation functions. Such functions
-  /// need to be post-processed to return the struct through sret argument.
-  bool postProcessOCLBuiltinReturnStruct(Function *F);
-
-  /// \brief Post-process OpenCL builtin functions having array argument.
-  ///
-  /// These functions are translated to functions with array type argument
-  /// first, then post-processed to have pointer arguments.
-  bool
-  postProcessOCLBuiltinWithArrayArguments(Function *F,
-                                          const std::string &DemangledName);
-
-  /// \brief Post-process OpImageSampleExplicitLod.
-  ///   sampled_image = __spirv_SampledImage__(image, sampler);
-  ///   return __spirv_ImageSampleExplicitLod__(sampled_image, image_operands,
-  ///                                           ...);
-  /// =>
-  ///   read_image(image, sampler, ...)
-  /// \return transformed call instruction.
-  Instruction *postProcessOCLReadImage(SPIRVInstruction *BI, CallInst *CI,
-                                       const std::string &DemangledName);
-
-  /// \brief Post-process OpImageWrite.
-  ///   return write_image(image, coord, color, image_operands, ...);
-  /// =>
-  ///   write_image(image, coord, ..., color)
-  /// \return transformed call instruction.
-  CallInst *postProcessOCLWriteImage(SPIRVInstruction *BI, CallInst *CI,
-                                     const std::string &DemangledName);
-
-  /// \brief Post-process OpBuildNDRange.
-  ///   OpBuildNDRange GlobalWorkSize, LocalWorkSize, GlobalWorkOffset
-  /// =>
-  ///   call ndrange_XD(GlobalWorkOffset, GlobalWorkSize, LocalWorkSize)
-  /// \return transformed call instruction.
-  CallInst *postProcessOCLBuildNDRange(SPIRVInstruction *BI, CallInst *CI,
-                                       const std::string &DemangledName);
-
-  /// \brief Expand OCL builtin functions with scalar argument, e.g.
-  /// step, smoothstep.
-  /// gentype func (fp edge, gentype x)
-  /// =>
-  /// gentype func (gentype edge, gentype x)
-  /// \return transformed call instruction.
-  CallInst *expandOCLBuiltinWithScalarArg(CallInst *CI,
-                                          const std::string &FuncName);
-
-  /// \brief Post-process OpGroupAll and OpGroupAny instructions translation.
-  /// i1 func (<n x i1> arg)
-  /// =>
-  /// i32 func (<n x i32> arg)
-  /// \return transformed call instruction.
-  Instruction *postProcessGroupAllAny(CallInst *CI,
-                                      const std::string &DemangledName);
-
-  typedef DenseMap<SPIRVType *, Type *> SPIRVToLLVMTypeMap;
-  typedef DenseMap<SPIRVValue *, Value *> SPIRVToLLVMValueMap;
-  typedef DenseMap<SPIRVValue *, Value *> SPIRVBlockToLLVMStructMap;
-  typedef DenseMap<SPIRVFunction *, Function *> SPIRVToLLVMFunctionMap;
-  typedef DenseMap<GlobalVariable *, SPIRVBuiltinVariableKind> BuiltinVarMap;
-
-  // A SPIRV value may be translated to a load instruction of a placeholder
-  // global variable. This map records load instruction of these placeholders
-  // which are supposed to be replaced by the real values later.
-  typedef std::map<SPIRVValue *, LoadInst *> SPIRVToLLVMPlaceholderMap;
-
-private:
-  Module *M;
-  BuiltinVarMap BuiltinGVMap;
-  LLVMContext *Context;
-  SPIRVModule *BM;
-  SPIRVToLLVMTypeMap TypeMap;
-  SPIRVToLLVMValueMap ValueMap;
-  SPIRVToLLVMFunctionMap FuncMap;
-  SPIRVBlockToLLVMStructMap BlockMap;
-  SPIRVToLLVMPlaceholderMap PlaceholderMap;
-  SPIRVToLLVMDbgTran DbgTran;
-
-  Type *mapType(SPIRVType *BT, Type *T) {
-    SPIRVDBG(dbgs() << *T << '\n';)
-    TypeMap[BT] = T;
-    return T;
-  }
-
-  // If a value is mapped twice, the existing mapped value is a placeholder,
-  // which must be a load instruction of a global variable whose name starts
-  // with kPlaceholderPrefix.
-  Value *mapValue(SPIRVValue *BV, Value *V) {
-    auto Loc = ValueMap.find(BV);
-    if (Loc != ValueMap.end()) {
-      if (Loc->second == V)
-        return V;
-      auto LD = dyn_cast<LoadInst>(Loc->second);
-      auto Placeholder = dyn_cast<GlobalVariable>(LD->getPointerOperand());
-      assert(LD && Placeholder &&
-             Placeholder->getName().startswith(KPlaceholderPrefix) &&
-             "A value is translated twice");
-      // Replaces placeholders for PHI nodes
-      LD->replaceAllUsesWith(V);
-      LD->eraseFromParent();
-      Placeholder->eraseFromParent();
-    }
-    ValueMap[BV] = V;
-    return V;
-  }
-
-  bool isSPIRVBuiltinVariable(GlobalVariable *GV,
-                              SPIRVBuiltinVariableKind *Kind = nullptr) {
-    auto Loc = BuiltinGVMap.find(GV);
-    if (Loc == BuiltinGVMap.end())
-      return false;
-    if (Kind)
-      *Kind = Loc->second;
-    return true;
-  }
-  // OpenCL function always has NoUnwound attribute.
-  // Change this if it is no longer true.
-  bool isFuncNoUnwind() const { return true; }
-  bool isSPIRVCmpInstTransToLLVMInst(SPIRVInstruction *BI) const;
-  bool transOCLBuiltinsFromVariables();
-  bool transOCLBuiltinFromVariable(GlobalVariable *GV,
-                                   SPIRVBuiltinVariableKind Kind);
-  MDString *transOCLKernelArgTypeName(SPIRVFunctionParameter *);
-
-  Value *mapFunction(SPIRVFunction *BF, Function *F) {
-    SPIRVDBG(spvdbgs() << "[mapFunction] " << *BF << " -> ";
-             dbgs() << *F << '\n';)
-    FuncMap[BF] = F;
-    return F;
-  }
-
-  Value *getTranslatedValue(SPIRVValue *BV);
-  Type *getTranslatedType(SPIRVType *BT);
-  IntrinsicInst *getLifetimeStartIntrinsic(Instruction *I);
-
-  SPIRVErrorLog &getErrorLog() { return BM->getErrorLog(); }
-
-  void setCallingConv(CallInst *Call) {
-    Function *F = Call->getCalledFunction();
-    assert(F);
-    Call->setCallingConv(F->getCallingConv());
-  }
-
-  void setAttrByCalledFunc(CallInst *Call);
-  Type *transFPType(SPIRVType *T);
-  BinaryOperator *transShiftLogicalBitwiseInst(SPIRVValue *BV, BasicBlock *BB,
-                                               Function *F);
-  Instruction *transCmpInst(SPIRVValue *BV, BasicBlock *BB, Function *F);
-  void transOCLBuiltinFromInstPreproc(SPIRVInstruction *BI, Type *&RetTy,
-                                      std::vector<SPIRVValue *> &Args);
-  Instruction *transOCLBuiltinPostproc(SPIRVInstruction *BI, CallInst *CI,
-                                       BasicBlock *BB,
-                                       const std::string &DemangledName);
-  std::string transOCLImageTypeName(SPIRV::SPIRVTypeImage *ST);
-  std::string transOCLSampledImageTypeName(SPIRV::SPIRVTypeSampledImage *ST);
-  std::string transOCLPipeTypeName(
-      SPIRV::SPIRVTypePipe *ST, bool UseSPIRVFriendlyFormat = false,
-      SPIRVAccessQualifierKind PipeAccess = AccessQualifierReadOnly);
-  std::string transOCLPipeStorageTypeName(SPIRV::SPIRVTypePipeStorage *PST);
-  std::string transOCLImageTypeAccessQualifier(SPIRV::SPIRVTypeImage *ST);
-  std::string transOCLPipeTypeAccessQualifier(SPIRV::SPIRVTypePipe *ST);
-
-  Value *oclTransConstantSampler(SPIRV::SPIRVConstantSampler *BCS);
-  Value *oclTransConstantPipeStorage(SPIRV::SPIRVConstantPipeStorage *BCPS);
-  void setName(llvm::Value *V, SPIRVValue *BV);
-  void setLLVMLoopMetadata(SPIRVLoopMerge *LM, BranchInst *BI);
-  void insertImageNameAccessQualifier(SPIRV::SPIRVTypeImage *ST,
-                                      std::string &Name);
-  template <class Source, class Func> bool foreachFuncCtlMask(Source, Func);
-  llvm::GlobalValue::LinkageTypes transLinkageType(const SPIRVValue *V);
-  Instruction *transOCLAllAny(SPIRVInstruction *BI, BasicBlock *BB);
-  Instruction *transOCLRelational(SPIRVInstruction *BI, BasicBlock *BB);
-
-  CallInst *transOCLBarrier(BasicBlock *BB, SPIRVWord ExecScope,
-                            SPIRVWord MemSema, SPIRVWord MemScope);
-
-  CallInst *transOCLMemFence(BasicBlock *BB, SPIRVWord MemSema,
-                             SPIRVWord MemScope);
-};
-
 Type *SPIRVToLLVM::getTranslatedType(SPIRVType *BV) {
   auto Loc = TypeMap.find(BV);
   if (Loc != TypeMap.end())
@@ -537,6 +209,14 @@ IntrinsicInst *SPIRVToLLVM::getLifetimeStartIntrinsic(Instruction *I) {
   return nullptr;
 }
 
+SPIRVErrorLog &SPIRVToLLVM::getErrorLog() { return BM->getErrorLog(); }
+
+void SPIRVToLLVM::setCallingConv(CallInst *Call) {
+  Function *F = Call->getCalledFunction();
+  assert(F && "Function pointers are not allowed in SPIRV");
+  Call->setCallingConv(F->getCallingConv());
+}
+
 void SPIRVToLLVM::setAttrByCalledFunc(CallInst *Call) {
   Function *F = Call->getCalledFunction();
   assert(F);
@@ -571,6 +251,13 @@ MDString *SPIRVToLLVM::transOCLKernelArgTypeName(SPIRVFunctionParameter *Arg) {
   return MDString::get(*Context, transTypeToOCLTypeName(Ty, !Arg->isZext()));
 }
 
+Value *SPIRVToLLVM::mapFunction(SPIRVFunction *BF, Function *F) {
+  SPIRVDBG(spvdbgs() << "[mapFunction] " << *BF << " -> ";
+           dbgs() << *F << '\n';)
+  FuncMap[BF] = F;
+  return F;
+}
+
 // Variable like GlobalInvolcationId[x] -> get_global_id(x).
 // Variable like WorkDim -> get_work_dim().
 bool SPIRVToLLVM::transOCLBuiltinFromVariable(GlobalVariable *GV,
@@ -1230,6 +917,43 @@ SPIRVToLLVM::postProcessGroupAllAny(CallInst *CI,
       &Attrs);
 }
 
+Type *SPIRVToLLVM::mapType(SPIRVType *BT, Type *T) {
+  SPIRVDBG(dbgs() << *T << '\n';)
+  TypeMap[BT] = T;
+  return T;
+}
+
+Value *SPIRVToLLVM::mapValue(SPIRVValue *BV, Value *V) {
+  auto Loc = ValueMap.find(BV);
+  if (Loc != ValueMap.end()) {
+    if (Loc->second == V)
+      return V;
+    auto LD = dyn_cast<LoadInst>(Loc->second);
+    auto Placeholder = dyn_cast<GlobalVariable>(LD->getPointerOperand());
+    assert(LD && Placeholder &&
+           Placeholder->getName().startswith(KPlaceholderPrefix) &&
+           "A value is translated twice");
+    // Replaces placeholders for PHI nodes
+    LD->replaceAllUsesWith(V);
+    LD->dropAllReferences();
+    LD->removeFromParent();
+    Placeholder->dropAllReferences();
+    Placeholder->removeFromParent();
+  }
+  ValueMap[BV] = V;
+  return V;
+}
+
+bool SPIRVToLLVM::isSPIRVBuiltinVariable(GlobalVariable *GV,
+                                         SPIRVBuiltinVariableKind *Kind) {
+  auto Loc = BuiltinGVMap.find(GV);
+  if (Loc == BuiltinGVMap.end())
+    return false;
+  if (Kind)
+    *Kind = Loc->second;
+  return true;
+}
+
 CallInst *
 SPIRVToLLVM::expandOCLBuiltinWithScalarArg(CallInst *CI,
                                            const std::string &FuncName) {
@@ -1824,10 +1548,17 @@ Value *SPIRVToLLVM::transValueWithoutDecoration(SPIRVValue *BV, Function *F,
     return mapValue(BV, Call);
   }
 
-  case OpExtInst:
-    return mapValue(
-        BV, transOCLBuiltinFromExtInst(static_cast<SPIRVExtInst *>(BV), BB));
-
+  case OpExtInst: {
+    auto *ExtInst = static_cast<SPIRVExtInst *>(BV);
+    switch (ExtInst->GetExtSetKind()) {
+    case SPIRVEIS_OpenCL:
+      return mapValue(BV, transOCLBuiltinFromExtInst(ExtInst, BB));
+    case SPIRVEIS_Debug:
+      return mapValue(BV, DbgTran->transDebugIntrinsic(ExtInst, BB));
+    default:
+      llvm_unreachable("Unknown extended instruction set!");
+    }
+  }
   case OpControlBarrier:
   case OpMemoryBarrier:
     return mapValue(
@@ -2260,6 +1991,13 @@ Instruction *SPIRVToLLVM::transBuiltinFromInst(const std::string &FuncName,
   return Inst;
 }
 
+SPIRVToLLVM::SPIRVToLLVM(Module *LLVMModule, SPIRVModule *TheSPIRVModule)
+    : M(LLVMModule), BM(TheSPIRVModule) {
+  assert(M && "Initialization without an LLVM module is not allowed");
+  Context = &M->getContext();
+  DbgTran.reset(new SPIRVToLLVMDbgTran(TheSPIRVModule, LLVMModule, this));
+}
+
 std::string SPIRVToLLVM::getOCLBuiltinName(SPIRVInstruction *BI) {
   auto OC = BI->getOpCode();
   if (OC == OpGenericCastToPtrExplicit)
@@ -2367,18 +2105,30 @@ bool SPIRVToLLVM::translate() {
   if (!transAddressingModel())
     return false;
 
-  DbgTran.createCompileUnit();
-  DbgTran.addDbgInfoVersion();
-
   for (unsigned I = 0, E = BM->getNumVariables(); I != E; ++I) {
     auto BV = BM->getVariable(I);
     if (BV->getStorageClass() != StorageClassFunction)
       transValue(BV, nullptr, nullptr);
   }
+  // Compile unit might be needed during translation of debug intrinsics.
+  for (SPIRVExtInst *EI : BM->getDebugInstVec()) {
+    // Translate Compile Unit first.
+    // It shuldn't be far from the beginig of the vector
+    if (EI->getExtOp() == SPIRVDebug::CompilationUnit) {
+      DbgTran->transDebugInst(EI);
+      // Fixme: there might be more then one Compile Unit.
+      break;
+    }
+  }
+  // Then translate all debug instructions.
+  for (SPIRVExtInst *EI : BM->getDebugInstVec()) {
+    DbgTran->transDebugInst(EI);
+  }
 
   for (unsigned I = 0, E = BM->getNumFunctions(); I != E; ++I) {
     transFunction(BM->getFunction(I));
   }
+
   if (!transKernelMetadata())
     return false;
   if (!transFPContractMetadata())
@@ -2393,7 +2143,9 @@ bool SPIRVToLLVM::translate() {
   if (!postProcessOCL())
     return false;
   eraseUselessFunctions(M);
-  DbgTran.finalize();
+
+  DbgTran->addDbgInfoVersion();
+  DbgTran->finalize();
   return true;
 }
 
@@ -2421,7 +2173,7 @@ bool SPIRVToLLVM::transAddressingModel() {
 bool SPIRVToLLVM::transDecoration(SPIRVValue *BV, Value *V) {
   if (!transAlign(BV, V))
     return false;
-  DbgTran.transDbgInfo(BV, V);
+  DbgTran->transDbgInfo(BV, V);
   return true;
 }
 
@@ -2821,7 +2573,8 @@ Instruction *SPIRVToLLVM::transOCLBarrierFence(SPIRVInstruction *MB,
 bool SPIRVToLLVM::transSourceLanguage() {
   SPIRVWord Ver = 0;
   SourceLanguage Lang = BM->getSourceLanguage(&Ver);
-  assert((Lang == SourceLanguageOpenCL_C || Lang == SourceLanguageOpenCL_CPP) &&
+  assert((Lang == SourceLanguageUnknown || // Allow unknown for debug info test
+          Lang == SourceLanguageOpenCL_C || Lang == SourceLanguageOpenCL_CPP) &&
          "Unsupported source language");
   unsigned short Major = 0;
   unsigned char Minor = 0;
diff --git a/lib/SPIRV/SPIRVReader.h b/lib/SPIRV/SPIRVReader.h
new file mode 100644
index 0000000..00f3663
--- /dev/null
+++ b/lib/SPIRV/SPIRVReader.h
@@ -0,0 +1,265 @@
+//===- SPIRVReader.h - Converts SPIR-V to LLVM ------------------*- C++ -*-===//
+//
+//                     The LLVM/SPIR-V Translator
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+// Copyright (c) 2014 Advanced Micro Devices, Inc. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the "Software"),
+// to deal with the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// Redistributions of source code must retain the above copyright notice,
+// this list of conditions and the following disclaimers.
+// Redistributions in binary form must reproduce the above copyright notice,
+// this list of conditions and the following disclaimers in the documentation
+// and/or other materials provided with the distribution.
+// Neither the names of Advanced Micro Devices, Inc., nor the names of its
+// contributors may be used to endorse or promote products derived from this
+// Software without specific prior written permission.
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
+// THE SOFTWARE.
+//
+//===----------------------------------------------------------------------===//
+/// \file
+///
+/// This file implements conversion of SPIR-V binary to LLVM IR.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef SPIRVREADER_H
+#define SPIRVREADER_H
+
+#include "SPIRVModule.h"
+
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/IR/GlobalValue.h" // llvm::GlobalValue::LinkageTypes
+
+namespace llvm {
+class Module;
+class Type;
+class Value;
+class Instruction;
+class CallInst;
+class BasicBlock;
+class Function;
+class GlobalVariable;
+class LLVMContext;
+class MDString;
+class IntrinsicInst;
+class LoadInst;
+class BranchInst;
+class BinaryOperator;
+class Value;
+} // namespace llvm
+using namespace llvm;
+
+namespace SPIRV {
+class SPIRVFunctionParameter;
+class SPIRVToLLVMDbgTran;
+class SPIRVConstantSampler;
+class SPIRVConstantPipeStorage;
+class SPIRVLoopMerge;
+
+class SPIRVToLLVM {
+public:
+  SPIRVToLLVM(Module *LLVMModule, SPIRVModule *TheSPIRVModule);
+
+  std::string getOCLBuiltinName(SPIRVInstruction *BI);
+  std::string getOCLConvertBuiltinName(SPIRVInstruction *BI);
+  std::string getOCLGenericCastToPtrName(SPIRVInstruction *BI);
+
+  Type *transType(SPIRVType *BT, bool IsClassMember = false);
+  std::string transTypeToOCLTypeName(SPIRVType *BT, bool IsSigned = true);
+  std::vector<Type *> transTypeVector(const std::vector<SPIRVType *> &);
+  bool translate();
+  bool transAddressingModel();
+
+  Value *transValue(SPIRVValue *, Function *F, BasicBlock *,
+                    bool CreatePlaceHolder = true);
+  Value *transValueWithoutDecoration(SPIRVValue *, Function *F, BasicBlock *,
+                                     bool CreatePlaceHolder = true);
+  Value *transDeviceEvent(SPIRVValue *BV, Function *F, BasicBlock *BB);
+  bool transDecoration(SPIRVValue *, Value *);
+  bool transAlign(SPIRVValue *, Value *);
+  Instruction *transOCLBuiltinFromExtInst(SPIRVExtInst *BC, BasicBlock *BB);
+  std::vector<Value *> transValue(const std::vector<SPIRVValue *> &,
+                                  Function *F, BasicBlock *);
+  Function *transFunction(SPIRVFunction *F);
+  Value *transBlockInvoke(SPIRVValue *Invoke, BasicBlock *BB);
+  Instruction *transEnqueueKernelBI(SPIRVInstruction *BI, BasicBlock *BB);
+  Instruction *transWGSizeQueryBI(SPIRVInstruction *BI, BasicBlock *BB);
+  Instruction *transSGSizeQueryBI(SPIRVInstruction *BI, BasicBlock *BB);
+  bool transFPContractMetadata();
+  bool transKernelMetadata();
+  bool transNonTemporalMetadata(Instruction *I);
+  bool transSourceLanguage();
+  bool transSourceExtension();
+  void transGeneratorMD();
+  Value *transConvertInst(SPIRVValue *BV, Function *F, BasicBlock *BB);
+  Instruction *transBuiltinFromInst(const std::string &FuncName,
+                                    SPIRVInstruction *BI, BasicBlock *BB);
+  Instruction *transOCLBuiltinFromInst(SPIRVInstruction *BI, BasicBlock *BB);
+  Instruction *transSPIRVBuiltinFromInst(SPIRVInstruction *BI, BasicBlock *BB);
+  Instruction *transOCLBarrierFence(SPIRVInstruction *BI, BasicBlock *BB);
+  void transOCLVectorLoadStore(std::string &UnmangledName,
+                               std::vector<SPIRVWord> &BArgs);
+
+  /// Post-process translated LLVM module for OpenCL.
+  bool postProcessOCL();
+
+  /// \brief Post-process OpenCL builtin functions returning struct type.
+  ///
+  /// Some OpenCL builtin functions are translated to SPIR-V instructions with
+  /// struct type result, e.g. NDRange creation functions. Such functions
+  /// need to be post-processed to return the struct through sret argument.
+  bool postProcessOCLBuiltinReturnStruct(Function *F);
+
+  /// \brief Post-process OpenCL builtin functions having array argument.
+  ///
+  /// These functions are translated to functions with array type argument
+  /// first, then post-processed to have pointer arguments.
+  bool
+  postProcessOCLBuiltinWithArrayArguments(Function *F,
+                                          const std::string &DemangledName);
+
+  /// \brief Post-process OpImageSampleExplicitLod.
+  ///   sampled_image = __spirv_SampledImage__(image, sampler);
+  ///   return __spirv_ImageSampleExplicitLod__(sampled_image, image_operands,
+  ///                                           ...);
+  /// =>
+  ///   read_image(image, sampler, ...)
+  /// \return transformed call instruction.
+  Instruction *postProcessOCLReadImage(SPIRVInstruction *BI, CallInst *CI,
+                                       const std::string &DemangledName);
+
+  /// \brief Post-process OpImageWrite.
+  ///   return write_image(image, coord, color, image_operands, ...);
+  /// =>
+  ///   write_image(image, coord, ..., color)
+  /// \return transformed call instruction.
+  CallInst *postProcessOCLWriteImage(SPIRVInstruction *BI, CallInst *CI,
+                                     const std::string &DemangledName);
+
+  /// \brief Post-process OpBuildNDRange.
+  ///   OpBuildNDRange GlobalWorkSize, LocalWorkSize, GlobalWorkOffset
+  /// =>
+  ///   call ndrange_XD(GlobalWorkOffset, GlobalWorkSize, LocalWorkSize)
+  /// \return transformed call instruction.
+  CallInst *postProcessOCLBuildNDRange(SPIRVInstruction *BI, CallInst *CI,
+                                       const std::string &DemangledName);
+
+  /// \brief Expand OCL builtin functions with scalar argument, e.g.
+  /// step, smoothstep.
+  /// gentype func (fp edge, gentype x)
+  /// =>
+  /// gentype func (gentype edge, gentype x)
+  /// \return transformed call instruction.
+  CallInst *expandOCLBuiltinWithScalarArg(CallInst *CI,
+                                          const std::string &FuncName);
+
+  /// \brief Post-process OpGroupAll and OpGroupAny instructions translation.
+  /// i1 func (<n x i1> arg)
+  /// =>
+  /// i32 func (<n x i32> arg)
+  /// \return transformed call instruction.
+  Instruction *postProcessGroupAllAny(CallInst *CI,
+                                      const std::string &DemangledName);
+
+  typedef DenseMap<SPIRVType *, Type *> SPIRVToLLVMTypeMap;
+  typedef DenseMap<SPIRVValue *, Value *> SPIRVToLLVMValueMap;
+  typedef DenseMap<SPIRVValue *, Value *> SPIRVBlockToLLVMStructMap;
+  typedef DenseMap<SPIRVFunction *, Function *> SPIRVToLLVMFunctionMap;
+  typedef DenseMap<GlobalVariable *, SPIRVBuiltinVariableKind> BuiltinVarMap;
+
+  // A SPIRV value may be translated to a load instruction of a placeholder
+  // global variable. This map records load instruction of these placeholders
+  // which are supposed to be replaced by the real values later.
+  typedef std::map<SPIRVValue *, LoadInst *> SPIRVToLLVMPlaceholderMap;
+
+private:
+  Module *M;
+  BuiltinVarMap BuiltinGVMap;
+  LLVMContext *Context;
+  SPIRVModule *BM;
+  SPIRVToLLVMTypeMap TypeMap;
+  SPIRVToLLVMValueMap ValueMap;
+  SPIRVToLLVMFunctionMap FuncMap;
+  SPIRVBlockToLLVMStructMap BlockMap;
+  SPIRVToLLVMPlaceholderMap PlaceholderMap;
+  std::unique_ptr<SPIRVToLLVMDbgTran> DbgTran;
+
+  Type *mapType(SPIRVType *BT, Type *T);
+
+  // If a value is mapped twice, the existing mapped value is a placeholder,
+  // which must be a load instruction of a global variable whose name starts
+  // with kPlaceholderPrefix.
+  Value *mapValue(SPIRVValue *BV, Value *V);
+
+  bool isSPIRVBuiltinVariable(GlobalVariable *GV,
+                              SPIRVBuiltinVariableKind *Kind = nullptr);
+
+  // OpenCL function always has NoUnwound attribute.
+  // Change this if it is no longer true.
+  bool isFuncNoUnwind() const { return true; }
+  bool isSPIRVCmpInstTransToLLVMInst(SPIRVInstruction *BI) const;
+  bool transOCLBuiltinsFromVariables();
+  bool transOCLBuiltinFromVariable(GlobalVariable *GV,
+                                   SPIRVBuiltinVariableKind Kind);
+  MDString *transOCLKernelArgTypeName(SPIRVFunctionParameter *);
+  Value *mapFunction(SPIRVFunction *BF, Function *F);
+  Value *getTranslatedValue(SPIRVValue *BV);
+  Type *getTranslatedType(SPIRVType *BT);
+  IntrinsicInst *getLifetimeStartIntrinsic(Instruction *I);
+  SPIRVErrorLog &getErrorLog();
+  void setCallingConv(CallInst *Call);
+  void setAttrByCalledFunc(CallInst *Call);
+  Type *transFPType(SPIRVType *T);
+  BinaryOperator *transShiftLogicalBitwiseInst(SPIRVValue *BV, BasicBlock *BB,
+                                               Function *F);
+  Instruction *transCmpInst(SPIRVValue *BV, BasicBlock *BB, Function *F);
+  void transOCLBuiltinFromInstPreproc(SPIRVInstruction *BI, Type *&RetTy,
+                                      std::vector<SPIRVValue *> &Args);
+  Instruction *transOCLBuiltinPostproc(SPIRVInstruction *BI, CallInst *CI,
+                                       BasicBlock *BB,
+                                       const std::string &DemangledName);
+  std::string transOCLImageTypeName(SPIRV::SPIRVTypeImage *ST);
+  std::string transOCLSampledImageTypeName(SPIRV::SPIRVTypeSampledImage *ST);
+  std::string transOCLPipeTypeName(
+      SPIRV::SPIRVTypePipe *ST, bool UseSPIRVFriendlyFormat = false,
+      SPIRVAccessQualifierKind PipeAccess = AccessQualifierReadOnly);
+  std::string transOCLPipeStorageTypeName(SPIRV::SPIRVTypePipeStorage *PST);
+  std::string transOCLImageTypeAccessQualifier(SPIRV::SPIRVTypeImage *ST);
+  std::string transOCLPipeTypeAccessQualifier(SPIRV::SPIRVTypePipe *ST);
+
+  Value *oclTransConstantSampler(SPIRV::SPIRVConstantSampler *BCS);
+  Value *oclTransConstantPipeStorage(SPIRV::SPIRVConstantPipeStorage *BCPS);
+  void setName(llvm::Value *V, SPIRVValue *BV);
+  void setLLVMLoopMetadata(SPIRVLoopMerge *LM, BranchInst *BI);
+  void insertImageNameAccessQualifier(SPIRV::SPIRVTypeImage *ST,
+                                      std::string &Name);
+  template <class Source, class Func> bool foreachFuncCtlMask(Source, Func);
+  llvm::GlobalValue::LinkageTypes transLinkageType(const SPIRVValue *V);
+  Instruction *transOCLAllAny(SPIRVInstruction *BI, BasicBlock *BB);
+  Instruction *transOCLRelational(SPIRVInstruction *BI, BasicBlock *BB);
+
+  CallInst *transOCLBarrier(BasicBlock *BB, SPIRVWord ExecScope,
+                            SPIRVWord MemSema, SPIRVWord MemScope);
+
+  CallInst *transOCLMemFence(BasicBlock *BB, SPIRVWord MemSema,
+                             SPIRVWord MemScope);
+}; // class SPIRVToLLVM
+
+} // namespace SPIRV
+
+#endif // SPIRVREADER_H
diff --git a/lib/SPIRV/SPIRVRegularizeLLVM.cpp b/lib/SPIRV/SPIRVRegularizeLLVM.cpp
index bf80af6..4a1837d 100644
--- a/lib/SPIRV/SPIRVRegularizeLLVM.cpp
+++ b/lib/SPIRV/SPIRVRegularizeLLVM.cpp
@@ -125,7 +125,8 @@ bool SPIRVRegularizeLLVM::regularize() {
       for (auto II = BI->begin(), IE = BI->end(); II != IE; ++II) {
         if (auto Call = dyn_cast<CallInst>(II)) {
           Call->setTailCall(false);
-          if (Call->getCalledFunction()->isIntrinsic())
+          Function *CF = Call->getCalledFunction();
+          if (CF && CF->isIntrinsic())
             removeFnAttr(Context, Call, Attribute::NoUnwind);
         }
 
diff --git a/lib/SPIRV/SPIRVToLLVMDbgTran.cpp b/lib/SPIRV/SPIRVToLLVMDbgTran.cpp
new file mode 100644
index 0000000..7766d96
--- /dev/null
+++ b/lib/SPIRV/SPIRVToLLVMDbgTran.cpp
@@ -0,0 +1,893 @@
+//===- SPIRVToLLVMDbgTran.cpp - Converts debug info to LLVM -----*- C++ -*-===//
+//
+//                     The LLVM/SPIR-V Translator
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+// Copyright (c) 2018 Intel Corporation. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the "Software"),
+// to deal with the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// Redistributions of source code must retain the above copyright notice,
+// this list of conditions and the following disclaimers.
+// Redistributions in binary form must reproduce the above copyright notice,
+// this list of conditions and the following disclaimers in the documentation
+// and/or other materials provided with the distribution.
+// Neither the names of Intel Corporation, nor the names of its
+// contributors may be used to endorse or promote products derived from this
+// Software without specific prior written permission.
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
+// THE SOFTWARE.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements translation of debug info from SPIR-V to LLVM metadata
+//
+//===----------------------------------------------------------------------===//
+
+#include "SPIRVToLLVMDbgTran.h"
+#include "SPIRVEntry.h"
+#include "SPIRVFunction.h"
+#include "SPIRVInstruction.h"
+#include "SPIRVInternal.h"
+#include "SPIRVReader.h"
+#include "SPIRVType.h"
+
+#include "llvm/IR/DIBuilder.h"
+#include "llvm/IR/Module.h"
+
+using namespace std;
+using namespace SPIRVDebug::Operand;
+
+namespace SPIRV {
+
+SPIRVToLLVMDbgTran::SPIRVToLLVMDbgTran(SPIRVModule *TBM, Module *TM,
+                                       SPIRVToLLVM *Reader)
+    : BM(TBM), M(TM), Builder(*M), SPIRVReader(Reader) {
+  Enable = BM->hasDebugInfo();
+}
+
+void SPIRVToLLVMDbgTran::addDbgInfoVersion() {
+  if (!Enable)
+    return;
+  M->addModuleFlag(Module::Warning, "Debug Info Version",
+                   DEBUG_METADATA_VERSION);
+}
+
+DIFile *SPIRVToLLVMDbgTran::getDIFile(const string &FileName) {
+  return getOrInsert(FileMap, FileName, [=]() {
+    splitFileName Split(FileName);
+    if (!Split.BaseName.empty())
+      return Builder.createFile(Split.BaseName, Split.Path);
+    return static_cast<DIFile *>(nullptr);
+  });
+}
+
+SPIRVExtInst *SPIRVToLLVMDbgTran::getDbgInst(const SPIRVId Id) {
+  SPIRVEntry *E = BM->getEntry(Id);
+  if (isa<OpExtInst>(E)) {
+    SPIRVExtInst *EI = static_cast<SPIRVExtInst *>(E);
+    if (EI->GetExtSetKind() == SPIRV::SPIRVEIS_Debug)
+      return EI;
+  }
+  return nullptr;
+}
+
+StringRef SPIRVToLLVMDbgTran::getString(const SPIRVId Id) {
+  SPIRVString *String = BM->get<SPIRVString>(Id);
+  assert(String && "Invalid string");
+  return String->getStr();
+}
+
+void SPIRVToLLVMDbgTran::transDbgInfo(const SPIRVValue *SV, Value *V) {
+  if (Instruction *I = dyn_cast<Instruction>(V)) {
+    const SPIRVInstruction *SI = static_cast<const SPIRVInstruction *>(SV);
+    I->setDebugLoc(transDebugScope(SI));
+  }
+}
+
+DIScope *SPIRVToLLVMDbgTran::getScope(const SPIRVEntry *ScopeInst) {
+  if (ScopeInst->getOpCode() == OpString)
+    return getDIFile(static_cast<const SPIRVString *>(ScopeInst)->getStr());
+  return transDebugInst<DIScope>(static_cast<const SPIRVExtInst *>(ScopeInst));
+}
+
+DICompileUnit *
+SPIRVToLLVMDbgTran::transCompileUnit(const SPIRVExtInst *DebugInst) {
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+
+  using namespace SPIRVDebug::Operand::CompilationUnit;
+  assert(Ops.size() == OperandCount && "Invalid number of operands");
+  M->addModuleFlag(llvm::Module::Warning, "Dwarf Version",
+                   Ops[DWARFVersionIdx]);
+  std::string File = "unknown";
+  unsigned SourceLang = llvm::dwarf::DW_LANG_OpenCL;
+  CU = Builder.createCompileUnit(SourceLang, getDIFile(File), "spirv", false,
+                                 "", 0);
+  return CU;
+}
+
+DIBasicType *SPIRVToLLVMDbgTran::transTypeBasic(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypeBasic;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() == OperandCount && "Invalid number of operands");
+  StringRef Name = getString(Ops[NameIdx]);
+  auto Tag = static_cast<SPIRVDebug::EncodingTag>(Ops[EncodingIdx]);
+  unsigned Encoding = SPIRV::DbgEncodingMap::rmap(Tag);
+  if (Encoding == 0)
+    return Builder.createUnspecifiedType(Name);
+  uint64_t Size = BM->get<SPIRVConstant>(Ops[SizeIdx])->getZExtIntValue();
+  return Builder.createBasicType(Name, Size, Encoding);
+}
+
+DIDerivedType *
+SPIRVToLLVMDbgTran::transTypeQualifier(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypeQualifier;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() == OperandCount && "Invalid number of operands");
+  DIType *BaseTy =
+      transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[BaseTypeIdx]));
+  unsigned Tag = SPIRV::DbgTypeQulifierMap::rmap(
+      static_cast<SPIRVDebug::TypeQualifierTag>(Ops[QualifierIdx]));
+  return Builder.createQualifiedType(Tag, BaseTy);
+}
+
+DIType *SPIRVToLLVMDbgTran::transTypePointer(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypePointer;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() == OperandCount && "Invalid number of operands");
+  DIType *PointeeTy = nullptr;
+  if (BM->getEntry(Ops[BaseTypeIdx])->getOpCode() != OpTypeVoid)
+    PointeeTy = transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[BaseTypeIdx]));
+  Optional<unsigned> AS;
+  if (Ops[StorageClassIdx] != ~0U) {
+    auto SC = static_cast<SPIRVStorageClassKind>(Ops[StorageClassIdx]);
+    AS = SPIRSPIRVAddrSpaceMap::rmap(SC);
+  }
+  DIType *Ty;
+  SPIRVWord Flags = Ops[FlagsIdx];
+  if (Flags & SPIRVDebug::FlagIsLValueReference)
+    Ty = Builder.createReferenceType(dwarf::DW_TAG_reference_type, PointeeTy, 0,
+                                     0, AS);
+  else if (Flags & SPIRVDebug::FlagIsRValueReference)
+    Ty = Builder.createReferenceType(dwarf::DW_TAG_rvalue_reference_type,
+                                     PointeeTy, 0, 0, AS);
+  else
+    Ty = Builder.createPointerType(PointeeTy, BM->getAddressingModel() * 32, 0,
+                                   AS);
+
+  if (Flags & SPIRVDebug::FlagIsObjectPointer)
+    Ty = Builder.createObjectPointerType(Ty);
+  else if (Flags & SPIRVDebug::FlagIsArtificial)
+    Ty = Builder.createArtificialType(Ty);
+
+  return Ty;
+}
+
+DICompositeType *
+SPIRVToLLVMDbgTran::transTypeArray(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypeArray;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+  DIType *BaseTy =
+      transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[BaseTypeIdx]));
+  size_t TotalCount = 1;
+  SmallVector<llvm::Metadata *, 8> Subscripts;
+  for (size_t i = ComponentCountIdx, e = Ops.size(); i < e; ++i) {
+    SPIRVConstant *C = BM->get<SPIRVConstant>(Ops[i]);
+    int64_t Count = static_cast<int64_t>(C->getZExtIntValue());
+    Subscripts.push_back(Builder.getOrCreateSubrange(0, Count));
+    TotalCount *= static_cast<uint64_t>(Count);
+  }
+  DINodeArray SubscriptArray = Builder.getOrCreateArray(Subscripts);
+  size_t Size = BaseTy->getSizeInBits() * TotalCount;
+  return Builder.createArrayType(Size, 0 /*align*/, BaseTy, SubscriptArray);
+}
+
+DICompositeType *
+SPIRVToLLVMDbgTran::transTypeVector(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypeVector;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+  DIType *BaseTy =
+      transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[BaseTypeIdx]));
+  SPIRVWord Count = Ops[ComponentCountIdx];
+  uint64_t Size = BaseTy->getSizeInBits() * Count;
+
+  SmallVector<llvm::Metadata *, 8> Subscripts;
+  Subscripts.push_back(Builder.getOrCreateSubrange(0, Count));
+  DINodeArray SubscriptArray = Builder.getOrCreateArray(Subscripts);
+
+  return Builder.createVectorType(Size, 0 /*align*/, BaseTy, SubscriptArray);
+}
+
+DICompositeType *
+SPIRVToLLVMDbgTran::transTypeComposite(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypeComposite;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+
+  StringRef Name = getString(Ops[NameIdx]);
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned LineNo = Ops[LineIdx];
+  DIScope *ParentScope = getScope(BM->getEntry(Ops[ParentIdx]));
+  uint64_t Size = BM->get<SPIRVConstant>(Ops[SizeIdx])->getZExtIntValue();
+
+  uint64_t Align = 0;
+  DIType *DerivedFrom = nullptr;
+  StringRef Identifier;
+
+  DINode::DIFlags Flags = DINode::FlagZero;
+  if (Ops[FlagsIdx] & SPIRVDebug::FlagIsFwdDecl)
+    Flags |= DINode::FlagFwdDecl;
+
+  DICompositeType *CT = nullptr;
+  switch (Ops[TagIdx]) {
+  case SPIRVDebug::Class:
+    CT = Builder.createClassType(
+        ParentScope, Name, File, LineNo, Size, Align, 0, Flags, DerivedFrom,
+        DINodeArray() /*elements*/, nullptr /*VTableHolder*/,
+        nullptr /*TemplateParams*/, Identifier);
+    break;
+  case SPIRVDebug::Structure:
+    CT = Builder.createStructType(ParentScope, Name, File, LineNo, Size, Align,
+                                  Flags, DerivedFrom,
+                                  DINodeArray() /*elements*/, 0 /*RunTimeLang*/,
+                                  nullptr /*VTableHolder*/, Identifier);
+    break;
+  case SPIRVDebug::Union:
+    CT = Builder.createUnionType(ParentScope, Name, File, LineNo, Size, Align,
+                                 Flags, DINodeArray(), 0 /*RuntimrLang*/,
+                                 Identifier);
+    break;
+  default:
+    llvm_unreachable("Unexpected composite type");
+    break;
+  }
+  DebugInstCache[DebugInst] = CT;
+  SmallVector<llvm::Metadata *, 8> EltTys;
+  for (size_t i = FirstMemberIdx; i < Ops.size(); ++i) {
+    EltTys.push_back(transDebugInst(BM->get<SPIRVExtInst>(Ops[i])));
+  }
+  DINodeArray Elements = Builder.getOrCreateArray(EltTys);
+  Builder.replaceArrays(CT, Elements);
+  assert(CT && "Composite type translation failed.");
+  return CT;
+}
+
+DINode *SPIRVToLLVMDbgTran::transTypeMember(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypeMember;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned LineNo = Ops[LineIdx];
+  StringRef Name = getString(Ops[NameIdx]);
+  DIScope *Scope = getScope(BM->getEntry(Ops[ParentIdx]));
+  DIType *BaseType =
+      transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[TypeIdx]));
+  uint64_t OffsetInBits =
+      BM->get<SPIRVConstant>(Ops[OffsetIdx])->getZExtIntValue();
+  unsigned SPIRVFlags = Ops[FlagsIdx];
+  DINode::DIFlags Flags = DINode::FlagZero;
+  if ((SPIRVDebug::FlagAccess & SPIRVFlags) == SPIRVDebug::FlagIsPublic) {
+    Flags |= DINode::FlagPublic;
+  } else if (SPIRVFlags & SPIRVDebug::FlagIsProtected) {
+    Flags |= DINode::FlagProtected;
+  } else if (SPIRVFlags & SPIRVDebug::FlagIsPrivate) {
+    Flags |= DINode::FlagPrivate;
+  }
+  if (SPIRVFlags & SPIRVDebug::FlagIsStaticMember)
+    Flags |= DINode::FlagStaticMember;
+
+  if (Flags & DINode::FlagStaticMember && Ops.size() > MinOperandCount) {
+    SPIRVValue *ConstVal = BM->get<SPIRVValue>(Ops[ValueIdx]);
+    assert(isConstantOpCode(ConstVal->getOpCode()) &&
+           "Static member must be a constant");
+    llvm::Value *Val = SPIRVReader->transValue(ConstVal, nullptr, nullptr);
+    return Builder.createStaticMemberType(Scope, Name, File, LineNo, BaseType,
+                                          Flags, cast<llvm::Constant>(Val));
+  }
+  uint64_t Size = BM->get<SPIRVConstant>(Ops[SizeIdx])->getZExtIntValue();
+  uint64_t Alignment = 0;
+
+  return Builder.createMemberType(Scope, Name, File, LineNo, Size, Alignment,
+                                  OffsetInBits, Flags, BaseType);
+}
+
+DINode *SPIRVToLLVMDbgTran::transTypeEnum(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypeEnum;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+
+  StringRef Name = getString(Ops[NameIdx]);
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned LineNo = Ops[LineIdx];
+  DIScope *Scope = getScope(BM->getEntry(Ops[ParentIdx]));
+  uint64_t SizeInBits = BM->get<SPIRVConstant>(Ops[SizeIdx])->getZExtIntValue();
+  unsigned AlignInBits = 0;
+  SmallVector<llvm::Metadata *, 16> Elts;
+  for (size_t i = FirstEnumeratorIdx, e = Ops.size(); i < e; i += 2) {
+    uint64_t Val = BM->get<SPIRVConstant>(Ops[i])->getZExtIntValue();
+    StringRef Name = getString(Ops[i + 1]);
+    Elts.push_back(Builder.createEnumerator(Name, Val));
+  }
+  DINodeArray Enumerators = Builder.getOrCreateArray(Elts);
+  DIType *UnderlyingType = nullptr;
+  SPIRVEntry *E = BM->getEntry(Ops[UnderlyingTypeIdx]);
+  if (!isa<OpTypeVoid>(E))
+    UnderlyingType = transDebugInst<DIType>(static_cast<SPIRVExtInst *>(E));
+  return Builder.createEnumerationType(Scope, Name, File, LineNo, SizeInBits,
+                                       AlignInBits, Enumerators, UnderlyingType,
+                                       "", UnderlyingType);
+}
+
+DINode *SPIRVToLLVMDbgTran::transTypeFunction(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypeFunction;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+
+  DINode::DIFlags Flags = DINode::FlagZero;
+  SPIRVEntry *E = BM->getEntry(Ops[ReturnTypeIdx]);
+  MDNode *RT = isa<OpTypeVoid>(E)
+                   ? nullptr
+                   : transDebugInst(BM->get<SPIRVExtInst>(Ops[ReturnTypeIdx]));
+  SmallVector<llvm::Metadata *, 16> Elements{RT};
+  for (size_t i = FirstParameterIdx, e = Ops.size(); i < e; ++i) {
+    MDNode *Param = transDebugInst(BM->get<SPIRVExtInst>(Ops[i]));
+    Elements.push_back(Param);
+  }
+  DITypeRefArray ArgTypes = Builder.getOrCreateTypeArray(Elements);
+  return Builder.createSubroutineType(ArgTypes, Flags);
+}
+
+DINode *
+SPIRVToLLVMDbgTran::transTypePtrToMember(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::PtrToMember;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= OperandCount && "Invalid number of operands");
+  SPIRVExtInst *Member = BM->get<SPIRVExtInst>(Ops[MemberTypeIdx]);
+  DIType *PointeeTy = transDebugInst<DIType>(Member);
+  SPIRVExtInst *ContainingTy = BM->get<SPIRVExtInst>(Ops[ParentIdx]);
+  DIType *BaseTy = transDebugInst<DIType>(ContainingTy);
+  return Builder.createMemberPointerType(PointeeTy, BaseTy, 0);
+}
+
+DINode *SPIRVToLLVMDbgTran::transLexicalBlock(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::LexicalBlock;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  DIScope *ParentScope = getScope(BM->getEntry(Ops[ParentIdx]));
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned LineNo = Ops[LineIdx];
+  if (Ops.size() > NameIdx) {
+    StringRef Name = getString(Ops[NameIdx]);
+    return Builder.createNameSpace(ParentScope, Name,
+                                   false /*inlined namespace*/);
+  }
+  unsigned Column = Ops[ColumnIdx];
+  return Builder.createLexicalBlock(ParentScope, File, LineNo, Column);
+}
+
+DINode *SPIRVToLLVMDbgTran::transLexicalBlockDiscriminator(
+    const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::LexicalBlockDiscriminator;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned Disc = Ops[DiscriminatorIdx];
+  DIScope *ParentScope = getScope(BM->getEntry(Ops[ParentIdx]));
+  return Builder.createLexicalBlockFile(ParentScope, File, Disc);
+}
+
+DINode *SPIRVToLLVMDbgTran::transFunction(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::Function;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+
+  StringRef Name = getString(Ops[NameIdx]);
+  DISubroutineType *Ty =
+      transDebugInst<DISubroutineType>(BM->get<SPIRVExtInst>(Ops[TypeIdx]));
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned LineNo = Ops[LineIdx];
+  DIScope *Scope = getScope(BM->getEntry(Ops[ParentIdx]));
+  StringRef LinkageName = getString(Ops[LinkageNameIdx]);
+
+  SPIRVWord SPIRVDebugFlags = Ops[FlagsIdx];
+  bool isDefinition = SPIRVDebugFlags & SPIRVDebug::FlagIsDefinition;
+  bool isOptimized = SPIRVDebugFlags & SPIRVDebug::FlagIsOptimized;
+  bool isLocal = SPIRVDebugFlags & SPIRVDebug::FlagIsLocal;
+  DINode::DIFlags Flags = DINode::FlagZero;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsArtificial)
+    Flags |= llvm::DINode::FlagArtificial;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsExplicit)
+    Flags |= llvm::DINode::FlagExplicit;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsPrototyped)
+    Flags |= llvm::DINode::FlagPrototyped;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsLValueReference)
+    Flags |= llvm::DINode::FlagLValueReference;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsRValueReference)
+    Flags |= llvm::DINode::FlagRValueReference;
+  if ((SPIRVDebugFlags & SPIRVDebug::FlagAccess) == SPIRVDebug::FlagIsPublic)
+    Flags |= llvm::DINode::FlagPublic;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsProtected)
+    Flags |= llvm::DINode::FlagProtected;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsPrivate)
+    Flags |= llvm::DINode::FlagPrivate;
+  if (BM->isEntryPoint(spv::ExecutionModelKernel, Ops[FunctionIdIdx]))
+    Flags |= llvm::DINode::FlagMainSubprogram;
+
+  unsigned ScopeLine = Ops[ScopeLineIdx];
+
+  // Function declaration descriptor
+  DISubprogram *FD = nullptr;
+  if (Ops.size() > DeclarationIdx) {
+    FD = transDebugInst<DISubprogram>(
+        BM->get<SPIRVExtInst>(Ops[DeclarationIdx]));
+  }
+
+  // Here we create fake array of template parameters. If it was plain nullptr,
+  // the template parameter operand would be removed in DISubprogram::getImpl.
+  // But we want it to be there, because if there is DebugTemplate instruction
+  // refering to this function, TransTemplate method must be able to replace the
+  // template parameter operand, thus it must be in the operands list.
+  SmallVector<llvm::Metadata *, 8> Elts;
+  DINodeArray TParams = Builder.getOrCreateArray(Elts);
+  llvm::DITemplateParameterArray TParamsArray = TParams.get();
+
+  DISubprogram *DIS = nullptr;
+  if ((isa<DICompositeType>(Scope) || isa<DINamespace>(Scope)) && !isDefinition)
+    DIS = Builder.createMethod(Scope, Name, LinkageName, File, LineNo, Ty,
+                               isLocal, isDefinition, 0, 0, 0, nullptr, Flags,
+                               isOptimized, TParamsArray);
+  else
+    DIS = Builder.createFunction(Scope, Name, LinkageName, File, LineNo, Ty,
+                                 isLocal, isDefinition, ScopeLine, Flags,
+                                 isOptimized, TParamsArray, FD);
+  DebugInstCache[DebugInst] = DIS;
+  SPIRVId RealFuncId = Ops[FunctionIdIdx];
+  FuncMap[RealFuncId] = DIS;
+
+  // Function.
+  SPIRVEntry *E = BM->getEntry(Ops[FunctionIdIdx]);
+  if (E->getOpCode() == OpFunction) {
+    SPIRVFunction *BF = static_cast<SPIRVFunction *>(E);
+    llvm::Function *F = SPIRVReader->transFunction(BF);
+    assert(F && "Translation of function failed!");
+    if (!F->hasMetadata())
+      F->setMetadata("dbg", DIS);
+  }
+  return DIS;
+}
+
+DINode *SPIRVToLLVMDbgTran::transFunctionDecl(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::FunctionDeclaration;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() == OperandCount && "Invalid number of operands");
+  // Scope
+  DIScope *Scope = getScope(BM->getEntry(Ops[ParentIdx]));
+  StringRef Name = getString(Ops[NameIdx]);
+  StringRef LinkageName = getString(Ops[LinkageNameIdx]);
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned LineNo = Ops[LineIdx];
+  DISubroutineType *Ty =
+      transDebugInst<DISubroutineType>(BM->get<SPIRVExtInst>(Ops[TypeIdx]));
+
+  SPIRVWord SPIRVDebugFlags = Ops[FlagsIdx];
+  bool isDefinition = SPIRVDebugFlags & SPIRVDebug::FlagIsDefinition;
+  bool isOptimized = SPIRVDebugFlags & SPIRVDebug::FlagIsOptimized;
+  bool isLocal = SPIRVDebugFlags & SPIRVDebug::FlagIsLocal;
+  DINode::DIFlags Flags = DINode::FlagZero;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsArtificial)
+    Flags |= llvm::DINode::FlagArtificial;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsExplicit)
+    Flags |= llvm::DINode::FlagExplicit;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsPrototyped)
+    Flags |= llvm::DINode::FlagPrototyped;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsLValueReference)
+    Flags |= llvm::DINode::FlagLValueReference;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsRValueReference)
+    Flags |= llvm::DINode::FlagRValueReference;
+  if ((SPIRVDebugFlags & SPIRVDebug::FlagAccess) == SPIRVDebug::FlagIsPublic)
+    Flags |= llvm::DINode::FlagPublic;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsProtected)
+    Flags |= llvm::DINode::FlagProtected;
+  if (SPIRVDebugFlags & SPIRVDebug::FlagIsPrivate)
+    Flags |= llvm::DINode::FlagPrivate;
+
+  DISubprogram *DIS = nullptr;
+  if (isa<DICompositeType>(Scope) || isa<DINamespace>(Scope))
+    DIS = Builder.createMethod(Scope, Name, LinkageName, File, LineNo, Ty,
+                               isLocal, isDefinition, 0, 0, 0, nullptr, Flags,
+                               isOptimized);
+  else
+    DIS = Builder.createFunction(Scope, Name, LinkageName, File, LineNo, Ty,
+                                 isLocal, isDefinition, 0, Flags, isOptimized);
+  DebugInstCache[DebugInst] = DIS;
+
+  return DIS;
+}
+
+MDNode *SPIRVToLLVMDbgTran::transGlobalVariable(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::GlobalVariable;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+
+  StringRef Name = getString(Ops[NameIdx]);
+  DIType *Ty = transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[TypeIdx]));
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned LineNo = Ops[LineIdx];
+  DIScope *Parent = getScope(BM->getEntry(Ops[ParentIdx]));
+  StringRef LinkageName = getString(Ops[LinkageNameIdx]);
+
+  DIDerivedType *StaticMemberDecl = nullptr;
+  if (Ops.size() > MinOperandCount) {
+    StaticMemberDecl = transDebugInst<DIDerivedType>(
+        BM->get<SPIRVExtInst>(Ops[StaticMemberDeclarationIdx]));
+  }
+  bool isLocal = Ops[FlagsIdx] & SPIRVDebug::FlagIsLocal;
+  bool isDefinition = Ops[FlagsIdx] & SPIRVDebug::FlagIsDefinition;
+  MDNode *VarDecl = nullptr;
+  if (isDefinition) {
+    VarDecl = Builder.createGlobalVariableExpression(Parent, Name, LinkageName,
+                                                     File, LineNo, Ty, isLocal,
+                                                     nullptr, StaticMemberDecl);
+  } else {
+    VarDecl = Builder.createTempGlobalVariableFwdDecl(
+        Parent, Name, LinkageName, File, LineNo, Ty, isLocal, StaticMemberDecl);
+    // replaceAllUsesWith call makes VarDecl non-temp.
+    // Otherwise DIBuilder will crash at finalization.
+    llvm::TempMDNode TMP(VarDecl);
+    Builder.replaceTemporary(std::move(TMP), VarDecl);
+  }
+  // If the variable has no initializer Ops[VariableIdx] is OpDebugInfoNone.
+  // Otherwise Ops[VariableIdx] may be a global variable or a constant(C++
+  // static const).
+  if (VarDecl && !getDbgInst<SPIRVDebug::DebugInfoNone>(Ops[VariableIdx])) {
+    SPIRVValue *V = BM->get<SPIRVValue>(Ops[VariableIdx]);
+    Value *Var = SPIRVReader->transValue(V, nullptr, nullptr);
+    llvm::GlobalVariable *GV = dyn_cast_or_null<llvm::GlobalVariable>(Var);
+    if (GV && !GV->hasMetadata())
+      GV->addMetadata("dbg", *VarDecl);
+  }
+  return VarDecl;
+}
+
+DINode *SPIRVToLLVMDbgTran::transLocalVariable(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::LocalVariable;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+
+  DIScope *Scope = getScope(BM->getEntry(Ops[ParentIdx]));
+  StringRef Name = getString(Ops[NameIdx]);
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned LineNo = Ops[LineIdx];
+  DIType *Ty = transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[TypeIdx]));
+  DINode::DIFlags Flags = DINode::FlagZero;
+  if (Ops.size() > ArgNumberIdx)
+    return Builder.createParameterVariable(Scope, Name, Ops[ArgNumberIdx], File,
+                                           LineNo, Ty, true, Flags);
+  return Builder.createAutoVariable(Scope, Name, File, LineNo, Ty, true, Flags);
+}
+
+DINode *SPIRVToLLVMDbgTran::transTypedef(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::Typedef;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= OperandCount && "Invalid number of operands");
+
+  DIFile *File = getFile(Ops[SourceIdx]);
+  unsigned LineNo = Ops[LineIdx];
+  StringRef Alias = getString(Ops[NameIdx]);
+  SPIRVEntry *TypeInst = BM->getEntry(Ops[BaseTypeIdx]);
+  DIType *Ty = transDebugInst<DIType>(static_cast<SPIRVExtInst *>(TypeInst));
+  DIScope *Scope = getScope(BM->getEntry(Ops[ParentIdx]));
+  assert(Scope && "Typedef should have a parent scope");
+  return Builder.createTypedef(Ty, Alias, File, LineNo, Scope);
+}
+
+DINode *SPIRVToLLVMDbgTran::transInheritance(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TypeInheritance;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= OperandCount && "Invalid number of operands");
+  DIType *Parent =
+      transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[ParentIdx]));
+  DIType *Child = transDebugInst<DIType>(BM->get<SPIRVExtInst>(Ops[ChildIdx]));
+  DINode::DIFlags Flags = DINode::FlagZero;
+  if ((Ops[FlagsIdx] & SPIRVDebug::FlagAccess) == SPIRVDebug::FlagIsPublic)
+    Flags |= llvm::DINode::FlagPublic;
+  if ((Ops[FlagsIdx] & SPIRVDebug::FlagAccess) == SPIRVDebug::FlagIsProtected)
+    Flags |= llvm::DINode::FlagProtected;
+  if ((Ops[FlagsIdx] & SPIRVDebug::FlagAccess) == SPIRVDebug::FlagIsPrivate)
+    Flags |= llvm::DINode::FlagPrivate;
+  uint64_t Offset = BM->get<SPIRVConstant>(Ops[OffsetIdx])->getZExtIntValue();
+  return Builder.createInheritance(Child, Parent, Offset, 0, Flags);
+}
+
+DINode *
+SPIRVToLLVMDbgTran::transTemplateParameter(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TemplateParameter;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= OperandCount && "Invalid number of operands");
+  StringRef Name = getString(Ops[NameIdx]);
+  SPIRVEntry *ActualType = BM->getEntry(Ops[TypeIdx]);
+  DIType *Ty = nullptr;
+  if (!isa<OpTypeVoid>(ActualType))
+    Ty = transDebugInst<DIType>(static_cast<SPIRVExtInst *>(ActualType));
+  DIScope *Context = nullptr;
+  if (!getDbgInst<SPIRVDebug::DebugInfoNone>(Ops[ValueIdx])) {
+    SPIRVValue *Val = BM->get<SPIRVValue>(Ops[ValueIdx]);
+    Value *V = SPIRVReader->transValue(Val, nullptr, nullptr);
+    return Builder.createTemplateValueParameter(Context, Name, Ty,
+                                                cast<Constant>(V));
+  }
+  return Builder.createTemplateTypeParameter(Context, Name, Ty);
+}
+
+DINode *SPIRVToLLVMDbgTran::transTemplateTemplateParameter(
+    const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TemplateTemplateParameter;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= OperandCount && "Invalid number of operands");
+  StringRef Name = getString(Ops[NameIdx]);
+  StringRef TemplName = getString(Ops[TemplateNameIdx]);
+  DIScope *Context = nullptr;
+  return Builder.createTemplateTemplateParameter(Context, Name, nullptr,
+                                                 TemplName);
+}
+
+DINode *
+SPIRVToLLVMDbgTran::transTemplateParameterPack(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::TemplateParameterPack;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+  StringRef Name = getString(Ops[NameIdx]);
+  SmallVector<llvm::Metadata *, 8> Elts;
+  for (size_t i = FirstParameterIdx, e = Ops.size(); i < e; ++i) {
+    Elts.push_back(transDebugInst(BM->get<SPIRVExtInst>(Ops[i])));
+  }
+  DINodeArray Pack = Builder.getOrCreateArray(Elts);
+  DIScope *Context = nullptr;
+  return Builder.createTemplateParameterPack(Context, Name, nullptr, Pack);
+}
+
+MDNode *SPIRVToLLVMDbgTran::transTemplate(const SPIRVExtInst *DebugInst) {
+  using namespace SPIRVDebug::Operand::Template;
+  const SPIRVWordVec &Ops = DebugInst->getArguments();
+  const size_t NumOps = Ops.size();
+  assert(NumOps >= MinOperandCount && "Invalid number of operands");
+
+  auto *Templ = BM->get<SPIRVExtInst>(Ops[TargetIdx]);
+  MDNode *D = transDebugInst(Templ);
+
+  SmallVector<llvm::Metadata *, 8> Elts;
+  for (size_t i = FirstParameterIdx; i < NumOps; ++i) {
+    Elts.push_back(transDebugInst(BM->get<SPIRVExtInst>(Ops[i])));
+  }
+  DINodeArray TParams = Builder.getOrCreateArray(Elts);
+
+  if (DICompositeType *Comp = dyn_cast<DICompositeType>(D)) {
+    Builder.replaceArrays(Comp, Comp->getElements(), TParams);
+    return Comp;
+  }
+  if (isa<DISubprogram>(D)) {
+    // This constant matches with one used in
+    // DISubprogram::getRawTemplateParams()
+    const unsigned TemplateParamsIndex = 9;
+    D->replaceOperandWith(TemplateParamsIndex, TParams.get());
+    return D;
+  }
+  llvm_unreachable("Invalid template");
+}
+
+MDNode *SPIRVToLLVMDbgTran::transExpression(const SPIRVExtInst *DebugInst) {
+  const SPIRVWordVec &Args = DebugInst->getArguments();
+  std::vector<int64_t> Ops;
+  for (SPIRVId A : Args) {
+    SPIRVExtInst *O = BM->get<SPIRVExtInst>(A);
+    const SPIRVWordVec &Operands = O->getArguments();
+    auto OpCode = static_cast<SPIRVDebug::ExpressionOpCode>(Operands[0]);
+    Ops.push_back(SPIRV::DbgExpressionOpCodeMap::rmap(OpCode));
+    for (unsigned i = 1, e = Operands.size(); i < e; ++i) {
+      Ops.push_back(Operands[i]);
+    }
+  }
+  ArrayRef<int64_t> Addr(Ops.data(), Ops.size());
+  return Builder.createExpression(Addr);
+}
+
+MDNode *SPIRVToLLVMDbgTran::transDebugInstImpl(const SPIRVExtInst *DebugInst) {
+  switch (DebugInst->getExtOp()) {
+  case SPIRVDebug::DebugInfoNone:
+    return nullptr;
+
+  case SPIRVDebug::CompilationUnit:
+    return transCompileUnit(DebugInst);
+
+  case SPIRVDebug::TypeBasic:
+    return transTypeBasic(DebugInst);
+
+  case SPIRVDebug::TypeQualifier:
+    return transTypeQualifier(DebugInst);
+
+  case SPIRVDebug::TypePointer:
+    return transTypePointer(DebugInst);
+
+  case SPIRVDebug::TypeArray:
+    return transTypeArray(DebugInst);
+
+  case SPIRVDebug::TypeVector:
+    return transTypeVector(DebugInst);
+
+  case SPIRVDebug::TypeComposite:
+    return transTypeComposite(DebugInst);
+
+  case SPIRVDebug::TypeMember:
+    return transTypeMember(DebugInst);
+
+  case SPIRVDebug::TypePtrToMember:
+    return transTypePtrToMember(DebugInst);
+
+  case SPIRVDebug::TypeEnum:
+    return transTypeEnum(DebugInst);
+
+  case SPIRVDebug::TypeFunction:
+    return transTypeFunction(DebugInst);
+
+  case SPIRVDebug::LexicalBlock:
+    return transLexicalBlock(DebugInst);
+
+  case SPIRVDebug::LexicalBlockDiscriminator:
+    return transLexicalBlockDiscriminator(DebugInst);
+
+  case SPIRVDebug::Function:
+    return transFunction(DebugInst);
+
+  case SPIRVDebug::FunctionDecl:
+    return transFunctionDecl(DebugInst);
+
+  case SPIRVDebug::GlobalVariable:
+    return transGlobalVariable(DebugInst);
+
+  case SPIRVDebug::LocalVariable:
+    return transLocalVariable(DebugInst);
+
+  case SPIRVDebug::Typedef:
+    return transTypedef(DebugInst);
+
+  case SPIRVDebug::InlinedAt:
+    return transDebugInlined(DebugInst);
+
+  case SPIRVDebug::Inheritance:
+    return transInheritance(DebugInst);
+
+  case SPIRVDebug::TypeTemplateParameter:
+    return transTemplateParameter(DebugInst);
+
+  case SPIRVDebug::TypeTemplateTemplateParameter:
+    return transTemplateTemplateParameter(DebugInst);
+
+  case SPIRVDebug::TypeTemplateParameterPack:
+    return transTemplateParameterPack(DebugInst);
+
+  case SPIRVDebug::TypeTemplate:
+    return transTemplate(DebugInst);
+
+  case SPIRVDebug::Operation: // To be translated with transExpression
+    return nullptr;
+
+  case SPIRVDebug::Expression:
+    return transExpression(DebugInst);
+
+  default:
+    llvm_unreachable("Not implemented SPIR-V debug instruction!");
+  }
+}
+
+Instruction *
+SPIRVToLLVMDbgTran::transDebugIntrinsic(const SPIRVExtInst *DebugInst,
+                                        BasicBlock *BB) {
+  auto getLocalVar = [&](SPIRVId Id) -> std::pair<DILocalVariable *, DebugLoc> {
+    auto *LV = transDebugInst<DILocalVariable>(BM->get<SPIRVExtInst>(Id));
+    DebugLoc DL = DebugLoc::get(LV->getLine(), 0, LV->getScope());
+    return std::make_pair(LV, DL);
+  };
+  auto getValue = [&](SPIRVId Id) -> Value * {
+    auto *V = BM->get<SPIRVValue>(Id);
+    return SPIRVReader->transValue(V, BB->getParent(), BB);
+  };
+  auto getExpression = [&](SPIRVId Id) -> DIExpression * {
+    return transDebugInst<DIExpression>(BM->get<SPIRVExtInst>(Id));
+  };
+  SPIRVWordVec Ops = DebugInst->getArguments();
+  switch (DebugInst->getExtOp()) {
+  case SPIRVDebug::Scope:
+  case SPIRVDebug::NoScope:
+    return nullptr;
+  case SPIRVDebug::Declare: {
+    using namespace SPIRVDebug::Operand::DebugDeclare;
+    auto LocalVar = getLocalVar(Ops[DebugLocalVarIdx]);
+    return Builder.insertDeclare(getValue(Ops[VariableIdx]), LocalVar.first,
+                                 getExpression(Ops[ExpressionIdx]),
+                                 LocalVar.second, BB);
+  }
+  case SPIRVDebug::Value: {
+    using namespace SPIRVDebug::Operand::DebugValue;
+    auto LocalVar = getLocalVar(Ops[DebugLocalVarIdx]);
+    return Builder.insertDbgValueIntrinsic(
+        getValue(Ops[ValueIdx]), LocalVar.first,
+        getExpression(Ops[ExpressionIdx]), LocalVar.second, BB);
+  }
+  default:
+    llvm_unreachable("Unknown debug intrinsic!");
+  }
+}
+
+DebugLoc SPIRVToLLVMDbgTran::transDebugScope(const SPIRVInstruction *Inst) {
+  unsigned Line = 0;
+  unsigned Col = 0;
+  MDNode *Scope = nullptr;
+  MDNode *InlinedAt = nullptr;
+  if (auto L = Inst->getLine()) {
+    Line = L->getLine();
+    Col = L->getColumn();
+  }
+  if (SPIRVEntry *S = Inst->getDebugScope()) {
+    using namespace SPIRVDebug::Operand::Scope;
+    SPIRVExtInst *DbgScope = static_cast<SPIRVExtInst *>(S);
+    SPIRVWordVec Ops = DbgScope->getArguments();
+    Scope = getScope(BM->getEntry(Ops[ScopeIdx]));
+    if (Ops.size() > InlinedAtIdx)
+      InlinedAt = transDebugInst(BM->get<SPIRVExtInst>(Ops[InlinedAtIdx]));
+  }
+  return DebugLoc::get(Line, Col, Scope, InlinedAt);
+}
+
+MDNode *SPIRVToLLVMDbgTran::transDebugInlined(const SPIRVExtInst *Inst) {
+  using namespace SPIRVDebug::Operand::InlinedAt;
+  SPIRVWordVec Ops = Inst->getArguments();
+  assert(Ops.size() >= MinOperandCount && "Invalid number of operands");
+  unsigned Line = Ops[LineIdx];
+  unsigned Col = 0; // DebugInlinedAt instruction has no column operand
+  DILocalScope *Scope =
+      cast<DILocalScope>(getScope(BM->getEntry(Ops[ScopeIdx])));
+  DILocation *InlinedAt = nullptr;
+  if (Ops.size() > InlinedIdx) {
+    InlinedAt =
+        transDebugInst<DILocation>(BM->get<SPIRVExtInst>(Ops[InlinedIdx]));
+  }
+  return DILocation::get(M->getContext(), Line, Col, Scope, InlinedAt);
+}
+
+void SPIRVToLLVMDbgTran::finalize() {
+  if (!Enable)
+    return;
+  Builder.finalize();
+}
+
+DIFile *SPIRVToLLVMDbgTran::getFile(const SPIRVId SourceId) {
+  // We can't convey source due to the bug in the debug info spec -
+  // We can't use OpSource because it has no id.
+  return getDIFile("unknown");
+}
+
+SPIRVToLLVMDbgTran::splitFileName::splitFileName(const string &FileName) {
+  auto Loc = FileName.find_last_of("/\\");
+  if (Loc != std::string::npos) {
+    BaseName = FileName.substr(Loc + 1);
+    Path = FileName.substr(0, Loc);
+  } else {
+    BaseName = FileName;
+    Path = ".";
+  }
+}
+
+} // namespace SPIRV
diff --git a/lib/SPIRV/SPIRVToLLVMDbgTran.h b/lib/SPIRV/SPIRVToLLVMDbgTran.h
new file mode 100644
index 0000000..e4312f7
--- /dev/null
+++ b/lib/SPIRV/SPIRVToLLVMDbgTran.h
@@ -0,0 +1,178 @@
+//===- SPIRVToLLVMDbgTran.h - Converts SPIR-V DebugInfo to LLVM -*- C++ -*-===//
+//
+//                     The LLVM/SPIR-V Translator
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+// Copyright (c) 2018 Intel Corporation. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the "Software"),
+// to deal with the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// Redistributions of source code must retain the above copyright notice,
+// this list of conditions and the following disclaimers.
+// Redistributions in binary form must reproduce the above copyright notice,
+// this list of conditions and the following disclaimers in the documentation
+// and/or other materials provided with the distribution.
+// Neither the names of Intel Corporation, nor the names of its
+// contributors may be used to endorse or promote products derived from this
+// Software without specific prior written permission.
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
+// THE SOFTWARE.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements translation of debug info from SPIR-V to LLVM metadata
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef SPIRVTOLLVMDBGTRAN_H
+#define SPIRVTOLLVMDBGTRAN_H
+
+#include "SPIRVInstruction.h"
+#include "SPIRVModule.h"
+
+#include "llvm/IR/DIBuilder.h"
+#include "llvm/IR/DebugLoc.h"
+
+#include <unordered_map>
+
+namespace llvm {
+class Module;
+class Value;
+class Instruction;
+class Type;
+} // namespace llvm
+using namespace llvm;
+
+namespace SPIRV {
+class SPIRVToLLVM;
+class SPIRVEntry;
+class SPIRVFunction;
+class SPIRVValue;
+
+class SPIRVToLLVMDbgTran {
+public:
+  typedef std::vector<SPIRVWord> SPIRVWordVec;
+
+  SPIRVToLLVMDbgTran(SPIRVModule *TBM, Module *TM, SPIRVToLLVM *Reader);
+  void addDbgInfoVersion();
+  void transDbgInfo(const SPIRVValue *SV, Value *V);
+  template <typename T = MDNode>
+  T *transDebugInst(const SPIRVExtInst *DebugInst) {
+    assert(DebugInst->GetExtSetKind() == SPIRVEIS_Debug &&
+           "Unexpected extended instruction set");
+    auto it = DebugInstCache.find(DebugInst);
+    if (it != DebugInstCache.end())
+      return static_cast<T *>(it->second);
+    MDNode *Res = transDebugInstImpl(DebugInst);
+    DebugInstCache[DebugInst] = Res;
+    return static_cast<T *>(Res);
+  }
+  Instruction *transDebugIntrinsic(const SPIRVExtInst *DebugInst,
+                                   BasicBlock *BB);
+  void finalize();
+
+private:
+  DIFile *getFile(const SPIRVId SourceId);
+  DIFile *getDIFile(const std::string &FileName);
+  DIFile *getDIFile(const SPIRVEntry *E);
+  unsigned getLineNo(const SPIRVEntry *E);
+
+  MDNode *transDebugInstImpl(const SPIRVExtInst *DebugInst);
+
+  llvm::DebugLoc transDebugLocation(const SPIRVExtInst *DebugInst);
+
+  llvm::DebugLoc transDebugScope(const SPIRVInstruction *Inst);
+
+  MDNode *transDebugInlined(const SPIRVExtInst *Inst);
+
+  DICompileUnit *transCompileUnit(const SPIRVExtInst *DebugInst);
+
+  DIBasicType *transTypeBasic(const SPIRVExtInst *DebugInst);
+
+  DIDerivedType *transTypeQualifier(const SPIRVExtInst *DebugInst);
+
+  DIType *transTypePointer(const SPIRVExtInst *DebugInst);
+
+  DICompositeType *transTypeArray(const SPIRVExtInst *DebugInst);
+
+  DICompositeType *transTypeVector(const SPIRVExtInst *DebugInst);
+
+  DICompositeType *transTypeComposite(const SPIRVExtInst *DebugInst);
+
+  DINode *transTypeMember(const SPIRVExtInst *DebugInst);
+
+  DINode *transTypeEnum(const SPIRVExtInst *DebugInst);
+
+  DINode *transTemplateParameter(const SPIRVExtInst *DebugInst);
+  DINode *transTemplateTemplateParameter(const SPIRVExtInst *DebugInst);
+  DINode *transTemplateParameterPack(const SPIRVExtInst *DebugInst);
+
+  MDNode *transTemplate(const SPIRVExtInst *DebugInst);
+
+  DINode *transTypeFunction(const SPIRVExtInst *DebugInst);
+
+  DINode *transTypePtrToMember(const SPIRVExtInst *DebugInst);
+
+  DINode *transLexicalBlock(const SPIRVExtInst *DebugInst);
+  DINode *transLexicalBlockDiscriminator(const SPIRVExtInst *DebugInst);
+
+  DINode *transFunction(const SPIRVExtInst *DebugInst);
+
+  DINode *transFunctionDecl(const SPIRVExtInst *DebugInst);
+
+  MDNode *transGlobalVariable(const SPIRVExtInst *DebugInst);
+
+  DINode *transLocalVariable(const SPIRVExtInst *DebugInst);
+
+  DINode *transTypedef(const SPIRVExtInst *DebugInst);
+
+  DINode *transInheritance(const SPIRVExtInst *DebugInst);
+
+  DINode *transImportedEntry(const SPIRVExtInst *DebugInst);
+
+  MDNode *transExpression(const SPIRVExtInst *DebugInst);
+
+  SPIRVModule *BM;
+  Module *M;
+  DIBuilder Builder;
+  SPIRVToLLVM *SPIRVReader;
+  DICompileUnit *CU;
+  bool Enable;
+  std::unordered_map<std::string, DIFile *> FileMap;
+  std::unordered_map<SPIRVId, DISubprogram *> FuncMap;
+  std::unordered_map<const SPIRVExtInst *, MDNode *> DebugInstCache;
+
+  struct splitFileName {
+    splitFileName(const std::string &FileName);
+    std::string BaseName;
+    std::string Path;
+  };
+
+  DIScope *getScope(const SPIRVEntry *ScopeInst);
+  SPIRVExtInst *getDbgInst(const SPIRVId Id);
+
+  template <SPIRVWord OpCode> SPIRVExtInst *getDbgInst(const SPIRVId Id) {
+    if (SPIRVExtInst *DI = getDbgInst(Id)) {
+      if (DI->getExtOp() == OpCode) {
+        return DI;
+      }
+    }
+    return nullptr;
+  }
+  StringRef getString(const SPIRVId Id);
+};
+} // namespace SPIRV
+
+#endif // SPIRVTOLLVMDBGTRAN_H
diff --git a/lib/SPIRV/SPIRVUtil.cpp b/lib/SPIRV/SPIRVUtil.cpp
index 902370e..1257a6c 100644
--- a/lib/SPIRV/SPIRVUtil.cpp
+++ b/lib/SPIRV/SPIRVUtil.cpp
@@ -793,7 +793,11 @@ Type *getVoidFuncPtrType(Module *M, unsigned AddrSpace) {
 }
 
 ConstantInt *getInt64(Module *M, int64_t Value) {
-  return ConstantInt::get(Type::getInt64Ty(M->getContext()), Value, true);
+  return ConstantInt::getSigned(Type::getInt64Ty(M->getContext()), Value);
+}
+
+ConstantInt *getUInt64(Module *M, uint64_t Value) {
+  return ConstantInt::get(Type::getInt64Ty(M->getContext()), Value, false);
 }
 
 Constant *getFloat32(Module *M, float Value) {
@@ -808,6 +812,16 @@ ConstantInt *getUInt32(Module *M, unsigned Value) {
   return ConstantInt::get(Type::getInt32Ty(M->getContext()), Value, false);
 }
 
+ConstantInt *getInt(Module *M, int64_t Value) {
+  return Value >> 32 ? getInt64(M, Value)
+                     : getInt32(M, static_cast<int32_t>(Value));
+}
+
+ConstantInt *getUInt(Module *M, uint64_t Value) {
+  return Value >> 32 ? getUInt64(M, Value)
+                     : getUInt32(M, static_cast<uint32_t>(Value));
+}
+
 ConstantInt *getUInt16(Module *M, unsigned short Value) {
   return ConstantInt::get(Type::getInt16Ty(M->getContext()), Value, false);
 }
diff --git a/lib/SPIRV/SPIRVWriter.cpp b/lib/SPIRV/SPIRVWriter.cpp
index 08849fd..66eecc2 100644
--- a/lib/SPIRV/SPIRVWriter.cpp
+++ b/lib/SPIRV/SPIRVWriter.cpp
@@ -38,8 +38,8 @@
 ///
 //===----------------------------------------------------------------------===//
 
-#include "OCLTypeToSPIRV.h"
-#include "OCLUtil.h"
+#include "SPIRVWriter.h"
+#include "LLVMToSPIRVDbgTran.h"
 #include "SPIRVBasicBlock.h"
 #include "SPIRVEntry.h"
 #include "SPIRVEnum.h"
@@ -126,185 +126,22 @@ struct OCLBuiltinSPIRVTransInfo {
   }
 };
 
-class LLVMToSPIRVDbgTran {
-public:
-  LLVMToSPIRVDbgTran(Module *TM = nullptr, SPIRVModule *TBM = nullptr)
-      : BM(TBM), M(TM) {}
-
-  void setModule(Module *Mod) { M = Mod; }
-  void setSPIRVModule(SPIRVModule *SMod) { BM = SMod; }
-
-  void transDbgInfo(Value *V, SPIRVValue *BV) {
-    if (auto I = dyn_cast<Instruction>(V)) {
-      auto DL = I->getDebugLoc();
-      if (DL) {
-        auto File = BM->getString(DL->getFilename().str());
-        BM->addLine(BV, File->getId(), DL->getLine(), DL->getColumn());
-      }
-    } else if (auto F = dyn_cast<Function>(V)) {
-      if (auto DIS = F->getSubprogram()) {
-        auto File = BM->getString(DIS->getFilename().str());
-        BM->addLine(BV, File->getId(), DIS->getLine(), 0);
-      }
-    }
-  }
-
-private:
-  SPIRVModule *BM;
-  Module *M;
-};
-
-class LLVMToSPIRV : public ModulePass {
-public:
-  LLVMToSPIRV(SPIRVModule *SMod = nullptr)
-      : ModulePass(ID), M(nullptr), Ctx(nullptr), BM(SMod),
-        ExtSetId(SPIRVID_INVALID), SrcLang(0), SrcLangVer(0),
-        DbgTran(nullptr, SMod) {}
-
-  StringRef getPassName() const override { return "LLVMToSPIRV"; }
-
-  bool runOnModule(Module &Mod) override {
-    M = &Mod;
-    Ctx = &M->getContext();
-    DbgTran.setModule(M);
-    assert(BM && "SPIR-V module not initialized");
-    translate();
-    return true;
-  }
-
-  void getAnalysisUsage(AnalysisUsage &AU) const override {
-    AU.addRequired<OCLTypeToSPIRV>();
-  }
-
-  static char ID;
-
-  SPIRVType *transType(Type *T);
-  SPIRVType *transSPIRVOpaqueType(Type *T);
-
-  SPIRVValue *getTranslatedValue(Value *) const;
-
-  // Translation functions
-  bool transAddressingMode();
-  bool transAlign(Value *V, SPIRVValue *BV);
-  std::vector<SPIRVValue *> transArguments(CallInst *, SPIRVBasicBlock *);
-  std::vector<SPIRVWord> transArguments(CallInst *, SPIRVBasicBlock *,
-                                        SPIRVEntry *);
-  bool transSourceLanguage();
-  bool transExtension();
-  bool transBuiltinSet();
-  SPIRVValue *transIntrinsicInst(IntrinsicInst *Intrinsic, SPIRVBasicBlock *BB);
-  SPIRVValue *transCallInst(CallInst *Call, SPIRVBasicBlock *BB);
-  bool transDecoration(Value *V, SPIRVValue *BV);
-  SPIRVWord transFunctionControlMask(CallInst *);
-  SPIRVWord transFunctionControlMask(Function *);
-  SPIRVFunction *transFunctionDecl(Function *F);
-  bool transGlobalVariables();
-
-  Op transBoolOpCode(SPIRVValue *Opn, Op OC);
-  // Translate LLVM module to SPIR-V module.
-  // Returns true if succeeds.
-  bool translate();
-  bool transExecutionMode();
-  SPIRVValue *transConstant(Value *V);
-  SPIRVValue *transValue(Value *V, SPIRVBasicBlock *BB,
-                         bool CreateForward = true);
-  SPIRVValue *transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
-                                          bool CreateForward = true);
-
-  typedef DenseMap<Type *, SPIRVType *> LLVMToSPIRVTypeMap;
-  typedef DenseMap<Value *, SPIRVValue *> LLVMToSPIRVValueMap;
-
-private:
-  Module *M;
-  LLVMContext *Ctx;
-  SPIRVModule *BM;
-  LLVMToSPIRVTypeMap TypeMap;
-  LLVMToSPIRVValueMap ValueMap;
-  // ToDo: support multiple builtin sets. Currently assume one builtin set.
-  SPIRVId ExtSetId;
-  SPIRVWord SrcLang;
-  SPIRVWord SrcLangVer;
-  LLVMToSPIRVDbgTran DbgTran;
-
-  SPIRVType *mapType(Type *T, SPIRVType *BT) {
-    TypeMap[T] = BT;
-    SPIRVDBG(dbgs() << "[mapType] " << *T << " => "; spvdbgs() << *BT << '\n');
-    return BT;
-  }
-
-  SPIRVValue *mapValue(Value *V, SPIRVValue *BV) {
-    auto Loc = ValueMap.find(V);
-    if (Loc != ValueMap.end()) {
-      if (Loc->second == BV)
-        return BV;
-      assert(Loc->second->isForward() &&
-             "LLVM Value is mapped to different SPIRV Values");
-      auto Forward = static_cast<SPIRVForward *>(Loc->second);
-      BM->replaceForward(Forward, BV);
-    }
-    ValueMap[V] = BV;
-    SPIRVDBG(dbgs() << "[mapValue] " << *V << " => "; spvdbgs() << *BV << "\n");
-    return BV;
-  }
+LLVMToSPIRV::LLVMToSPIRV(SPIRVModule *SMod)
+    : ModulePass(ID), M(nullptr), Ctx(nullptr), BM(SMod), SrcLang(0),
+      SrcLangVer(0) {
+  DbgTran = make_unique<LLVMToSPIRVDbgTran>(nullptr, SMod, this);
+}
 
-  SPIRVType *getSPIRVType(Type *T) { return TypeMap[T]; }
-
-  SPIRVValue *getSPIRVValue(Value *V) { return ValueMap[V]; }
-
-  SPIRVErrorLog &getErrorLog() { return BM->getErrorLog(); }
-
-  llvm::IntegerType *getSizetType();
-  std::vector<SPIRVValue *> transValue(const std::vector<Value *> &Values,
-                                       SPIRVBasicBlock *BB);
-  std::vector<SPIRVWord> transValue(const std::vector<Value *> &Values,
-                                    SPIRVBasicBlock *BB, SPIRVEntry *Entry);
-
-  SPIRVInstruction *transBinaryInst(BinaryOperator *B, SPIRVBasicBlock *BB);
-  SPIRVInstruction *transCmpInst(CmpInst *Cmp, SPIRVBasicBlock *BB);
-  SPIRVInstruction *transLifetimeIntrinsicInst(Op OC, IntrinsicInst *Intrinsic,
-                                               SPIRVBasicBlock *BB);
-
-  void dumpUsers(Value *V);
-
-  template <class ExtInstKind>
-  bool oclGetExtInstIndex(const std::string &MangledName,
-                          const std::string &DemangledName,
-                          SPIRVWord *EntryPoint);
-  void
-  oclGetMutatedArgumentTypesByBuiltin(llvm::FunctionType *FT,
-                                      std::map<unsigned, Type *> &ChangedType,
-                                      Function *F);
-
-  bool isBuiltinTransToInst(Function *F);
-  bool isBuiltinTransToExtInst(Function *F,
-                               SPIRVExtInstSetKind *BuiltinSet = nullptr,
-                               SPIRVWord *EntryPoint = nullptr,
-                               SmallVectorImpl<std::string> *Dec = nullptr);
-  bool oclIsKernel(Function *F);
-
-  bool transOCLKernelMetadata();
-
-  SPIRVInstruction *transBuiltinToInst(const std::string &DemangledName,
-                                       const std::string &MangledName,
-                                       CallInst *CI, SPIRVBasicBlock *BB);
-  SPIRVInstruction *transBuiltinToInstWithoutDecoration(Op OC, CallInst *CI,
-                                                        SPIRVBasicBlock *BB);
-  void mutateFuncArgType(const std::map<unsigned, Type *> &ChangedType,
-                         Function *F);
-
-  SPIRVValue *oclTransSpvcCastSampler(CallInst *CI, SPIRVBasicBlock *BB);
-
-  SPIRV::SPIRVInstruction *transUnaryInst(UnaryInstruction *U,
-                                          SPIRVBasicBlock *BB);
-
-  /// Add a 32 bit integer constant.
-  /// \return Id of the constant.
-  SPIRVId addInt32(int);
-  void transFunction(Function *I);
-  SPIRV::SPIRVLinkageTypeKind transLinkageType(const GlobalValue *GV);
-};
+bool LLVMToSPIRV::runOnModule(Module &Mod) {
+  M = &Mod;
+  Ctx = &M->getContext();
+  DbgTran->setModule(M);
+  assert(BM && "SPIR-V module not initialized");
+  translate();
+  return true;
+}
 
-SPIRVValue *LLVMToSPIRV::getTranslatedValue(Value *V) const {
+SPIRVValue *LLVMToSPIRV::getTranslatedValue(const Value *V) const {
   auto Loc = ValueMap.find(V);
   if (Loc != ValueMap.end())
     return Loc->second;
@@ -345,9 +182,8 @@ bool LLVMToSPIRV::isBuiltinTransToExtInst(Function *F,
   SPIRVExtInstSetKind Set = SPIRVEIS_Count;
   if (!SPIRVExtSetShortNameMap::rfind(ExtSetName, &Set))
     return false;
-  assert(Set == BM->getBuiltinSet(ExtSetId) &&
-         "Invalid extended instruction set");
-  assert(Set == SPIRVEIS_OpenCL && "Unsupported extended instruction set");
+  assert((Set == SPIRVEIS_OpenCL || Set == SPIRVEIS_Debug) &&
+         "Unsupported extended instruction set");
 
   auto ExtOpName = S.substr(Loc + 1);
   auto Splited = ExtOpName.split(kSPIRVPostfix::ExtDivider);
@@ -665,7 +501,6 @@ SPIRVFunction *LLVMToSPIRV::transFunctionDecl(Function *F) {
     BF->addDecorate(DecorationFuncParamAttr, FunctionParameterAttributeZext);
   if (Attrs.hasAttribute(AttributeList::ReturnIndex, Attribute::SExt))
     BF->addDecorate(DecorationFuncParamAttr, FunctionParameterAttributeSext);
-  DbgTran.transDbgInfo(F, BF);
   SPIRVDBG(dbgs() << "[transFunction] " << *F << " => ";
            spvdbgs() << *BF << '\n';)
   return BF;
@@ -1149,13 +984,33 @@ SPIRVValue *LLVMToSPIRV::transValueWithoutDecoration(Value *V,
   return nullptr;
 }
 
+SPIRVType *LLVMToSPIRV::mapType(Type *T, SPIRVType *BT) {
+  TypeMap[T] = BT;
+  SPIRVDBG(dbgs() << "[mapType] " << *T << " => "; spvdbgs() << *BT << '\n');
+  return BT;
+}
+
+SPIRVValue *LLVMToSPIRV::mapValue(Value *V, SPIRVValue *BV) {
+  auto Loc = ValueMap.find(V);
+  if (Loc != ValueMap.end()) {
+    if (Loc->second == BV)
+      return BV;
+    assert(Loc->second->isForward() &&
+           "LLVM Value is mapped to different SPIRV Values");
+    auto Forward = static_cast<SPIRVForward *>(Loc->second);
+    BM->replaceForward(Forward, BV);
+  }
+  ValueMap[V] = BV;
+  SPIRVDBG(dbgs() << "[mapValue] " << *V << " => "; spvdbgs() << BV << "\n");
+  return BV;
+}
+
 bool LLVMToSPIRV::transDecoration(Value *V, SPIRVValue *BV) {
   if (!transAlign(V, BV))
     return false;
   if ((isa<AtomicCmpXchgInst>(V) && cast<AtomicCmpXchgInst>(V)->isVolatile()) ||
       (isa<AtomicRMWInst>(V) && cast<AtomicRMWInst>(V)->isVolatile()))
     BV->setVolatile(true);
-  DbgTran.transDbgInfo(V, BV);
   return true;
 }
 
@@ -1173,14 +1028,14 @@ bool LLVMToSPIRV::transAlign(Value *V, SPIRVValue *BV) {
 
 /// Do this after source language is set.
 bool LLVMToSPIRV::transBuiltinSet() {
-  SPIRVWord Ver = 0;
-  (void)Ver;
-  assert((BM->getSourceLanguage(&Ver) == SourceLanguageOpenCL_C ||
-          BM->getSourceLanguage(&Ver) == SourceLanguageOpenCL_CPP) &&
-         "not supported");
-  std::stringstream SS;
-  SS << "OpenCL.std";
-  return BM->importBuiltinSet(SS.str(), &ExtSetId);
+  SPIRVId EISId;
+  if (!BM->importBuiltinSet("OpenCL.std", &EISId))
+    return false;
+  if (SPIRVMDWalker(*M).getNamedMD("llvm.dbg.cu")) {
+    if (!BM->importBuiltinSet("SPIRV.debug", &EISId))
+      return false;
+  }
+  return true;
 }
 
 /// Translate sampler* spcv.cast(i32 arg) or
@@ -1302,6 +1157,13 @@ SPIRVValue *LLVMToSPIRV::transIntrinsicInst(IntrinsicInst *II,
     return transLifetimeIntrinsicInst(OpLifetimeStart, II, BB);
   case Intrinsic::lifetime_end:
     return transLifetimeIntrinsicInst(OpLifetimeStop, II, BB);
+  // We don't want to mix translation of regular code and debug info, because
+  // it creates a mess, therefore translation of debug intrinsics is
+  // postponed until LLVMToSPIRVDbgTran::finalizeDebug...() methods.
+  case Intrinsic::dbg_declare:
+    return DbgTran->createDebugDeclarePlaceholder(cast<DbgDeclareInst>(II), BB);
+  case Intrinsic::dbg_value:
+    return DbgTran->createDebugValuePlaceholder(cast<DbgValueInst>(II), BB);
   default:
     // LLVM intrinsic functions shouldn't get to SPIRV, because they
     // would have no definition there.
@@ -1331,7 +1193,7 @@ SPIRVValue *LLVMToSPIRV::transCallInst(CallInst *CI, SPIRVBasicBlock *BB) {
                               &Dec))
     return addDecorations(
         BM->addExtInst(
-            transType(CI->getType()), ExtSetId, ExtOp,
+            transType(CI->getType()), BM->getExtInstSetId(ExtSetKind), ExtOp,
             transArguments(CI, BB,
                            SPIRVEntry::createUnique(ExtSetKind, ExtOp).get()),
             BB),
@@ -1502,6 +1364,7 @@ bool LLVMToSPIRV::translate() {
   BM->optimizeDecorates();
   BM->resolveUnknownStructFields();
   BM->createForwardPointers();
+  DbgTran->transDebugMetadata();
   return true;
 }
 
diff --git a/lib/SPIRV/SPIRVWriter.h b/lib/SPIRV/SPIRVWriter.h
new file mode 100644
index 0000000..bc14c33
--- /dev/null
+++ b/lib/SPIRV/SPIRVWriter.h
@@ -0,0 +1,184 @@
+//===- SPIRVWriter.h - Converts LLVM to SPIR-V ------------------*- C++ -*-===//
+//
+//                     The LLVM/SPIR-V Translator
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+// Copyright (c) 2014 Advanced Micro Devices, Inc. All rights reserved.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the "Software"),
+// to deal with the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// Redistributions of source code must retain the above copyright notice,
+// this list of conditions and the following disclaimers.
+// Redistributions in binary form must reproduce the above copyright notice,
+// this list of conditions and the following disclaimers in the documentation
+// and/or other materials provided with the distribution.
+// Neither the names of Advanced Micro Devices, Inc., nor the names of its
+// contributors may be used to endorse or promote products derived from this
+// Software without specific prior written permission.
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH
+// THE SOFTWARE.
+//
+//===----------------------------------------------------------------------===//
+/// \file
+///
+/// This file implements conversion of LLVM intermediate language to SPIR-V
+/// binary.
+///
+//===----------------------------------------------------------------------===//
+
+#ifndef SPIRVWRITER_H
+#define SPIRVWRITER_H
+
+#include "OCLTypeToSPIRV.h"
+#include "OCLUtil.h"
+#include "SPIRVBasicBlock.h"
+#include "SPIRVEntry.h"
+#include "SPIRVEnum.h"
+#include "SPIRVExtInst.h"
+#include "SPIRVFunction.h"
+#include "SPIRVInstruction.h"
+#include "SPIRVInternal.h"
+#include "SPIRVMDWalker.h"
+#include "SPIRVModule.h"
+#include "SPIRVType.h"
+#include "SPIRVUtil.h"
+#include "SPIRVValue.h"
+
+#include "llvm/IR/IntrinsicInst.h"
+
+#include <memory>
+
+using namespace llvm;
+using namespace SPIRV;
+using namespace OCLUtil;
+
+namespace SPIRV {
+
+class LLVMToSPIRVDbgTran;
+
+class LLVMToSPIRV : public ModulePass {
+public:
+  LLVMToSPIRV(SPIRVModule *SMod = nullptr);
+
+  virtual StringRef getPassName() const override { return "LLVMToSPIRV"; }
+
+  bool runOnModule(Module &Mod) override;
+
+  void getAnalysisUsage(AnalysisUsage &AU) const override {
+    AU.addRequired<OCLTypeToSPIRV>();
+  }
+
+  static char ID;
+
+  SPIRVType *transType(Type *T);
+  SPIRVType *transSPIRVOpaqueType(Type *T);
+
+  SPIRVValue *getTranslatedValue(const Value *) const;
+
+  // Translation functions
+  bool transAddressingMode();
+  bool transAlign(Value *V, SPIRVValue *BV);
+  std::vector<SPIRVValue *> transArguments(CallInst *, SPIRVBasicBlock *);
+  std::vector<SPIRVWord> transArguments(CallInst *, SPIRVBasicBlock *,
+                                        SPIRVEntry *);
+  bool transSourceLanguage();
+  bool transExtension();
+  bool transBuiltinSet();
+  SPIRVValue *transIntrinsicInst(IntrinsicInst *Intrinsic, SPIRVBasicBlock *BB);
+  SPIRVValue *transCallInst(CallInst *Call, SPIRVBasicBlock *BB);
+  bool transDecoration(Value *V, SPIRVValue *BV);
+  SPIRVWord transFunctionControlMask(CallInst *);
+  SPIRVWord transFunctionControlMask(Function *);
+  SPIRVFunction *transFunctionDecl(Function *F);
+  bool transGlobalVariables();
+
+  Op transBoolOpCode(SPIRVValue *Opn, Op OC);
+  // Translate LLVM module to SPIR-V module.
+  // Returns true if succeeds.
+  bool translate();
+  bool transExecutionMode();
+  SPIRVValue *transConstant(Value *V);
+  SPIRVValue *transValue(Value *V, SPIRVBasicBlock *BB,
+                         bool CreateForward = true);
+  SPIRVValue *transValueWithoutDecoration(Value *V, SPIRVBasicBlock *BB,
+                                          bool CreateForward = true);
+
+  typedef DenseMap<Type *, SPIRVType *> LLVMToSPIRVTypeMap;
+  typedef DenseMap<Value *, SPIRVValue *> LLVMToSPIRVValueMap;
+
+private:
+  Module *M;
+  LLVMContext *Ctx;
+  SPIRVModule *BM;
+  LLVMToSPIRVTypeMap TypeMap;
+  LLVMToSPIRVValueMap ValueMap;
+  SPIRVWord SrcLang;
+  SPIRVWord SrcLangVer;
+  std::unique_ptr<LLVMToSPIRVDbgTran> DbgTran;
+
+  SPIRVType *mapType(Type *T, SPIRVType *BT);
+  SPIRVValue *mapValue(Value *V, SPIRVValue *BV);
+  SPIRVType *getSPIRVType(Type *T) { return TypeMap[T]; }
+  SPIRVErrorLog &getErrorLog() { return BM->getErrorLog(); }
+  llvm::IntegerType *getSizetType();
+  std::vector<SPIRVValue *> transValue(const std::vector<Value *> &Values,
+                                       SPIRVBasicBlock *BB);
+  std::vector<SPIRVWord> transValue(const std::vector<Value *> &Values,
+                                    SPIRVBasicBlock *BB, SPIRVEntry *Entry);
+  SPIRVInstruction *transBinaryInst(BinaryOperator *B, SPIRVBasicBlock *BB);
+  SPIRVInstruction *transCmpInst(CmpInst *Cmp, SPIRVBasicBlock *BB);
+  SPIRVInstruction *transLifetimeIntrinsicInst(Op OC, IntrinsicInst *Intrinsic,
+                                               SPIRVBasicBlock *BB);
+
+  void dumpUsers(Value *V);
+
+  template <class ExtInstKind>
+  bool oclGetExtInstIndex(const std::string &MangledName,
+                          const std::string &DemangledName,
+                          SPIRVWord *EntryPoint);
+  void
+  oclGetMutatedArgumentTypesByBuiltin(llvm::FunctionType *FT,
+                                      std::map<unsigned, Type *> &ChangedType,
+                                      Function *F);
+  bool isBuiltinTransToInst(Function *F);
+  bool isBuiltinTransToExtInst(Function *F,
+                               SPIRVExtInstSetKind *BuiltinSet = nullptr,
+                               SPIRVWord *EntryPoint = nullptr,
+                               SmallVectorImpl<std::string> *Dec = nullptr);
+  bool oclIsKernel(Function *F);
+  bool transOCLKernelMetadata();
+  SPIRVInstruction *transBuiltinToInst(const std::string &DemangledName,
+                                       const std::string &MangledName,
+                                       CallInst *CI, SPIRVBasicBlock *BB);
+  SPIRVInstruction *transBuiltinToInstWithoutDecoration(Op OC, CallInst *CI,
+                                                        SPIRVBasicBlock *BB);
+  void mutateFuncArgType(const std::map<unsigned, Type *> &ChangedType,
+                         Function *F);
+
+  SPIRVValue *transSpcvCast(CallInst *CI, SPIRVBasicBlock *BB);
+  SPIRVValue *oclTransSpvcCastSampler(CallInst *CI, SPIRVBasicBlock *BB);
+  SPIRV::SPIRVInstruction *transUnaryInst(UnaryInstruction *U,
+                                          SPIRVBasicBlock *BB);
+
+  /// Add a 32 bit integer constant.
+  /// \return Id of the constant.
+  SPIRVId addInt32(int);
+  void transFunction(Function *I);
+  SPIRV::SPIRVLinkageTypeKind transLinkageType(const GlobalValue *GV);
+};
+
+} // namespace SPIRV
+
+#endif // SPIRVWRITER_H
diff --git a/lib/SPIRV/libSPIRV/SPIRV.debug.h b/lib/SPIRV/libSPIRV/SPIRV.debug.h
new file mode 100644
index 0000000..f0d18c1
--- /dev/null
+++ b/lib/SPIRV/libSPIRV/SPIRV.debug.h
@@ -0,0 +1,503 @@
+#ifndef SPIRV_DEBUG_H
+#define SPIRV_DEBUG_H
+#include "SPIRVUtil.h"
+#include "llvm/BinaryFormat/Dwarf.h"
+
+namespace SPIRVDebug {
+
+const unsigned int DebugInfoVersion = 0x00010000;
+
+// clang-format off
+
+enum Instruction {
+  DebugInfoNone                 = 0,
+  CompilationUnit               = 1,
+  TypeBasic                     = 2,
+  TypePointer                   = 3,
+  TypeQualifier                 = 4,
+  TypeArray                     = 5,
+  TypeVector                    = 6,
+  Typedef                       = 7,
+  TypeFunction                  = 8,
+  TypeEnum                      = 9,
+  TypeComposite                 = 10,
+  TypeMember                    = 11,
+  Inheritance                   = 12,
+  TypePtrToMember               = 13,
+  TypeTemplate                  = 14,
+  TypeTemplateParameter         = 15,
+  TypeTemplateParameterPack     = 16,
+  TypeTemplateTemplateParameter = 17,
+  GlobalVariable                = 18,
+  FunctionDecl                  = 19,
+  Function                      = 20,
+  LexicalBlock                  = 21,
+  LexicalBlockDiscriminator     = 22,
+  Scope                         = 23,
+  NoScope                       = 24,
+  InlinedAt                     = 25,
+  LocalVariable                 = 26,
+  InlinedVariable               = 27,
+  Declare                       = 28,
+  Value                         = 29,
+  Operation                     = 30,
+  Expression                    = 31,
+  MacroDef                      = 32,
+  MacroUndef                    = 33,
+  InstCount                     = 34
+};
+
+enum Flag {
+  FlagIsPrivate          = 1 << 0,
+  FlagIsProtected        = 1 << 1,
+  FlagIsPublic           = FlagIsPrivate | FlagIsProtected,
+  FlagAccess             = FlagIsPublic,
+  FlagIsLocal            = 1 << 2,
+  FlagIsDefinition       = 1 << 3,
+  FlagIsFwdDecl          = 1 << 4,
+  FlagIsArtificial       = 1 << 5,
+  FlagIsExplicit         = 1 << 6,
+  FlagIsPrototyped       = 1 << 7,
+  FlagIsObjectPointer    = 1 << 8,
+  FlagIsStaticMember     = 1 << 9,
+  FlagIsIndirectVariable = 1 << 10,
+  FlagIsLValueReference  = 1 << 11,
+  FlagIsRValueReference  = 1 << 12,
+  FlagIsOptimized        = 1 << 13
+};
+
+enum EncodingTag {
+  Unspecified  = 0,
+  Address      = 1,
+  Boolean      = 2,
+  Float        = 3,
+  Signed       = 4,
+  SignedChar   = 5,
+  Unsigned     = 6,
+  UnsignedChar = 7
+};
+
+enum CompositeTypeTag {
+  Class     = 0,
+  Structure = 1,
+  Union     = 2
+};
+
+enum TypeQualifierTag {
+  ConstType    = 0,
+  VolatileType = 1,
+  RestrictType = 2,
+};
+
+enum ExpressionOpCode {
+  Deref      = 0,
+  Plus       = 1,
+  Minus      = 2,
+  PlusUconst = 3,
+  BitPiece   = 4,
+  Swap       = 5,
+  Xderef     = 6,
+  StackValue = 7,
+  Constu     = 8,
+};
+
+enum ImportedEntityTag {
+  ImportedModule      = 0,
+  ImportedDeclaration = 1,
+};
+
+namespace Operand {
+
+namespace CompilationUnit {
+enum {
+  SPIRVDebugInfoVersionIdx = 0,
+  DWARFVersionIdx          = 1,
+  SourceIdx                = 2,
+  OperandCount             = 3
+};
+}
+
+namespace Source {
+enum {
+  FileIdx      = 0,
+  TextIdx      = 1,
+  OperandCount = 2
+};
+}
+
+namespace TypeBasic {
+enum {
+  NameIdx      = 0,
+  SizeIdx      = 1,
+  EncodingIdx  = 2,
+  OperandCount = 3
+};
+}
+
+namespace TypePointer {
+enum {
+  BaseTypeIdx     = 0,
+  StorageClassIdx = 1,
+  FlagsIdx        = 2,
+  OperandCount    = 3
+};
+}
+
+namespace TypeQualifier {
+enum {
+  BaseTypeIdx  = 0,
+  QualifierIdx = 1,
+  OperandCount = 2
+};
+}
+
+namespace TypeArray {
+enum {
+  BaseTypeIdx       = 0,
+  ComponentCountIdx = 1,
+  MinOperandCount   = 2
+};
+}
+
+namespace TypeVector = TypeArray;
+
+namespace Typedef {
+enum {
+  NameIdx      = 0,
+  BaseTypeIdx  = 1,
+  SourceIdx    = 2,
+  LineIdx      = 3,
+  ColumnIdx    = 4,
+  ParentIdx    = 5,
+  OperandCount = 6
+};
+}
+
+namespace TypeFunction {
+enum {
+  ReturnTypeIdx     = 0,
+  FirstParameterIdx = 1,
+  MinOperandCount   = 1
+};
+}
+
+namespace TypeEnum {
+enum {
+  NameIdx            = 0,
+  UnderlyingTypeIdx  = 1,
+  SourceIdx          = 2,
+  LineIdx            = 3,
+  ColumnIdx          = 4,
+  ParentIdx          = 5,
+  SizeIdx            = 6,
+  FlagsIdx           = 7,
+  FirstEnumeratorIdx = 8,
+  MinOperandCount    = 8
+};
+}
+
+namespace TypeComposite {
+enum {
+  NameIdx         = 0,
+  TagIdx          = 1,
+  SourceIdx       = 2,
+  LineIdx         = 3,
+  ColumnIdx       = 4,
+  ParentIdx       = 5,
+  SizeIdx         = 6,
+  FlagsIdx        = 7,
+  FirstMemberIdx  = 8,
+  MinOperandCount = 8
+};
+}
+
+namespace TypeMember {
+enum {
+  NameIdx         = 0,
+  TypeIdx         = 1,
+  SourceIdx       = 2,
+  LineIdx         = 3,
+  ColumnIdx       = 4,
+  ParentIdx       = 5,
+  OffsetIdx       = 6,
+  SizeIdx         = 7,
+  FlagsIdx        = 8,
+  ValueIdx        = 9,
+  MinOperandCount = 9
+};
+}
+
+namespace TypeInheritance {
+enum {
+  ChildIdx     = 0,
+  ParentIdx    = 1,
+  OffsetIdx    = 2,
+  SizeIdx      = 3,
+  FlagsIdx     = 4,
+  OperandCount = 5
+};
+}
+
+namespace PtrToMember {
+enum {
+  MemberTypeIdx = 0,
+  ParentIdx     = 1,
+  OperandCount  = 2
+};
+}
+
+namespace Template {
+enum {
+  TargetIdx         = 0,
+  FirstParameterIdx = 1,
+  MinOperandCount   = 1
+};
+}
+
+namespace TemplateParameter {
+enum {
+  NameIdx      = 0,
+  TypeIdx      = 1,
+  ValueIdx     = 2,
+  SourceIdx    = 3,
+  LineIdx      = 4,
+  ColumnIdx    = 5,
+  OperandCount = 6
+};
+}
+
+namespace TemplateTemplateParameter {
+enum {
+  NameIdx         = 0,
+  TemplateNameIdx = 1,
+  SourceIdx       = 2,
+  LineIdx         = 3,
+  ColumnIdx       = 4,
+  OperandCount    = 4
+};
+}
+
+namespace TemplateParameterPack {
+enum {
+  NameIdx           = 0,
+  SourceIdx         = 1,
+  LineIdx           = 2,
+  ColumnIdx         = 3,
+  FirstParameterIdx = 4,
+  MinOperandCount   = 4
+};
+}
+
+namespace GlobalVariable {
+enum {
+  NameIdx                    = 0,
+  TypeIdx                    = 1,
+  SourceIdx                  = 2,
+  LineIdx                    = 3,
+  ColumnIdx                  = 4,
+  ParentIdx                  = 5,
+  LinkageNameIdx             = 6,
+  VariableIdx                = 7,
+  FlagsIdx                   = 8,
+  StaticMemberDeclarationIdx = 9,
+  MinOperandCount            = 9
+};
+}
+
+namespace FunctionDeclaration {
+enum {
+  NameIdx        = 0,
+  TypeIdx        = 1,
+  SourceIdx      = 2,
+  LineIdx        = 3,
+  ColumnIdx      = 4,
+  ParentIdx      = 5,
+  LinkageNameIdx = 6,
+  FlagsIdx       = 7,
+  OperandCount   = 8
+};
+}
+
+namespace Function {
+enum {
+  NameIdx         = 0,
+  TypeIdx         = 1,
+  SourceIdx       = 2,
+  LineIdx         = 3,
+  ColumnIdx       = 4,
+  ParentIdx       = 5,
+  LinkageNameIdx  = 6,
+  FlagsIdx        = 7,
+  ScopeLineIdx    = 8,
+  FunctionIdIdx   = 9,
+  DeclarationIdx  = 10,
+  MinOperandCount = 10
+};
+}
+
+namespace LexicalBlock {
+enum {
+  SourceIdx       = 0,
+  LineIdx         = 1,
+  ColumnIdx       = 2,
+  ParentIdx       = 3,
+  NameIdx         = 4,
+  MinOperandCount = 4
+};
+}
+
+namespace LexicalBlockDiscriminator {
+enum {
+  SourceIdx        = 0,
+  DiscriminatorIdx = 1,
+  ParentIdx        = 2,
+  OperandCount     = 3
+};
+}
+
+namespace Scope {
+enum {
+  ScopeIdx        = 0,
+  InlinedAtIdx    = 1,
+  MinOperandCount = 1
+};
+}
+
+namespace NoScope {
+// No operands
+}
+
+namespace InlinedAt {
+enum {
+  LineIdx         = 0,
+  ScopeIdx        = 1,
+  InlinedIdx      = 2,
+  MinOperandCount = 2
+};
+}
+
+namespace LocalVariable {
+enum {
+  NameIdx         = 0,
+  TypeIdx         = 1,
+  SourceIdx       = 2,
+  LineIdx         = 3,
+  ColumnIdx       = 4,
+  ParentIdx       = 5,
+  ArgNumberIdx    = 6,
+  MinOperandCount = 6
+};
+}
+
+namespace InlinedVariable {
+enum {
+  VariableIdx  = 0,
+  InlinedIdx   = 1,
+  OperandCount = 2
+};
+}
+
+namespace DebugDeclare {
+enum {
+  DebugLocalVarIdx = 0,
+  VariableIdx      = 1,
+  ExpressionIdx    = 2,
+  OperandCount     = 3
+};
+}
+
+namespace DebugValue {
+enum {
+  DebugLocalVarIdx     = 0,
+  ValueIdx             = 1,
+  ExpressionIdx        = 2,
+  FirstIndexOperandIdx = 3,
+  MinOperandCount      = 3
+};
+}
+
+namespace Operation {
+enum {
+  OpCodeIdx = 0
+};
+static std::map<ExpressionOpCode, unsigned> OpCountMap {
+  { Deref,      1 },
+  { Plus,       2 },
+  { Minus,      2 },
+  { PlusUconst, 2 },
+  { BitPiece,   3 },
+  { Swap,       1 },
+  { Xderef,     1 },
+  { StackValue, 1 },
+  { Constu,     2 }
+};
+}
+
+namespace ImportedEntity {
+enum {
+  NameIdx      = 0,
+  TagIdx       = 1,
+  SourceIdx    = 3,
+  EntityIdx    = 4,
+  LineIdx      = 5,
+  ColumnIdx    = 6,
+  ParentIdx    = 7,
+  OperandCount = 8
+};
+}
+
+} // namespace Operand
+} // namespace SPIRVDebug
+
+using namespace llvm;
+
+namespace SPIRV {
+typedef SPIRVMap<dwarf::TypeKind, SPIRVDebug::EncodingTag> DbgEncodingMap;
+template <>
+inline void DbgEncodingMap::init() {
+  add(static_cast<dwarf::TypeKind>(0), SPIRVDebug::Unspecified);
+  add(dwarf::DW_ATE_address,           SPIRVDebug::Address);
+  add(dwarf::DW_ATE_boolean,           SPIRVDebug::Boolean);
+  add(dwarf::DW_ATE_float,             SPIRVDebug::Float);
+  add(dwarf::DW_ATE_signed,            SPIRVDebug::Signed);
+  add(dwarf::DW_ATE_signed_char,       SPIRVDebug::SignedChar);
+  add(dwarf::DW_ATE_unsigned,          SPIRVDebug::Unsigned);
+  add(dwarf::DW_ATE_unsigned_char,     SPIRVDebug::UnsignedChar);
+}
+
+typedef SPIRVMap<dwarf::Tag, SPIRVDebug::TypeQualifierTag> DbgTypeQulifierMap;
+template <>
+inline void DbgTypeQulifierMap::init() {
+  add(dwarf::DW_TAG_const_type,    SPIRVDebug::ConstType);
+  add(dwarf::DW_TAG_volatile_type, SPIRVDebug::VolatileType);
+  add(dwarf::DW_TAG_restrict_type, SPIRVDebug::RestrictType);
+}
+
+typedef SPIRVMap<dwarf::Tag, SPIRVDebug::CompositeTypeTag> DbgCompositeTypeMap;
+template <>
+inline void DbgCompositeTypeMap::init() {
+  add(dwarf::DW_TAG_class_type,     SPIRVDebug::Class);
+  add(dwarf::DW_TAG_structure_type, SPIRVDebug::Structure);
+  add(dwarf::DW_TAG_union_type,     SPIRVDebug::Union);
+}
+
+typedef SPIRVMap<dwarf::LocationAtom, SPIRVDebug::ExpressionOpCode>
+  DbgExpressionOpCodeMap;
+template <>
+inline void DbgExpressionOpCodeMap::init() {
+  add(dwarf::DW_OP_deref,         SPIRVDebug::Deref);
+  add(dwarf::DW_OP_plus,          SPIRVDebug::Plus);
+  add(dwarf::DW_OP_minus,         SPIRVDebug::Minus);
+  add(dwarf::DW_OP_plus_uconst,   SPIRVDebug::PlusUconst);
+  add(dwarf::DW_OP_bit_piece,     SPIRVDebug::BitPiece);
+  add(dwarf::DW_OP_swap,          SPIRVDebug::Swap);
+  add(dwarf::DW_OP_xderef,        SPIRVDebug::Xderef);
+  add(dwarf::DW_OP_stack_value,   SPIRVDebug::StackValue);
+  add(dwarf::DW_OP_constu,        SPIRVDebug::Constu);
+}
+
+// clang-format on
+
+} // namespace SPIRV
+
+#endif // SPIRV_DEBUG_H
diff --git a/lib/SPIRV/libSPIRV/SPIRVBasicBlock.cpp b/lib/SPIRV/libSPIRV/SPIRVBasicBlock.cpp
index f749337..bae4274 100644
--- a/lib/SPIRV/libSPIRV/SPIRVBasicBlock.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVBasicBlock.cpp
@@ -59,11 +59,17 @@ SPIRVDecoder SPIRVBasicBlock::getDecoder(std::istream &IS) {
 }
 
 /// Assume I contains valid Id.
-SPIRVInstruction *SPIRVBasicBlock::addInstruction(SPIRVInstruction *I) {
+SPIRVInstruction *
+SPIRVBasicBlock::addInstruction(SPIRVInstruction *I,
+                                const SPIRVInstruction *InsertBefore) {
   assert(I && "Invalid instruction");
   Module->add(I);
   I->setParent(this);
-  InstVec.push_back(I);
+  if (InsertBefore) {
+    auto Pos = std::find(InstVec.begin(), InstVec.end(), InsertBefore);
+    InstVec.insert(Pos, I);
+  } else
+    InstVec.push_back(I);
   return I;
 }
 
diff --git a/lib/SPIRV/libSPIRV/SPIRVBasicBlock.h b/lib/SPIRV/libSPIRV/SPIRVBasicBlock.h
index 624e369..867cd3a 100644
--- a/lib/SPIRV/libSPIRV/SPIRVBasicBlock.h
+++ b/lib/SPIRV/libSPIRV/SPIRVBasicBlock.h
@@ -76,7 +76,9 @@ public:
 
   void setScope(SPIRVEntry *Scope) override;
   void setParent(SPIRVFunction *F) { ParentF = F; }
-  SPIRVInstruction *addInstruction(SPIRVInstruction *I);
+  SPIRVInstruction *
+  addInstruction(SPIRVInstruction *I,
+                 const SPIRVInstruction *InsertBefore = nullptr);
   void eraseInstruction(const SPIRVInstruction *I) {
     auto Loc = find(I);
     assert(Loc != InstVec.end());
diff --git a/lib/SPIRV/libSPIRV/SPIRVEntry.cpp b/lib/SPIRV/libSPIRV/SPIRVEntry.cpp
index fa7ae69..4bfb1ff 100644
--- a/lib/SPIRV/libSPIRV/SPIRVEntry.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVEntry.cpp
@@ -338,9 +338,28 @@ bool SPIRVEntry::hasLinkageType() const {
   return OpCode == OpFunction || OpCode == OpVariable;
 }
 
+bool SPIRVEntry::isExtInst(const SPIRVExtInstSetKind InstSet) const {
+  if (isExtInst()) {
+    const SPIRVExtInst *EI = static_cast<const SPIRVExtInst *>(this);
+    return EI->GetExtSetKind() == InstSet;
+  }
+  return false;
+}
+
+bool SPIRVEntry::isExtInst(const SPIRVExtInstSetKind InstSet,
+                           const SPIRVWord ExtOp) const {
+  if (isExtInst()) {
+    const SPIRVExtInst *EI = static_cast<const SPIRVExtInst *>(this);
+    if (EI->GetExtSetKind() == InstSet) {
+      return EI->getExtOp() == ExtOp;
+    }
+  }
+  return false;
+}
+
 void SPIRVEntry::encodeDecorate(spv_ostream &O) const {
-  for (auto &I : Decorates)
-    O << *I.second;
+  for (auto &i : Decorates)
+    O << *i.second;
 }
 
 SPIRVLinkageTypeKind SPIRVEntry::getLinkageType() const {
diff --git a/lib/SPIRV/libSPIRV/SPIRVEntry.h b/lib/SPIRV/libSPIRV/SPIRVEntry.h
index 9411fa5..4004de9 100644
--- a/lib/SPIRV/libSPIRV/SPIRVEntry.h
+++ b/lib/SPIRV/libSPIRV/SPIRVEntry.h
@@ -297,7 +297,10 @@ public:
   bool hasLinkageType() const;
   bool isAtomic() const { return isAtomicOpCode(OpCode); }
   bool isBasicBlock() const { return isLabel(); }
-  bool isBuiltinCall() const { return OpCode == OpExtInst; }
+  bool isExtInst() const { return OpCode == OpExtInst; }
+  bool isExtInst(const SPIRVExtInstSetKind InstSet) const;
+  bool isExtInst(const SPIRVExtInstSetKind InstSet,
+                 const SPIRVWord ExtOp) const;
   bool isDecorate() const { return OpCode == OpDecorate; }
   bool isMemberDecorate() const { return OpCode == OpMemberDecorate; }
   bool isForward() const { return OpCode == OpForward; }
diff --git a/lib/SPIRV/libSPIRV/SPIRVEnum.h b/lib/SPIRV/libSPIRV/SPIRVEnum.h
index 8c902d1..e3b53bb 100644
--- a/lib/SPIRV/libSPIRV/SPIRVEnum.h
+++ b/lib/SPIRV/libSPIRV/SPIRVEnum.h
@@ -77,6 +77,7 @@ enum SPIRVInstructionSchemaKind {
 
 enum SPIRVExtInstSetKind {
   SPIRVEIS_OpenCL,
+  SPIRVEIS_Debug,
   SPIRVEIS_Count,
 };
 
@@ -114,6 +115,7 @@ typedef std::vector<SPIRVCapabilityKind> SPIRVCapVec;
 
 template <> inline void SPIRVMap<SPIRVExtInstSetKind, std::string>::init() {
   add(SPIRVEIS_OpenCL, "OpenCL.std");
+  add(SPIRVEIS_Debug, "SPIRV.debug");
 }
 typedef SPIRVMap<SPIRVExtInstSetKind, std::string> SPIRVBuiltinSetNameMap;
 
diff --git a/lib/SPIRV/libSPIRV/SPIRVExtInst.h b/lib/SPIRV/libSPIRV/SPIRVExtInst.h
index 94fd8f9..af826e3 100644
--- a/lib/SPIRV/libSPIRV/SPIRVExtInst.h
+++ b/lib/SPIRV/libSPIRV/SPIRVExtInst.h
@@ -41,6 +41,7 @@
 #define SPIRV_LIBSPIRV_SPIRVEXTINST_H
 
 #include "OpenCL.std.h"
+#include "SPIRV.debug.h"
 #include "SPIRVEnum.h"
 #include "SPIRVUtil.h"
 
@@ -49,10 +50,6 @@
 
 namespace SPIRV {
 
-inline bool isOpenCLBuiltinSet(SPIRVExtInstSetKind Set) {
-  return Set == SPIRVEIS_OpenCL;
-}
-
 typedef OpenCLLIB::Entrypoints OCLExtOpKind;
 
 template <> inline void SPIRVMap<OCLExtOpKind, std::string>::init() {
@@ -251,6 +248,44 @@ template <> inline void SPIRVMap<OCLExtOpKind, std::string>::init() {
 }
 SPIRV_DEF_NAMEMAP(OCLExtOpKind, OCLExtOpMap)
 
+typedef SPIRVDebug::Instruction SPIRVDebugExtOpKind;
+template <> inline void SPIRVMap<SPIRVDebugExtOpKind, std::string>::init() {
+  add(SPIRVDebug::DebugInfoNone, "DebugInfoNone");
+  add(SPIRVDebug::CompilationUnit, "DebugCompileUnit");
+  add(SPIRVDebug::TypeBasic, "DebugTypeBasic");
+  add(SPIRVDebug::TypePointer, "DebugTypePointer");
+  add(SPIRVDebug::TypeArray, "DebugTypeArray");
+  add(SPIRVDebug::TypeVector, "DebugTypeVector");
+  add(SPIRVDebug::TypeQualifier, "DebugTypeQualifier");
+  add(SPIRVDebug::TypeFunction, "DebugTypeFunction");
+  add(SPIRVDebug::TypeComposite, "DebugTypeComposite");
+  add(SPIRVDebug::TypeMember, "DebugTypeMember");
+  add(SPIRVDebug::TypeEnum, "DebugTypeEnum");
+  add(SPIRVDebug::Typedef, "DebugTypedef");
+  add(SPIRVDebug::TypeTemplateParameter, "DebugTemplateParameter");
+  add(SPIRVDebug::TypeTemplateParameterPack, "DebugTemplateParameterPack");
+  add(SPIRVDebug::TypeTemplateTemplateParameter,
+      "DebugTemplateTemplateParameter");
+  add(SPIRVDebug::TypeTemplate, "DebugTemplate");
+  add(SPIRVDebug::TypePtrToMember, "DebugTypePtrToMember,");
+  add(SPIRVDebug::Inheritance, "DebugInheritance");
+  add(SPIRVDebug::Function, "DebugFunction");
+  add(SPIRVDebug::FunctionDecl, "DebugFunctionDecl");
+  add(SPIRVDebug::LexicalBlock, "DebugLexicalBlock");
+  add(SPIRVDebug::LexicalBlockDiscriminator, "LexicalBlockDiscriminator");
+  add(SPIRVDebug::LocalVariable, "DebugLocalVariable");
+  add(SPIRVDebug::InlinedVariable, "DebugInlinedVariable");
+  add(SPIRVDebug::GlobalVariable, "DebugGlobalVariable");
+  add(SPIRVDebug::Declare, "DebugDeclare");
+  add(SPIRVDebug::Value, "DebugValue");
+  add(SPIRVDebug::Scope, "DebugScope");
+  add(SPIRVDebug::NoScope, "DebugNoScope");
+  add(SPIRVDebug::InlinedAt, "DebugInlinedAt");
+  add(SPIRVDebug::Expression, "DebugExpression");
+  add(SPIRVDebug::Operation, "DebugOperation");
+}
+SPIRV_DEF_NAMEMAP(SPIRVDebugExtOpKind, SPIRVDebugExtOpMap)
+
 inline bool isReadImage(SPIRVWord EntryPoint) {
   return EntryPoint >= OpenCLLIB::Read_imagef &&
          EntryPoint <= OpenCLLIB::Read_imageui;
diff --git a/lib/SPIRV/libSPIRV/SPIRVFunction.cpp b/lib/SPIRV/libSPIRV/SPIRVFunction.cpp
index f395341..7f72bf6 100644
--- a/lib/SPIRV/libSPIRV/SPIRVFunction.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVFunction.cpp
@@ -108,7 +108,6 @@ void SPIRVFunction::decode(std::istream &I) {
       Param->setParent(this);
       Parameters.push_back(Param);
       Decoder.getWordCountAndOpCode();
-      continue;
       break;
     }
     case OpLabel: {
@@ -130,6 +129,7 @@ void SPIRVFunction::decodeBB(SPIRVDecoder &Decoder) {
   SPIRVDBG(spvdbgs() << "Decode BB: " << BB->getId() << '\n');
 
   Decoder.setScope(BB);
+  SPIRVEntry *DebugScope = nullptr;
   while (Decoder.getWordCountAndOpCode()) {
     if (Decoder.OpCode == OpFunctionEnd || Decoder.OpCode == OpLabel) {
       break;
@@ -140,13 +140,20 @@ void SPIRVFunction::decodeBB(SPIRVDecoder &Decoder) {
       continue;
     }
 
-    SPIRVInstruction *Inst =
-        static_cast<SPIRVInstruction *>(Decoder.getEntry());
+    auto *Inst = static_cast<SPIRVInstruction *>(Decoder.getEntry());
     assert(Inst);
-    if (Inst->getOpCode() != OpUndef)
-      BB->addInstruction(Inst);
-    else
+    if (Inst->getOpCode() == OpUndef) {
       Module->add(Inst);
+    } else {
+      if (Inst->isExtInst(SPIRVEIS_Debug, SPIRVDebug::Scope)) {
+        DebugScope = Inst;
+      } else if (Inst->isExtInst(SPIRVEIS_Debug, SPIRVDebug::NoScope)) {
+        DebugScope = nullptr;
+      } else {
+        Inst->setDebugScope(DebugScope);
+      }
+      BB->addInstruction(Inst);
+    }
   }
   Decoder.setScope(this);
 }
diff --git a/lib/SPIRV/libSPIRV/SPIRVInstruction.cpp b/lib/SPIRV/libSPIRV/SPIRVInstruction.cpp
index dd9ce84..b587069 100644
--- a/lib/SPIRV/libSPIRV/SPIRVInstruction.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVInstruction.cpp
@@ -50,33 +50,46 @@ SPIRVInstruction::SPIRVInstruction(unsigned TheWordCount, Op TheOC,
                                    SPIRVType *TheType, SPIRVId TheId,
                                    SPIRVBasicBlock *TheBB)
     : SPIRVValue(TheBB->getModule(), TheWordCount, TheOC, TheType, TheId),
-      BB(TheBB) {
+      BB(TheBB), DebugScope(nullptr) {
   validate();
 }
 
 SPIRVInstruction::SPIRVInstruction(unsigned TheWordCount, Op TheOC,
                                    SPIRVType *TheType, SPIRVId TheId,
                                    SPIRVBasicBlock *TheBB, SPIRVModule *TheBM)
-    : SPIRVValue(TheBM, TheWordCount, TheOC, TheType, TheId), BB(TheBB) {
+    : SPIRVValue(TheBM, TheWordCount, TheOC, TheType, TheId), BB(TheBB),
+      DebugScope(nullptr) {
   validate();
 }
 
 // Complete constructor for instruction with id but no type
 SPIRVInstruction::SPIRVInstruction(unsigned TheWordCount, Op TheOC,
                                    SPIRVId TheId, SPIRVBasicBlock *TheBB)
-    : SPIRVValue(TheBB->getModule(), TheWordCount, TheOC, TheId), BB(TheBB) {
+    : SPIRVValue(TheBB->getModule(), TheWordCount, TheOC, TheId), BB(TheBB),
+      DebugScope(nullptr) {
   validate();
 }
 // Complete constructor for instruction without type and id
 SPIRVInstruction::SPIRVInstruction(unsigned TheWordCount, Op TheOC,
                                    SPIRVBasicBlock *TheBB)
-    : SPIRVValue(TheBB->getModule(), TheWordCount, TheOC), BB(TheBB) {
+    : SPIRVValue(TheBB->getModule(), TheWordCount, TheOC), BB(TheBB),
+      DebugScope(nullptr) {
   validate();
 }
 // Complete constructor for instruction with type but no id
 SPIRVInstruction::SPIRVInstruction(unsigned TheWordCount, Op TheOC,
                                    SPIRVType *TheType, SPIRVBasicBlock *TheBB)
-    : SPIRVValue(TheBB->getModule(), TheWordCount, TheOC, TheType), BB(TheBB) {
+    : SPIRVValue(TheBB->getModule(), TheWordCount, TheOC, TheType), BB(TheBB),
+      DebugScope(nullptr) {
+  validate();
+}
+
+// Special constructor for debug instruction
+SPIRVInstruction::SPIRVInstruction(unsigned TheWordCount, Op TheOC,
+                                   SPIRVType *TheType, SPIRVId TheId,
+                                   SPIRVModule *TheBM, SPIRVBasicBlock *TheBB)
+    : SPIRVValue(TheBM, TheWordCount, TheOC, TheType, TheId), BB(TheBB),
+      DebugScope(nullptr) {
   validate();
 }
 
diff --git a/lib/SPIRV/libSPIRV/SPIRVInstruction.h b/lib/SPIRV/libSPIRV/SPIRVInstruction.h
index 98ea94b..c6eedaf 100644
--- a/lib/SPIRV/libSPIRV/SPIRVInstruction.h
+++ b/lib/SPIRV/libSPIRV/SPIRVInstruction.h
@@ -115,8 +115,14 @@ public:
   // Complete constructor for instruction with type but no id
   SPIRVInstruction(unsigned TheWordCount, Op TheOC, SPIRVType *TheType,
                    SPIRVBasicBlock *TheBB);
+  // Special constructor for debug instruction
+  SPIRVInstruction(unsigned TheWordCount, Op TheOC, SPIRVType *TheType,
+                   SPIRVId TheId, SPIRVModule *TheBM,
+                   SPIRVBasicBlock *TheBB = nullptr);
+
   // Incomplete constructor
-  SPIRVInstruction(Op TheOC = OpNop) : SPIRVValue(TheOC), BB(NULL) {}
+  SPIRVInstruction(Op TheOC = OpNop)
+      : SPIRVValue(TheOC), BB(NULL), DebugScope(nullptr) {}
 
   bool isInst() const override { return true; }
   SPIRVBasicBlock *getParent() const { return BB; }
@@ -159,11 +165,16 @@ public:
       setModule(TheBB->getModule());
   }
 
+  void setDebugScope(SPIRVEntry *Scope) { DebugScope = Scope; }
+
+  SPIRVEntry *getDebugScope() const { return DebugScope; }
+
 protected:
   void validate() const override { SPIRVValue::validate(); }
 
 private:
   SPIRVBasicBlock *BB;
+  SPIRVEntry *DebugScope;
 };
 
 class SPIRVInstTemplateBase : public SPIRVInstruction {
@@ -1308,8 +1319,19 @@ public:
     validate();
     assert(BB && "Invalid BB");
   }
+
+  SPIRVFunctionCallGeneric(SPIRVModule *BM, SPIRVWord ResId, SPIRVType *TheType,
+                           const std::vector<SPIRVWord> &TheArgs)
+      : SPIRVInstruction(TheArgs.size() + FixedWordCount, OC, TheType, ResId,
+                         BM),
+        Args(TheArgs) {}
+
   SPIRVFunctionCallGeneric() : SPIRVInstruction(OC) {}
-  const std::vector<SPIRVWord> &getArguments() { return Args; }
+  const std::vector<SPIRVWord> &getArguments() const { return Args; }
+  void setArguments(const std::vector<SPIRVWord> &A) {
+    Args = A;
+    setWordCount(Args.size() + FixedWordCount);
+  }
   std::vector<SPIRVValue *> getArgumentValues() { return getValues(Args); }
   std::vector<SPIRVType *> getArgumentValueTypes() const {
     std::vector<SPIRVType *> ArgTypes;
@@ -1359,17 +1381,28 @@ public:
     setExtSetKindById();
     validate();
   }
+
+  SPIRVExtInst(SPIRVModule *BM, SPIRVId ResId, SPIRVType *TheType,
+               SPIRVExtInstSetKind SetKind, SPIRVWord SetId, SPIRVWord InstId,
+               const std::vector<SPIRVWord> &Args)
+      : SPIRVFunctionCallGeneric(BM, ResId, TheType, Args), ExtSetKind(SetKind),
+        ExtSetId(SetId), ExtOp(InstId) {}
+
   SPIRVExtInst(SPIRVExtInstSetKind SetKind = SPIRVEIS_Count,
                unsigned ExtOC = SPIRVWORD_MAX)
-      : ExtSetId(SPIRVWORD_MAX), ExtOp(ExtOC), ExtSetKind(SetKind) {}
+      : ExtSetKind(SetKind), ExtSetId(SPIRVWORD_MAX), ExtOp(ExtOC) {}
   void setExtSetId(unsigned Set) { ExtSetId = Set; }
   void setExtOp(unsigned ExtOC) { ExtOp = ExtOC; }
   SPIRVId getExtSetId() const { return ExtSetId; }
   SPIRVWord getExtOp() const { return ExtOp; }
+
+  SPIRVExtInstSetKind GetExtSetKind() const { return ExtSetKind; }
+
   void setExtSetKindById() {
     assert(Module && "Invalid module");
     ExtSetKind = Module->getBuiltinSet(ExtSetId);
-    assert(ExtSetKind == SPIRVEIS_OpenCL && "not supported");
+    assert((ExtSetKind == SPIRVEIS_OpenCL || ExtSetKind == SPIRVEIS_Debug) &&
+           "not supported");
   }
   void encode(spv_ostream &O) const override {
     getEncoder(O) << Type << Id << ExtSetId;
@@ -1377,6 +1410,9 @@ public:
     case SPIRVEIS_OpenCL:
       getEncoder(O) << ExtOpOCL;
       break;
+    case SPIRVEIS_Debug:
+      getEncoder(O) << ExtOpDebug;
+      break;
     default:
       assert(0 && "not supported");
       getEncoder(O) << ExtOp;
@@ -1390,6 +1426,9 @@ public:
     case SPIRVEIS_OpenCL:
       getDecoder(I) >> ExtOpOCL;
       break;
+    case SPIRVEIS_Debug:
+      getDecoder(I) >> ExtOpDebug;
+      break;
     default:
       assert(0 && "not supported");
       getDecoder(I) >> ExtOp;
@@ -1419,12 +1458,13 @@ public:
   }
 
 protected:
+  SPIRVExtInstSetKind ExtSetKind;
   SPIRVId ExtSetId;
   union {
     SPIRVWord ExtOp;
     OCLExtOpKind ExtOpOCL;
+    SPIRVDebugExtOpKind ExtOpDebug;
   };
-  SPIRVExtInstSetKind ExtSetKind;
 };
 
 class SPIRVCompositeConstruct : public SPIRVInstruction {
diff --git a/lib/SPIRV/libSPIRV/SPIRVModule.cpp b/lib/SPIRV/libSPIRV/SPIRVModule.cpp
index 3be592c..7a800df 100644
--- a/lib/SPIRV/libSPIRV/SPIRVModule.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVModule.cpp
@@ -133,6 +133,9 @@ public:
   unsigned short getGeneratorId() const override { return GeneratorId; }
   unsigned short getGeneratorVer() const override { return GeneratorVer; }
   SPIRVWord getSPIRVVersion() const override { return SPIRVVersion; }
+  const std::vector<SPIRVExtInst *> &getDebugInstVec() const {
+    return DebugInstVec;
+  }
 
   // Module changing functions
   bool importBuiltinSet(const std::string &, SPIRVId *) override;
@@ -243,19 +246,23 @@ public:
                                      SPIRVWord Capacity) override;
 
   // Instruction creation functions
-  SPIRVInstruction *addPtrAccessChainInst(SPIRVType *, SPIRVValue *,
-                                          std::vector<SPIRVValue *>,
-                                          SPIRVBasicBlock *, bool) override;
-  SPIRVInstruction *addAsyncGroupCopy(SPIRVValue *Scope, SPIRVValue *Dest,
-                                      SPIRVValue *Src, SPIRVValue *NumElems,
-                                      SPIRVValue *Stride, SPIRVValue *Event,
-                                      SPIRVBasicBlock *BB) override;
-  SPIRVInstruction *addExtInst(SPIRVType *, SPIRVWord, SPIRVWord,
-                               const std::vector<SPIRVWord> &,
-                               SPIRVBasicBlock *) override;
-  SPIRVInstruction *addExtInst(SPIRVType *, SPIRVWord, SPIRVWord,
-                               const std::vector<SPIRVValue *> &,
-                               SPIRVBasicBlock *) override;
+  virtual SPIRVInstruction *addPtrAccessChainInst(SPIRVType *, SPIRVValue *,
+                                                  std::vector<SPIRVValue *>,
+                                                  SPIRVBasicBlock *, bool);
+  virtual SPIRVInstruction *
+  addAsyncGroupCopy(SPIRVValue *Scope, SPIRVValue *Dest, SPIRVValue *Src,
+                    SPIRVValue *NumElems, SPIRVValue *Stride, SPIRVValue *Event,
+                    SPIRVBasicBlock *BB);
+  virtual SPIRVInstruction *addExtInst(SPIRVType *, SPIRVWord, SPIRVWord,
+                                       const std::vector<SPIRVWord> &,
+                                       SPIRVBasicBlock *,
+                                       SPIRVInstruction * = nullptr);
+  virtual SPIRVInstruction *addExtInst(SPIRVType *, SPIRVWord, SPIRVWord,
+                                       const std::vector<SPIRVValue *> &,
+                                       SPIRVBasicBlock *,
+                                       SPIRVInstruction * = nullptr);
+  virtual SPIRVEntry *addDebugInfo(SPIRVWord, SPIRVType *TheType,
+                                   const std::vector<SPIRVWord> &) override;
   SPIRVInstruction *addBinaryInst(Op, SPIRVType *, SPIRVValue *, SPIRVValue *,
                                   SPIRVBasicBlock *) override;
   SPIRVInstruction *addCallInst(SPIRVFunction *, const std::vector<SPIRVWord> &,
@@ -292,8 +299,9 @@ public:
   SPIRVInstruction *addGroupInst(Op OpCode, SPIRVType *Type, Scope Scope,
                                  const std::vector<SPIRVValue *> &Ops,
                                  SPIRVBasicBlock *BB) override;
-  virtual SPIRVInstruction *addInstruction(SPIRVInstruction *Inst,
-                                           SPIRVBasicBlock *BB);
+  virtual SPIRVInstruction *
+  addInstruction(SPIRVInstruction *Inst, SPIRVBasicBlock *BB,
+                 SPIRVInstruction *InsertBefore = nullptr);
   SPIRVInstTemplateBase *addInstTemplate(Op OC, SPIRVBasicBlock *BB,
                                          SPIRVType *Ty) override;
   SPIRVInstTemplateBase *addInstTemplate(Op OC,
@@ -346,6 +354,8 @@ public:
                                                SPIRVValue *,
                                                SPIRVBasicBlock *) override;
 
+  virtual SPIRVId getExtInstSetId(SPIRVExtInstSetKind Kind) const override;
+
   // I/O functions
   friend spv_ostream &operator<<(spv_ostream &O, SPIRVModule &M);
   friend std::istream &operator>>(std::istream &I, SPIRVModule &M);
@@ -378,6 +388,8 @@ private:
   typedef std::vector<SPIRVMemberName *> SPIRVMemberNameVec;
   typedef std::vector<SPIRVDecorationGroup *> SPIRVDecGroupVec;
   typedef std::vector<SPIRVGroupDecorateGeneric *> SPIRVGroupDecVec;
+  typedef std::map<SPIRVId, SPIRVExtInstSetKind> SPIRVIdToInstructionSetMap;
+  std::map<SPIRVExtInstSetKind, SPIRVId> ExtInstSetIds;
   typedef std::map<SPIRVId, SPIRVExtInstSetKind> SPIRVIdToBuiltinSetMap;
   typedef std::map<SPIRVExecutionModelKind, SPIRVIdSet> SPIRVExecModelIdSetMap;
   typedef std::map<SPIRVExecutionModelKind, SPIRVIdVec> SPIRVExecModelIdVecMap;
@@ -392,6 +404,7 @@ private:
   SPIRVConstantVector ConstVec;
   SPIRVVariableVec VariableVec;
   SPIRVEntrySet EntryNoId; // Entries without id
+  SPIRVIdToInstructionSetMap IdToInstSetMap;
   SPIRVIdToBuiltinSetMap IdBuiltinMap;
   SPIRVIdSet NamedId;
   SPIRVStringVec StringVec;
@@ -407,6 +420,7 @@ private:
   SPIRVUnknownStructFieldMap UnknownStructFieldMap;
   std::map<unsigned, SPIRVTypeInt *> IntTypeMap;
   std::map<unsigned, SPIRVConstant *> LiteralMap;
+  std::vector<SPIRVExtInst *> DebugInstVec;
 
   void layoutEntry(SPIRVEntry *Entry);
 };
@@ -544,6 +558,17 @@ void SPIRVModuleImpl::layoutEntry(SPIRVEntry *E) {
     if (!BV->getParent())
       addTo(VariableVec, E);
   } break;
+  case OpExtInst: {
+    SPIRVExtInst *EI = static_cast<SPIRVExtInst *>(E);
+    if (EI->GetExtSetKind() == SPIRVEIS_Debug &&
+        EI->getExtOp() != SPIRVDebug::Declare &&
+        EI->getExtOp() != SPIRVDebug::Value &&
+        EI->getExtOp() != SPIRVDebug::Scope &&
+        EI->getExtOp() != SPIRVDebug::NoScope) {
+      DebugInstVec.push_back(EI);
+    }
+    break;
+  }
   default:
     if (isTypeOpCode(OC))
       TypeVec.push_back(static_cast<SPIRVType *>(E));
@@ -625,8 +650,8 @@ SPIRVEntry *SPIRVModuleImpl::getEntry(SPIRVId Id) const {
 }
 
 SPIRVExtInstSetKind SPIRVModuleImpl::getBuiltinSet(SPIRVId SetId) const {
-  auto Loc = IdBuiltinMap.find(SetId);
-  assert(Loc != IdBuiltinMap.end() && "Invalid builtin set id");
+  auto Loc = IdToInstSetMap.find(SetId);
+  assert(Loc != IdToInstSetMap.end() && "Invalid builtin set id");
   return Loc->second;
 }
 
@@ -656,7 +681,8 @@ bool SPIRVModuleImpl::importBuiltinSetWithId(const std::string &BuiltinSetName,
   SPIRVExtInstSetKind BuiltinSet = SPIRVEIS_Count;
   SPIRVCKRT(SPIRVBuiltinSetNameMap::rfind(BuiltinSetName, &BuiltinSet),
             InvalidBuiltinSetName, "Actual is " + BuiltinSetName);
-  IdBuiltinMap[BuiltinSetId] = BuiltinSet;
+  IdToInstSetMap[BuiltinSetId] = BuiltinSet;
+  ExtInstSetIds[BuiltinSet] = BuiltinSetId;
   return true;
 }
 
@@ -985,10 +1011,11 @@ SPIRVModuleImpl::addGroupInst(Op OpCode, SPIRVType *Type, Scope Scope,
   return addInstTemplate(OpCode, WordOps, BB, Type);
 }
 
-SPIRVInstruction *SPIRVModuleImpl::addInstruction(SPIRVInstruction *Inst,
-                                                  SPIRVBasicBlock *BB) {
+SPIRVInstruction *
+SPIRVModuleImpl::addInstruction(SPIRVInstruction *Inst, SPIRVBasicBlock *BB,
+                                SPIRVInstruction *InsertBefore) {
   if (BB)
-    return BB->addInstruction(Inst);
+    return BB->addInstruction(Inst, InsertBefore);
   if (Inst->getOpCode() != OpSpecConstantOp)
     Inst = createSpecConstantOpInst(Inst);
   return static_cast<SPIRVInstruction *>(addConstant(Inst));
@@ -1011,16 +1038,27 @@ SPIRVModuleImpl::addPhiInst(SPIRVType *Type,
 
 SPIRVInstruction *SPIRVModuleImpl::addExtInst(
     SPIRVType *TheType, SPIRVWord BuiltinSet, SPIRVWord EntryPoint,
-    const std::vector<SPIRVWord> &Args, SPIRVBasicBlock *BB) {
+    const std::vector<SPIRVWord> &Args, SPIRVBasicBlock *BB,
+    SPIRVInstruction *InsertBefore) {
   return addInstruction(
-      new SPIRVExtInst(TheType, getId(), BuiltinSet, EntryPoint, Args, BB), BB);
+      new SPIRVExtInst(TheType, getId(), BuiltinSet, EntryPoint, Args, BB), BB,
+      InsertBefore);
 }
 
 SPIRVInstruction *SPIRVModuleImpl::addExtInst(
     SPIRVType *TheType, SPIRVWord BuiltinSet, SPIRVWord EntryPoint,
-    const std::vector<SPIRVValue *> &Args, SPIRVBasicBlock *BB) {
+    const std::vector<SPIRVValue *> &Args, SPIRVBasicBlock *BB,
+    SPIRVInstruction *InsertBefore) {
   return addInstruction(
-      new SPIRVExtInst(TheType, getId(), BuiltinSet, EntryPoint, Args, BB), BB);
+      new SPIRVExtInst(TheType, getId(), BuiltinSet, EntryPoint, Args, BB), BB,
+      InsertBefore);
+}
+
+SPIRVEntry *SPIRVModuleImpl::addDebugInfo(SPIRVWord InstId, SPIRVType *TheType,
+                                          const std::vector<SPIRVWord> &Args) {
+  return addEntry(new SPIRVExtInst(this, getId(), TheType, SPIRVEIS_Debug,
+                                   ExtInstSetIds[SPIRVEIS_Debug], InstId,
+                                   Args));
 }
 
 SPIRVInstruction *
@@ -1339,6 +1377,8 @@ spv_ostream &operator<<(spv_ostream &O, const TopologicalSort &S) {
 
 spv_ostream &operator<<(spv_ostream &O, SPIRVModule &M) {
   SPIRVModuleImpl &MI = *static_cast<SPIRVModuleImpl *>(&M);
+  // Start tracking of the current line with no line
+  MI.CurrentLine.reset();
 
   SPIRVEncoder Encoder(O);
   Encoder << MagicNumber << MI.SPIRVVersion
@@ -1355,7 +1395,7 @@ spv_ostream &operator<<(spv_ostream &O, SPIRVModule &M) {
     O << SPIRVExtension(&M, I);
   }
 
-  for (auto &I : MI.IdBuiltinMap)
+  for (auto &I : MI.IdToInstSetMap)
     O << SPIRVExtInstImport(&M, I.first, SPIRVBuiltinSetNameMap::map(I.second));
 
   O << SPIRVMemoryModel(&M);
@@ -1394,7 +1434,7 @@ spv_ostream &operator<<(spv_ostream &O, SPIRVModule &M) {
     << MI.ForwardPointerVec
     << TopologicalSort(MI.TypeVec, MI.ConstVec, MI.VariableVec,
                        MI.ForwardPointerVec)
-    << SPIRVNL() << MI.FuncVec;
+    << SPIRVNL() << MI.DebugInstVec << SPIRVNL() << MI.FuncVec;
   return O;
 }
 
@@ -1561,25 +1601,11 @@ SPIRVModuleImpl::addInstTemplate(Op OC, const std::vector<SPIRVWord> &Ops,
   return Ins;
 }
 
-SPIRVDbgInfo::SPIRVDbgInfo(SPIRVModule *TM) : M(TM) {}
-
-std::string SPIRVDbgInfo::getEntryPointFileStr(SPIRVExecutionModelKind EM,
-                                               unsigned I) {
-  if (M->getNumEntryPoints(EM) == 0)
-    return "";
-  return getFunctionFileStr(M->getEntryPoint(EM, I));
-}
-
-std::string SPIRVDbgInfo::getFunctionFileStr(SPIRVFunction *F) {
-  if (F->hasLine())
-    return F->getLine()->getFileNameStr();
-  return "";
-}
-
-unsigned SPIRVDbgInfo::getFunctionLineNo(SPIRVFunction *F) {
-  if (F->hasLine())
-    return F->getLine()->getLine();
-  return 0;
+SPIRVId SPIRVModuleImpl::getExtInstSetId(SPIRVExtInstSetKind Kind) const {
+  assert(Kind < SPIRVEIS_Count && "Unknown extended instruction set!");
+  auto res = ExtInstSetIds.find(Kind);
+  assert(res != ExtInstSetIds.end() && "extended instruction set not found!");
+  return res->second;
 }
 
 bool isSpirvBinary(const std::string &Img) {
diff --git a/lib/SPIRV/libSPIRV/SPIRVModule.h b/lib/SPIRV/libSPIRV/SPIRVModule.h
index 3c212c4..bc3e9b2 100644
--- a/lib/SPIRV/libSPIRV/SPIRVModule.h
+++ b/lib/SPIRV/libSPIRV/SPIRVModule.h
@@ -138,6 +138,7 @@ public:
   virtual unsigned short getGeneratorId() const = 0;
   virtual unsigned short getGeneratorVer() const = 0;
   virtual SPIRVWord getSPIRVVersion() const = 0;
+  virtual const std::vector<SPIRVExtInst *> &getDebugInstVec() const = 0;
 
   // Module changing functions
   virtual bool importBuiltinSet(const std::string &, SPIRVId *) = 0;
@@ -260,10 +261,14 @@ public:
   virtual SPIRVInstruction *addBranchInst(SPIRVLabel *, SPIRVBasicBlock *) = 0;
   virtual SPIRVInstruction *addExtInst(SPIRVType *, SPIRVWord, SPIRVWord,
                                        const std::vector<SPIRVWord> &,
-                                       SPIRVBasicBlock *) = 0;
+                                       SPIRVBasicBlock *,
+                                       SPIRVInstruction * = nullptr) = 0;
   virtual SPIRVInstruction *addExtInst(SPIRVType *, SPIRVWord, SPIRVWord,
                                        const std::vector<SPIRVValue *> &,
-                                       SPIRVBasicBlock *) = 0;
+                                       SPIRVBasicBlock *,
+                                       SPIRVInstruction * = nullptr) = 0;
+  virtual SPIRVEntry *addDebugInfo(SPIRVWord, SPIRVType *,
+                                   const std::vector<SPIRVWord> &) = 0;
   virtual void addCapability(SPIRVCapabilityKind) = 0;
   template <typename T> void addCapabilities(const T &Caps) {
     for (auto I : Caps)
@@ -363,6 +368,8 @@ public:
                                                        SPIRVValue *,
                                                        SPIRVValue *,
                                                        SPIRVBasicBlock *) = 0;
+  virtual SPIRVId getExtInstSetId(SPIRVExtInstSetKind Kind) const = 0;
+
   // I/O functions
   friend spv_ostream &operator<<(spv_ostream &O, SPIRVModule &M);
   friend std::istream &operator>>(std::istream &I, SPIRVModule &M);
@@ -372,18 +379,6 @@ protected:
   bool ValidateCapability;
 };
 
-class SPIRVDbgInfo {
-public:
-  SPIRVDbgInfo(SPIRVModule *TM);
-  std::string getEntryPointFileStr(SPIRVExecutionModelKind, unsigned);
-  std::string getFunctionFileStr(SPIRVFunction *);
-  unsigned getFunctionLineNo(SPIRVFunction *);
-
-private:
-  std::unordered_map<SPIRVFunction *, SPIRVLine *> FuncMap;
-  const std::string ModuleFileStr;
-  SPIRVModule *M;
-};
 
 #ifdef _SPIRV_SUPPORT_TEXT_FMT
 
diff --git a/lib/SPIRV/libSPIRV/SPIRVOpCode.h b/lib/SPIRV/libSPIRV/SPIRVOpCode.h
index 612ab94..896cd69 100644
--- a/lib/SPIRV/libSPIRV/SPIRVOpCode.h
+++ b/lib/SPIRV/libSPIRV/SPIRVOpCode.h
@@ -150,7 +150,8 @@ inline bool isConstantOpCode(Op OpCode) {
 }
 
 inline bool isModuleScopeAllowedOpCode(Op OpCode) {
-  return OpCode == OpVariable || isConstantOpCode(OpCode);
+  return OpCode == OpVariable || OpCode == OpExtInst ||
+         isConstantOpCode(OpCode);
 }
 
 inline bool isIntelSubgroupOpCode(Op OpCode) {
diff --git a/lib/SPIRV/libSPIRV/SPIRVStream.cpp b/lib/SPIRV/libSPIRV/SPIRVStream.cpp
index 00efeae..2d85d88 100644
--- a/lib/SPIRV/libSPIRV/SPIRVStream.cpp
+++ b/lib/SPIRV/libSPIRV/SPIRVStream.cpp
@@ -131,6 +131,7 @@ SPIRV_DEF_ENCDEC(Op)
 SPIRV_DEF_ENCDEC(Capability)
 SPIRV_DEF_ENCDEC(Decoration)
 SPIRV_DEF_ENCDEC(OCLExtOpKind)
+SPIRV_DEF_ENCDEC(SPIRVDebugExtOpKind)
 SPIRV_DEF_ENCDEC(LinkageType)
 
 // Read a string with padded 0's at the end so that they form a stream of
diff --git a/lib/SPIRV/libSPIRV/SPIRVStream.h b/lib/SPIRV/libSPIRV/SPIRVStream.h
index 5253aa5..c0cc69b 100644
--- a/lib/SPIRV/libSPIRV/SPIRVStream.h
+++ b/lib/SPIRV/libSPIRV/SPIRVStream.h
@@ -181,6 +181,7 @@ SPIRV_DEC_ENCDEC(Op)
 SPIRV_DEC_ENCDEC(Capability)
 SPIRV_DEC_ENCDEC(Decoration)
 SPIRV_DEC_ENCDEC(OCLExtOpKind)
+SPIRV_DEC_ENCDEC(SPIRVDebugExtOpKind)
 SPIRV_DEC_ENCDEC(LinkageType)
 
 const SPIRVEncoder &operator<<(const SPIRVEncoder &O, const std::string &Str);
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 719ab54..b6d2aa7 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -22,8 +22,13 @@ add_lit_testsuite(check-llvm-spirv "Running the LLVM-SPIRV regression tests"
     --verbose
   DEPENDS
     ${LLVM_SPIRV_TEST_DEPS}
+    llc
     llvm-as
     llvm-dis
+    llvm-dwarfdump
+    llvm-objdump
+    llvm-readelf
+    llvm-readobj
     llvm-spirv
 )
 
diff --git a/test/DebugInfo/COFF/global-dllimport.ll b/test/DebugInfo/COFF/global-dllimport.ll
new file mode 100644
index 0000000..88ea27f
--- /dev/null
+++ b/test/DebugInfo/COFF/global-dllimport.ll
@@ -0,0 +1,36 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll | FileCheck %s
+
+; CHECK-NOT: S_GDATA32
+
+source_filename = "test/DebugInfo/COFF/global-dllimport.ll"
+target datalayout = "e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32"
+target triple = "spir64-unknown-unknown"
+
+@"\01?id@?$numpunct@D@@0HA" = available_externally dllimport global i32 0, align 4, !dbg !0
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!14, !15}
+!llvm.ident = !{!16}
+
+!0 = distinct !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "id", linkageName: "\01?id@?$numpunct@D@@0HA", scope: !2, file: !6, line: 4, type: !7, isLocal: false, isDefinition: true, declaration: !8)
+!2 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !3, producer: "clang version 3.9.0 (trunk 272628) (llvm/trunk 272566)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, globals: !5)
+!3 = !DIFile(filename: "/usr/local/google/home/majnemer/Downloads/<stdin>", directory: "/usr/local/google/home/majnemer/llvm/src")
+!4 = !{}
+!5 = !{!0}
+!6 = !DIFile(filename: "/usr/local/google/home/majnemer/Downloads/t.ii", directory: "/usr/local/google/home/majnemer/llvm/src")
+!7 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!8 = !DIDerivedType(tag: DW_TAG_member, name: "id", scope: !9, file: !6, line: 2, baseType: !7, flags: DIFlagStaticMember)
+!9 = distinct !DICompositeType(tag: DW_TAG_class_type, name: "numpunct<char>", file: !6, line: 2, size: 8, align: 8, elements: !10, templateParams: !11)
+!10 = !{!8}
+!11 = !{!12}
+!12 = !DITemplateTypeParameter(type: !13)
+!13 = !DIBasicType(name: "char", size: 8, align: 8, encoding: DW_ATE_signed_char)
+!14 = !{i32 2, !"CodeView", i32 1}
+!15 = !{i32 2, !"Debug Info Version", i32 3}
+!16 = !{!"clang version 3.9.0 (trunk 272628) (llvm/trunk 272566)"}
+
diff --git a/test/DebugInfo/COFF/no-cus.ll b/test/DebugInfo/COFF/no-cus.ll
new file mode 100644
index 0000000..c9e532f
--- /dev/null
+++ b/test/DebugInfo/COFF/no-cus.ll
@@ -0,0 +1,29 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll -filetype=obj -o %t.o
+; RUN: llvm-objdump -section-headers %t.o | FileCheck %s
+
+; Don't emit debug info in this scenario and don't crash.
+
+; CHECK-NOT: .debug$S
+; CHECK: .text
+; CHECK-NOT: .debug$S
+
+; ModuleID = 't.cpp'
+source_filename = "t.cpp"
+target datalayout = "e-m:w-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+define void @f() {
+entry:
+  ret void
+}
+
+!llvm.module.flags = !{!0, !1}
+!llvm.ident = !{!2}
+
+!0 = !{i32 2, !"CodeView", i32 1}
+!1 = !{i32 1, !"PIC Level", i32 2}
+!2 = !{!"clang version 5.0.0 "}
diff --git a/test/DebugInfo/Generic/2009-11-05-DeadGlobalVariable.ll b/test/DebugInfo/Generic/2009-11-05-DeadGlobalVariable.ll
new file mode 100644
index 0000000..3850658
--- /dev/null
+++ b/test/DebugInfo/Generic/2009-11-05-DeadGlobalVariable.ll
@@ -0,0 +1,36 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple %t.ll -o /dev/null
+; Here variable bar is optimized away. Do not trip over while trying to generate debug info.
+
+source_filename = "test/DebugInfo/Generic/2009-11-05-DeadGlobalVariable.ll"
+
+; Function Attrs: nounwind readnone ssp uwtable
+define i32 @foo() #0 !dbg !6 {
+entry:
+  ret i32 42, !dbg !11
+}
+
+attributes #0 = { nounwind readnone ssp uwtable }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!10}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 3.0 (trunk 139632)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, globals: !3)
+!1 = !DIFile(filename: "fb.c", directory: "/private/tmp")
+!2 = !{}
+!3 = !{!4}
+!4 = !DIGlobalVariableExpression(var: !5, expr: !DIExpression())
+!5 = !DIGlobalVariable(name: "bar", scope: !6, file: !1, line: 2, type: !9, isLocal: true, isDefinition: true)
+!6 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 1, type: !7, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: true, unit: !0)
+!7 = !DISubroutineType(types: !8)
+!8 = !{!9}
+!9 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!10 = !{i32 1, !"Debug Info Version", i32 3}
+!11 = !DILocation(line: 3, column: 3, scope: !12)
+!12 = distinct !DILexicalBlock(scope: !6, file: !1, line: 1, column: 11)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/2009-11-06-NamelessGlobalVariable.ll b/test/DebugInfo/Generic/2009-11-06-NamelessGlobalVariable.ll
new file mode 100644
index 0000000..6f8eed6
--- /dev/null
+++ b/test/DebugInfo/Generic/2009-11-06-NamelessGlobalVariable.ll
@@ -0,0 +1,22 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple %t.ll -o /dev/null
+source_filename = "test/DebugInfo/Generic/2009-11-06-NamelessGlobalVariable.ll"
+
+@0 = internal constant i32 1, !dbg !0
+
+!llvm.dbg.cu = !{!4}
+!llvm.module.flags = !{!7}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "a", scope: null, file: !2, line: 2, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "g.c", directory: "/private/tmp")
+!3 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!4 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2, producer: "clang version 3.0 (trunk 139632)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !5, retainedTypes: !5, globals: !6)
+!5 = !{}
+!6 = !{!0}
+!7 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/2009-11-10-CurrentFn.ll b/test/DebugInfo/Generic/2009-11-10-CurrentFn.ll
new file mode 100644
index 0000000..440ad6a
--- /dev/null
+++ b/test/DebugInfo/Generic/2009-11-10-CurrentFn.ll
@@ -0,0 +1,36 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll -o /dev/null
+
+define void @bar(i32 %i) nounwind uwtable ssp !dbg !5 {
+entry:
+  tail call void (...) @foo() nounwind, !dbg !14
+  ret void, !dbg !16
+}
+
+declare void @foo(...)
+
+declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!18}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.0 (trunk 139632)", isOptimized: true, emissionKind: FullDebug, file: !17, enums: !1, retainedTypes: !1, globals: !1)
+!1 = !{}
+!5 = distinct !DISubprogram(name: "bar", line: 3, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, file: !17, scope: !6, type: !7, retainedNodes: !9)
+!6 = !DIFile(filename: "cf.c", directory: "/private/tmp")
+!7 = !DISubroutineType(types: !8)
+!8 = !{null}
+!9 = !{!11}
+!11 = !DILocalVariable(name: "i", line: 3, arg: 1, scope: !5, file: !17, type: !12)
+!12 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!13 = !DILocation(line: 3, column: 14, scope: !5)
+!14 = !DILocation(line: 4, column: 3, scope: !15)
+!15 = distinct !DILexicalBlock(line: 3, column: 17, file: !17, scope: !5)
+!16 = !DILocation(line: 5, column: 1, scope: !15)
+!17 = !DIFile(filename: "cf.c", directory: "/private/tmp")
+!18 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/2010-01-05-DbgScope.ll b/test/DebugInfo/Generic/2010-01-05-DbgScope.ll
new file mode 100644
index 0000000..923c0da
--- /dev/null
+++ b/test/DebugInfo/Generic/2010-01-05-DbgScope.ll
@@ -0,0 +1,30 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll -o /dev/null
+; PR 5942
+define i8* @foo() nounwind {
+entry:
+  %0 = load i32, i32* undef, align 4, !dbg !0          ; <i32> [#uses=1]
+  %1 = inttoptr i32 %0 to i8*, !dbg !0            ; <i8*> [#uses=1]
+  ret i8* %1, !dbg !10
+
+}
+
+!llvm.dbg.cu = !{!3}
+!llvm.module.flags = !{!14}
+
+!0 = !DILocation(line: 571, column: 3, scope: !1)
+!1 = distinct !DILexicalBlock(line: 1, column: 1, file: !11, scope: !2)
+!2 = distinct !DISubprogram(name: "foo", linkageName: "foo", file: !11, line: 561, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !3, scope: !3, type: !4)
+!3 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang 1.1", isOptimized: true, emissionKind: FullDebug, file: !11, enums: !12, retainedTypes: !12)
+!4 = !DISubroutineType(types: !5)
+!5 = !{!6}
+!6 = !DIBasicType(tag: DW_TAG_base_type, name: "char", size: 8, align: 8, encoding: DW_ATE_signed_char)
+!10 = !DILocation(line: 588, column: 1, scope: !2)
+!11 = !DIFile(filename: "hashtab.c", directory: "/usr/src/gnu/usr.bin/cc/cc_tools/../../../../contrib/gcclibs/libiberty")
+!12 = !{}
+!14 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/2010-03-12-llc-crash.ll b/test/DebugInfo/Generic/2010-03-12-llc-crash.ll
new file mode 100644
index 0000000..4410cf0
--- /dev/null
+++ b/test/DebugInfo/Generic/2010-03-12-llc-crash.ll
@@ -0,0 +1,29 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 < %t.ll -o /dev/null
+; llc should not crash on this optimized out debug info.
+; PR6588
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+define void @foo() {
+entry:
+  call void @llvm.dbg.declare(metadata i32* undef, metadata !0, metadata !DIExpression()), !dbg !DILocation(scope: !1)
+  ret void
+}
+
+!llvm.dbg.cu = !{!3}
+!0 = !DILocalVariable(name: "sy", line: 890, arg: 1, scope: !1, file: !2, type: !7)
+!1 = distinct !DISubprogram(name: "foo", linkageName: "foo", line: 892, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !3, file: !8, scope: !3, type: !4)
+!2 = !DIFile(filename: "qpainter.h", directory: "QtGui")
+!3 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang 1.1", isOptimized: true, emissionKind: FullDebug, file: !9, enums: !10, retainedTypes: !10)
+!4 = !DISubroutineType(types: !6)
+!5 = !DIFile(filename: "splineeditor.cpp", directory: "src")
+!6 = !{null}
+!7 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!8 = !DIFile(filename: "qpainter.h", directory: "QtGui")
+!9 = !DIFile(filename: "splineeditor.cpp", directory: "src")
+!10 = !{i32 0}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/2010-04-19-FramePtr.ll b/test/DebugInfo/Generic/2010-04-19-FramePtr.ll
new file mode 100644
index 0000000..71e6695
--- /dev/null
+++ b/test/DebugInfo/Generic/2010-04-19-FramePtr.ll
@@ -0,0 +1,45 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -debugger-tune=lldb -asm-verbose -O1 -o - < %t.ll | FileCheck %s
+; RUN: llc -mtriple=%triple -debugger-tune=gdb -asm-verbose -O1 -o - < %t.ll | FileCheck %s --check-prefix=DISABLE
+; RUN: llc -mtriple=%triple -disable-fp-elim -debugger-tune=lldb -asm-verbose -O1 -o - < %t.ll | FileCheck %s --check-prefix=DISABLE
+
+; CHECK: DW_AT_APPLE_omit_frame_ptr
+; DISABLE-NOT: DW_AT_APPLE_omit_frame_ptr
+
+
+define i32 @foo() nounwind ssp !dbg !1 {
+entry:
+  %retval = alloca i32                            ; <i32*> [#uses=2]
+  %0 = alloca i32                                 ; <i32*> [#uses=2]
+  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
+  store i32 42, i32* %0, align 4, !dbg !0
+  %1 = load i32, i32* %0, align 4, !dbg !0             ; <i32> [#uses=1]
+  store i32 %1, i32* %retval, align 4, !dbg !0
+  br label %return, !dbg !0
+
+return:                                           ; preds = %entry
+  %retval1 = load i32, i32* %retval, !dbg !0           ; <i32> [#uses=1]
+  ret i32 %retval1, !dbg !7
+}
+
+!llvm.dbg.cu = !{!3}
+!llvm.module.flags = !{!12}
+!9 = !{!1}
+
+!0 = !DILocation(line: 2, scope: !1)
+!1 = distinct !DISubprogram(name: "foo", linkageName: "foo", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !3, scopeLine: 2, file: !10, scope: null, type: !4)
+!2 = !DIFile(filename: "a.c", directory: "/tmp")
+!3 = distinct !DICompileUnit(language: DW_LANG_C89, producer: "4.2.1 (Based on Apple Inc. build 5658) (LLVM build)", isOptimized: false, emissionKind: FullDebug, file: !10, enums: !11, retainedTypes: !11, imports:  null)
+!4 = !DISubroutineType(types: !5)
+!5 = !{!6}
+!6 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!7 = !DILocation(line: 2, scope: !8)
+!8 = distinct !DILexicalBlock(line: 2, column: 0, file: !10, scope: !1)
+!10 = !DIFile(filename: "a.c", directory: "/tmp")
+!11 = !{}
+!12 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/2010-06-29-InlinedFnLocalVar.ll b/test/DebugInfo/Generic/2010-06-29-InlinedFnLocalVar.ll
new file mode 100644
index 0000000..f690dd0
--- /dev/null
+++ b/test/DebugInfo/Generic/2010-06-29-InlinedFnLocalVar.ll
@@ -0,0 +1,70 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O2 %t.ll -o - | FileCheck %s
+; Check struct X for dead variable xyz from inlined function foo.
+
+; CHECK: debug_info,
+; CHECK:	DW_TAG_structure_type
+; CHECK-NEXT:	DW_AT_name
+
+source_filename = "test/DebugInfo/Generic/2010-06-29-InlinedFnLocalVar.ll"
+
+@i = common global i32 0, !dbg !0
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #0
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #0
+
+; Function Attrs: nounwind ssp
+define i32 @bar() #1 !dbg !8 {
+entry:
+  %0 = load i32, i32* @i, align 4, !dbg !11
+  tail call void @llvm.dbg.value(metadata i32 %0, metadata !13, metadata !24), !dbg !25
+  tail call void @llvm.dbg.declare(metadata !5, metadata !18, metadata !24), !dbg !26
+  %1 = mul nsw i32 %0, %0, !dbg !27
+  store i32 %1, i32* @i, align 4, !dbg !11
+  ret i32 %1, !dbg !28
+}
+
+attributes #0 = { nounwind readnone }
+attributes #1 = { nounwind ssp }
+
+!llvm.dbg.cu = !{!4}
+!llvm.module.flags = !{!7}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "i", scope: !2, file: !2, line: 5, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "bar.c", directory: "/tmp/")
+!3 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!4 = distinct !DICompileUnit(language: DW_LANG_C89, file: !2, producer: "4.2.1 (Based on Apple Inc. build 5658) (LLVM build)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !5, retainedTypes: !5, globals: !6, imports: !5)
+!5 = !{}
+!6 = !{!0}
+!7 = !{i32 1, !"Debug Info Version", i32 3}
+!8 = distinct !DISubprogram(name: "bar", linkageName: "bar", scope: !2, file: !2, line: 14, type: !9, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: true, unit: !4)
+!9 = !DISubroutineType(types: !10)
+!10 = !{!3}
+!11 = !DILocation(line: 15, scope: !12)
+!12 = distinct !DILexicalBlock(scope: !8, file: !2, line: 14)
+!13 = !DILocalVariable(name: "j", arg: 1, scope: !14, file: !2, line: 9, type: !3)
+!14 = distinct !DISubprogram(name: "foo", scope: !2, file: !2, line: 9, type: !15, isLocal: true, isDefinition: true, scopeLine: 9, virtualIndex: 6, isOptimized: true, unit: !4, retainedNodes: !17)
+!15 = !DISubroutineType(types: !16)
+!16 = !{!3, !3}
+!17 = !{!13, !18}
+!18 = !DILocalVariable(name: "xyz", scope: !19, file: !2, line: 10, type: !20)
+!19 = distinct !DILexicalBlock(scope: !14, file: !2, line: 9)
+!20 = !DICompositeType(tag: DW_TAG_structure_type, name: "X", scope: !14, file: !2, line: 10, size: 64, align: 32, elements: !21)
+!21 = !{!22, !23}
+!22 = !DIDerivedType(tag: DW_TAG_member, name: "a", scope: !20, file: !2, line: 10, baseType: !3, size: 32, align: 32)
+!23 = !DIDerivedType(tag: DW_TAG_member, name: "b", scope: !20, file: !2, line: 10, baseType: !3, size: 32, align: 32, offset: 32)
+!24 = !DIExpression()
+!25 = !DILocation(line: 9, scope: !14, inlinedAt: !11)
+!26 = !DILocation(line: 9, scope: !19, inlinedAt: !11)
+!27 = !DILocation(line: 11, scope: !19, inlinedAt: !11)
+!28 = !DILocation(line: 16, scope: !12)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/2010-10-01-crash.ll b/test/DebugInfo/Generic/2010-10-01-crash.ll
new file mode 100644
index 0000000..d900a08
--- /dev/null
+++ b/test/DebugInfo/Generic/2010-10-01-crash.ll
@@ -0,0 +1,32 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 %t.ll -o /dev/null
+
+define void @CGRectStandardize(i32* sret %agg.result, i32* byval %rect) nounwind ssp !dbg !0 {
+entry:
+  call void @llvm.dbg.declare(metadata i32* %rect, metadata !23, metadata !DIExpression()), !dbg !24
+  ret void
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind
+
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!27}
+!0 = distinct !DISubprogram(name: "CGRectStandardize", linkageName: "CGRectStandardize", line: 54, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !2, file: !1, scope: null, type: !28)
+!1 = !DIFile(filename: "GSFusedSilica.m", directory: "/Volumes/Data/Users/sabre/Desktop")
+!2 = distinct !DICompileUnit(language: DW_LANG_ObjC, producer: "clang version 2.9 (trunk 115292)", isOptimized: true, runtimeVersion: 1, emissionKind: FullDebug, file: !25, enums: !26, retainedTypes: !26)
+!5 = !DIDerivedType(tag: DW_TAG_typedef, name: "CGRect", line: 49, file: !25, baseType: null)
+!23 = !DILocalVariable(name: "rect", line: 53, arg: 2, scope: !0, file: !1, type: !5)
+!24 = !DILocation(line: 53, column: 33, scope: !0)
+!25 = !DIFile(filename: "GSFusedSilica.m", directory: "/Volumes/Data/Users/sabre/Desktop")
+!26 = !{}
+!27 = !{i32 1, !"Debug Info Version", i32 3}
+!28 = !DISubroutineType(types: !29)
+!29 = !{null}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/PR20038.ll b/test/DebugInfo/Generic/PR20038.ll
new file mode 100644
index 0000000..4d697d5
--- /dev/null
+++ b/test/DebugInfo/Generic/PR20038.ll
@@ -0,0 +1,177 @@
+; REQUIRES: object-emission
+
+; For some reason, the output when targetting sparc is not quite as expected.
+; XFAIL: sparc
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj -dwarf-linkage-names=All < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck %s
+
+; IR generated from clang -O0 with:
+; struct C {
+;   ~C();
+; };
+; extern bool b;
+; void fun4() { b && (C(), 1); }
+; __attribute__((always_inline)) C::~C() { }
+
+; CHECK: DW_TAG_structure_type
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_name {{.*}} "C"
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_name {{.*}} "~C"
+
+; CHECK:  DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_linkage_name {{.*}} "_ZN1CD1Ev"
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:  DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_name {{.*}} "this"
+
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_name {{.*}} "fun4"
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_TAG_inlined_subroutine
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_abstract_origin {{.*}} "_ZN1CD1Ev"
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:     DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK:       DW_AT_abstract_origin {{.*}} "this"
+
+; FIXME: D2 is actually inlined into D1 but doesn't show up here, possibly due
+; to there being no work in D2 (calling another member function from the dtor
+; causes D2 to show up, calling a free function doesn't).
+
+; CHECK-NOT: DW_TAG
+; CHECK:     NULL
+; CHECK-NOT: DW_TAG
+; CHECK:   NULL
+
+%struct.C = type { i8 }
+
+@b = external global i8
+
+; Function Attrs: nounwind
+define void @_Z4fun4v() #0 !dbg !12 {
+entry:
+  %this.addr.i.i = alloca %struct.C*, align 8, !dbg !21
+  %this.addr.i = alloca %struct.C*, align 8, !dbg !22
+  %agg.tmp.ensured = alloca %struct.C, align 1
+  %cleanup.cond = alloca i1
+  %0 = load i8, i8* @b, align 1, !dbg !24
+  %tobool = trunc i8 %0 to i1, !dbg !24
+  store i1 false, i1* %cleanup.cond
+  br i1 %tobool, label %land.rhs, label %land.end, !dbg !24
+
+land.rhs:                                         ; preds = %entry
+  store i1 true, i1* %cleanup.cond, !dbg !25
+  br label %land.end
+
+land.end:                                         ; preds = %land.rhs, %entry
+  %1 = phi i1 [ false, %entry ], [ true, %land.rhs ]
+  %cleanup.is_active = load i1, i1* %cleanup.cond, !dbg !27
+  br i1 %cleanup.is_active, label %cleanup.action, label %cleanup.done, !dbg !27
+
+cleanup.action:                                   ; preds = %land.end
+  store %struct.C* %agg.tmp.ensured, %struct.C** %this.addr.i, align 8, !dbg !22
+  call void @llvm.dbg.declare(metadata %struct.C** %this.addr.i, metadata !129, metadata !DIExpression()), !dbg !31
+  %this1.i = load %struct.C*, %struct.C** %this.addr.i, !dbg !22
+  store %struct.C* %this1.i, %struct.C** %this.addr.i.i, align 8, !dbg !21
+  call void @llvm.dbg.declare(metadata %struct.C** %this.addr.i.i, metadata !132, metadata !DIExpression()), !dbg !33
+  %this1.i.i = load %struct.C*, %struct.C** %this.addr.i.i, !dbg !21
+  br label %cleanup.done, !dbg !22
+
+cleanup.done:                                     ; preds = %cleanup.action, %land.end
+  ret void, !dbg !34
+}
+
+; Function Attrs: alwaysinline nounwind
+define void @_ZN1CD1Ev(%struct.C* %this) unnamed_addr #1 align 2 !dbg !17 {
+entry:
+  %this.addr.i = alloca %struct.C*, align 8, !dbg !37
+  %this.addr = alloca %struct.C*, align 8
+  store %struct.C* %this, %struct.C** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.C** %this.addr, metadata !29, metadata !DIExpression()), !dbg !38
+  %this1 = load %struct.C*, %struct.C** %this.addr
+  store %struct.C* %this1, %struct.C** %this.addr.i, align 8, !dbg !37
+  call void @llvm.dbg.declare(metadata %struct.C** %this.addr.i, metadata !232, metadata !DIExpression()), !dbg !39
+  %this1.i = load %struct.C*, %struct.C** %this.addr.i, !dbg !37
+  ret void, !dbg !37
+}
+
+; Function Attrs: alwaysinline nounwind
+define void @_ZN1CD2Ev(%struct.C* %this) unnamed_addr #1 align 2 !dbg !16 {
+entry:
+  %this.addr = alloca %struct.C*, align 8
+  store %struct.C* %this, %struct.C** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.C** %this.addr, metadata !32, metadata !DIExpression()), !dbg !40
+  %this1 = load %struct.C*, %struct.C** %this.addr
+  ret void, !dbg !41
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #2
+
+attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-realign-stack" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { alwaysinline nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-realign-stack" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #2 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!18, !19}
+!llvm.ident = !{!20}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !3, globals: !2, imports: !2)
+!1 = !DIFile(filename: "<stdin>", directory: "/tmp/dbginfo")
+!2 = !{}
+!3 = !{!4}
+!4 = !DICompositeType(tag: DW_TAG_structure_type, name: "C", line: 1, size: 8, align: 8, file: !5, elements: !6, identifier: "_ZTS1C")
+!5 = !DIFile(filename: "PR20038.cpp", directory: "/tmp/dbginfo")
+!6 = !{!7}
+!7 = !DISubprogram(name: "~C", line: 2, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, scopeLine: 2, file: !5, scope: !4, type: !8)
+!8 = !DISubroutineType(types: !9)
+!9 = !{null, !10}
+!10 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer, baseType: !4)
+!12 = distinct !DISubprogram(name: "fun4", linkageName: "_Z4fun4v", line: 5, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 5, file: !5, scope: !13, type: !14, retainedNodes: !2)
+!13 = !DIFile(filename: "PR20038.cpp", directory: "/tmp/dbginfo")
+!14 = !DISubroutineType(types: !15)
+!15 = !{null}
+!16 = distinct !DISubprogram(name: "~C", linkageName: "_ZN1CD2Ev", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 6, file: !5, scope: !4, type: !8, declaration: !7, retainedNodes: !2)
+!17 = distinct !DISubprogram(name: "~C", linkageName: "_ZN1CD1Ev", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 6, file: !5, scope: !4, type: !8, declaration: !7, retainedNodes: !2)
+!18 = !{i32 2, !"Dwarf Version", i32 4}
+!19 = !{i32 2, !"Debug Info Version", i32 3}
+!20 = !{!"clang version 3.5.0 "}
+!21 = !DILocation(line: 6, scope: !17, inlinedAt: !22)
+!22 = !DILocation(line: 5, scope: !23)
+!23 = distinct !DILexicalBlock(line: 5, column: 0, file: !5, scope: !12)
+!24 = !DILocation(line: 5, scope: !12)
+!25 = !DILocation(line: 5, scope: !26)
+!26 = distinct !DILexicalBlock(line: 5, column: 0, file: !5, scope: !12)
+!27 = !DILocation(line: 5, scope: !28)
+!28 = distinct !DILexicalBlock(line: 5, column: 0, file: !5, scope: !12)
+!29 = !DILocalVariable(name: "this", arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !17, type: !30)
+!30 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !4)
+!31 = !DILocation(line: 0, scope: !17, inlinedAt: !22)
+!32 = !DILocalVariable(name: "this", arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !16, type: !30)
+!33 = !DILocation(line: 0, scope: !16, inlinedAt: !21)
+
+!129 = !DILocalVariable(name: "this", arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !17, type: !30)
+!132 = !DILocalVariable(name: "this", arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !16, type: !30)
+!232 = !DILocalVariable(name: "this", arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !16, type: !30)
+
+!34 = !DILocation(line: 5, scope: !35)
+!35 = distinct !DILexicalBlock(line: 5, column: 0, file: !5, scope: !36)
+!36 = distinct !DILexicalBlock(line: 5, column: 0, file: !5, scope: !12)
+!37 = !DILocation(line: 6, scope: !17)
+!38 = !DILocation(line: 0, scope: !17)
+!39 = !DILocation(line: 0, scope: !16, inlinedAt: !37)
+!40 = !DILocation(line: 0, scope: !16)
+!41 = !DILocation(line: 6, scope: !16)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/bug_null_debuginfo.ll b/test/DebugInfo/Generic/bug_null_debuginfo.ll
new file mode 100644
index 0000000..02201bf
--- /dev/null
+++ b/test/DebugInfo/Generic/bug_null_debuginfo.ll
@@ -0,0 +1,14 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!2}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, isOptimized: false, emissionKind: FullDebug, file: !1, globals:  null)
+!1 = !DIFile(filename: "t", directory: "")
+!2 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/constant-pointers.ll b/test/DebugInfo/Generic/constant-pointers.ll
new file mode 100644
index 0000000..63c5e03
--- /dev/null
+++ b/test/DebugInfo/Generic/constant-pointers.ll
@@ -0,0 +1,56 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj %t.ll -o - | llvm-dwarfdump -v -debug-info - | FileCheck %s
+
+; Ensure that pointer constants are emitted as unsigned data. Alternatively,
+; these could be signless data (dataN).
+
+; Built with Clang from:
+; template <void *V, void (*F)(), int i>
+; void func() {}
+; template void func<nullptr, nullptr, 42>();
+
+; CHECK: DW_TAG_subprogram
+; CHECK:   DW_TAG_template_value_parameter
+; CHECK:     DW_AT_name {{.*}} "V"
+; CHECK:     DW_AT_const_value [DW_FORM_udata] (0)
+; CHECK:   DW_TAG_template_value_parameter
+; CHECK:     DW_AT_name {{.*}} "F"
+; CHECK:     DW_AT_const_value [DW_FORM_udata] (0)
+
+; Function Attrs: nounwind uwtable
+define weak_odr void @_Z4funcILPv0ELPFvvE0ELi42EEvv() #0 !dbg !4 {
+entry:
+  ret void, !dbg !18
+}
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!15, !16}
+!llvm.ident = !{!17}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "constant-pointers.cpp", directory: "/tmp/dbginfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "func<nullptr, nullptr, 42>", linkageName: "_Z4funcILPv0ELPFvvE0ELi42EEvv", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 2, file: !1, scope: !5, type: !6, templateParams: !8, retainedNodes: !2)
+!5 = !DIFile(filename: "constant-pointers.cpp", directory: "/tmp/dbginfo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{null}
+!8 = !{!9, !11, !13}
+!9 = !DITemplateValueParameter(tag: DW_TAG_template_value_parameter, name: "V", type: !10, value: i8 0)
+!10 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: null)
+!11 = !DITemplateValueParameter(tag: DW_TAG_template_value_parameter, name: "F", type: !12, value: i8 0)
+!12 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !6)
+!13 = !DITemplateValueParameter(tag: DW_TAG_template_value_parameter, name: "i", type: !14, value: i32 42)
+!14 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!15 = !{i32 2, !"Dwarf Version", i32 4}
+!16 = !{i32 2, !"Debug Info Version", i32 3}
+!17 = !{!"clang version 3.5.0 "}
+!18 = !DILocation(line: 3, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/dead-argument-order.ll b/test/DebugInfo/Generic/dead-argument-order.ll
new file mode 100644
index 0000000..b667ab3
--- /dev/null
+++ b/test/DebugInfo/Generic/dead-argument-order.ll
@@ -0,0 +1,86 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck %s
+
+; Built from the following source with clang -O1
+; struct S { int i; };
+; int function(struct S s, int i) { return s.i + i; }
+
+; Due to the X86_64 ABI, 's' is passed in registers and once optimized, the
+; entirety of 's' is never reconstituted, since only the int is required, and
+; thus the variable's location is unknown/dead to debug info.
+
+; Future/current work should enable us to describe partial variables, which, in
+; this case, happens to be the entire variable.
+
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_name {{.*}} "function"
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_name {{.*}} "s"
+; CHECK-NOT: DW_TAG
+; FIXME: Even though 's' is never reconstituted into a struct, the one member
+; variable is still live and used, and so we should be able to describe 's's
+; location as the location of that int.
+; CHECK-NOT: DW_AT_location
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_location
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_name {{.*}} "i"
+
+
+%struct.S = type { i32 }
+
+; Function Attrs: nounwind readnone uwtable
+define i32 @_Z8function1Si(i32 %s.coerce, i32 %i) #0 !dbg !9 {
+entry:
+  tail call void @llvm.dbg.declare(metadata %struct.S* undef, metadata !14, metadata !DIExpression()), !dbg !20
+  tail call void @llvm.dbg.value(metadata i32 %i, metadata !15, metadata !DIExpression()), !dbg !20
+  %add = add nsw i32 %i, %s.coerce, !dbg !20
+  ret i32 %add, !dbg !20
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind readnone uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!16, !17}
+!llvm.ident = !{!18}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: true, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !3, globals: !2, imports: !2)
+!1 = !DIFile(filename: "dead-argument-order.cpp", directory: "/tmp/dbginfo")
+!2 = !{}
+!3 = !{!4}
+!4 = !DICompositeType(tag: DW_TAG_structure_type, name: "S", line: 1, size: 32, align: 32, file: !1, elements: !5, identifier: "_ZTS1S")
+!5 = !{!6}
+!6 = !DIDerivedType(tag: DW_TAG_member, name: "i", line: 1, size: 32, align: 32, file: !1, scope: !4, baseType: !7)
+!7 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = distinct !DISubprogram(name: "function", linkageName: "_Z8function1Si", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 2, file: !1, scope: !10, type: !11, retainedNodes: !13)
+!10 = !DIFile(filename: "dead-argument-order.cpp", directory: "/tmp/dbginfo")
+!11 = !DISubroutineType(types: !12)
+!12 = !{!7, !4, !7}
+!13 = !{!14, !15}
+!14 = !DILocalVariable(name: "s", line: 2, arg: 1, scope: !9, file: !10, type: !4)
+!15 = !DILocalVariable(name: "i", line: 2, arg: 2, scope: !9, file: !10, type: !7)
+!16 = !{i32 2, !"Dwarf Version", i32 4}
+!17 = !{i32 2, !"Debug Info Version", i32 3}
+!18 = !{!"clang version 3.5.0 "}
+!19 = !{%struct.S* undef}
+!20 = !DILocation(line: 2, scope: !9)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/def-line.ll b/test/DebugInfo/Generic/def-line.ll
new file mode 100644
index 0000000..929123e
--- /dev/null
+++ b/test/DebugInfo/Generic/def-line.ll
@@ -0,0 +1,98 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll -filetype=obj | llvm-dwarfdump -debug-info - | FileCheck %s
+
+; Given the following source, ensure that the decl_line/file is correctly
+; emitted and omitted on definitions if it mismatches/matches the declaration
+
+; struct foo {
+;   static void f1() {
+;   }
+;   static void f2();
+;   static void f3();
+; };
+; void foo::f2() {
+;   f1(); // just to ensure f1 is emitted
+; }
+; #line 1 "bar.cpp"
+; void foo::f3() {
+; }
+
+; Skip the declarations
+; CHECK: DW_TAG_subprogram
+; CHECK: DW_TAG_subprogram
+; CHECK: DW_TAG_subprogram
+
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: {{DW_TAG|NULL|DW_AT_decl_file}}
+; CHECK:   DW_AT_decl_line {{.*}}7
+; CHECK-NOT: {{DW_TAG|NULL|DW_AT_decl_file}}
+; CHECK:   DW_AT_specification {{.*}}f2
+; CHECK-NOT: {{DW_TAG|NULL|DW_AT_decl_file}}
+
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: {{DW_TAG|NULL|DW_AT_decl_line|DW_AT_decl_file}}
+; CHECK:   DW_AT_specification {{.*}}f1
+
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_AT_decl_file {{.*}}bar.cpp
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_AT_decl_line {{.*}}1
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_AT_specification {{.*}}f3
+
+; Function Attrs: uwtable
+define void @_ZN3foo2f2Ev() #0 align 2 !dbg !12 {
+entry:
+  call void @_ZN3foo2f1Ev(), !dbg !19
+  ret void, !dbg !20
+}
+
+; Function Attrs: nounwind uwtable
+define linkonce_odr void @_ZN3foo2f1Ev() #1 align 2 !dbg !15 {
+entry:
+  ret void, !dbg !21
+}
+
+; Function Attrs: nounwind uwtable
+define void @_ZN3foo2f3Ev() #1 align 2 !dbg !13 {
+entry:
+  ret void, !dbg !22
+}
+
+attributes #0 = { uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!16, !17}
+!llvm.ident = !{!18}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 3.8.0 (trunk 249440) (llvm/trunk 249465)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !3)
+!1 = !DIFile(filename: "def-line.cpp", directory: "/tmp/dbginfo")
+!2 = !{}
+!3 = !{!4}
+!4 = !DICompositeType(tag: DW_TAG_structure_type, name: "foo", file: !1, line: 1, size: 8, align: 8, elements: !5, identifier: "_ZTS3foo")
+!5 = !{!6, !9, !10}
+!6 = !DISubprogram(name: "f1", linkageName: "_ZN3foo2f1Ev", scope: !4, file: !1, line: 2, type: !7, isLocal: false, isDefinition: false, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: false)
+!7 = !DISubroutineType(types: !8)
+!8 = !{null}
+!9 = !DISubprogram(name: "f2", linkageName: "_ZN3foo2f2Ev", scope: !4, file: !1, line: 4, type: !7, isLocal: false, isDefinition: false, scopeLine: 4, flags: DIFlagPrototyped, isOptimized: false)
+!10 = !DISubprogram(name: "f3", linkageName: "_ZN3foo2f3Ev", scope: !4, file: !1, line: 5, type: !7, isLocal: false, isDefinition: false, scopeLine: 5, flags: DIFlagPrototyped, isOptimized: false)
+!12 = distinct !DISubprogram(name: "f2", linkageName: "_ZN3foo2f2Ev", scope: !4, file: !1, line: 7, type: !7, isLocal: false, isDefinition: true, scopeLine: 7, flags: DIFlagPrototyped, isOptimized: false, unit: !0, declaration: !9, retainedNodes: !2)
+!13 = distinct !DISubprogram(name: "f3", linkageName: "_ZN3foo2f3Ev", scope: !4, file: !14, line: 1, type: !7, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: false, unit: !0, declaration: !10, retainedNodes: !2)
+!14 = !DIFile(filename: "bar.cpp", directory: "/tmp/dbginfo")
+!15 = distinct !DISubprogram(name: "f1", linkageName: "_ZN3foo2f1Ev", scope: !4, file: !1, line: 2, type: !7, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: false, unit: !0, declaration: !6, retainedNodes: !2)
+!16 = !{i32 2, !"Dwarf Version", i32 4}
+!17 = !{i32 2, !"Debug Info Version", i32 3}
+!18 = !{!"clang version 3.8.0 (trunk 249440) (llvm/trunk 249465)"}
+!19 = !DILocation(line: 8, column: 3, scope: !12)
+!20 = !DILocation(line: 9, column: 1, scope: !12)
+!21 = !DILocation(line: 3, column: 3, scope: !15)
+!22 = !DILocation(line: 2, column: 1, scope: !13)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/discriminator.ll b/test/DebugInfo/Generic/discriminator.ll
new file mode 100644
index 0000000..2af2c08
--- /dev/null
+++ b/test/DebugInfo/Generic/discriminator.ll
@@ -0,0 +1,57 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll -filetype=obj | llvm-dwarfdump -debug-info - | FileCheck %s
+
+; Given the following source, ensure that the discriminator is emitted for
+; the inlined callsite.
+
+;void xyz();
+;static void __attribute__((always_inline)) bar() { xyz(); }
+;void foo() {
+;  bar(); bar();
+;}
+
+;CHECK: DW_TAG_inlined_subroutine
+;CHECK-NOT: DW_AT_GNU_discriminator
+;CHECK: DW_TAG_inlined_subroutine
+;CHECK-NOT: {{DW_TAG|NULL}}
+;CHECK: DW_AT_GNU_discriminator{{.*}}0x01
+
+; Function Attrs: uwtable
+define void @_Z3foov() #0 !dbg !4 {
+  tail call void @_Z3xyzv(), !dbg !11
+  tail call void @_Z3xyzv(), !dbg !13
+  ret void, !dbg !16
+}
+
+declare void @_Z3xyzv() #1
+
+attributes #0 = { uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!8, !9}
+!llvm.ident = !{!10}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 3.8.0 (trunk 252497)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "a.cc", directory: "/tmp")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "foo", linkageName: "_Z3foov", scope: !1, file: !1, line: 3, type: !5, isLocal: false, isDefinition: true, scopeLine: 3, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !2)
+!5 = !DISubroutineType(types: !6)
+!6 = !{null}
+!7 = distinct !DISubprogram(name: "bar", linkageName: "_ZL3barv", scope: !1, file: !1, line: 2, type: !5, isLocal: true, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !2)
+!8 = !{i32 2, !"Dwarf Version", i32 4}
+!9 = !{i32 2, !"Debug Info Version", i32 3}
+!10 = !{!"clang version 3.8.0 (trunk 252497)"}
+!11 = !DILocation(line: 2, column: 52, scope: !7, inlinedAt: !12)
+!12 = distinct !DILocation(line: 4, column: 3, scope: !4)
+!13 = !DILocation(line: 2, column: 52, scope: !7, inlinedAt: !14)
+!14 = distinct !DILocation(line: 4, column: 10, scope: !15)
+!15 = !DILexicalBlockFile(scope: !4, file: !1, discriminator: 1)
+!16 = !DILocation(line: 5, column: 1, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/dwarf-public-names.ll b/test/DebugInfo/Generic/dwarf-public-names.ll
new file mode 100644
index 0000000..677ae60
--- /dev/null
+++ b/test/DebugInfo/Generic/dwarf-public-names.ll
@@ -0,0 +1,145 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -debugger-tune=gdb -filetype=obj -o %t.o < %t.ll
+; RUN: llvm-dwarfdump -debug-pubnames %t.o | FileCheck %s
+; ModuleID = 'dwarf-public-names.cpp'
+;
+; Generated from:
+;
+; struct C {
+;   void member_function();
+;   static int static_member_function();
+;   static int static_member_variable;
+; };
+;
+; int C::static_member_variable = 0;
+;
+; void C::member_function() {
+;   static_member_variable = 0;
+; }
+;
+; int C::static_member_function() {
+;   return static_member_variable;
+; }
+;
+; C global_variable;
+;
+; int global_function() {
+;   return -1;
+; }
+;
+; namespace ns {
+;   void global_namespace_function() {
+;     global_variable.member_function();
+;   }
+;   int global_namespace_variable = 1;
+; }
+
+; Skip the output to the header of the pubnames section.
+; CHECK: debug_pubnames
+; CHECK: version = 0x0002
+
+; Check for each name in the output.
+; CHECK-DAG: "ns"
+; CHECK-DAG: "C::static_member_function"
+; CHECK-DAG: "global_variable"
+; CHECK-DAG: "ns::global_namespace_variable"
+; CHECK-DAG: "ns::global_namespace_function"
+; CHECK-DAG: "global_function"
+; CHECK-DAG: "C::static_member_variable"
+; CHECK-DAG: "C::member_function"
+
+source_filename = "test/DebugInfo/Generic/dwarf-public-names.ll"
+
+%struct.C = type { i8 }
+
+@_ZN1C22static_member_variableE = global i32 0, align 4, !dbg !0
+@global_variable = global %struct.C zeroinitializer, align 1, !dbg !15
+@_ZN2ns25global_namespace_variableE = global i32 1, align 4, !dbg !17
+
+; Function Attrs: nounwind uwtable
+define void @_ZN1C15member_functionEv(%struct.C* %this) #0 align 2 !dbg !23 {
+entry:
+  %this.addr = alloca %struct.C*, align 8
+  store %struct.C* %this, %struct.C** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.C** %this.addr, metadata !24, metadata !26), !dbg !27
+  %this1 = load %struct.C*, %struct.C** %this.addr
+  store i32 0, i32* @_ZN1C22static_member_variableE, align 4, !dbg !28
+  ret void, !dbg !29
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+; Function Attrs: nounwind uwtable
+define i32 @_ZN1C22static_member_functionEv() #0 align 2 !dbg !30 {
+entry:
+  %0 = load i32, i32* @_ZN1C22static_member_variableE, align 4, !dbg !31
+  ret i32 %0, !dbg !31
+}
+
+; Function Attrs: nounwind uwtable
+define i32 @_Z15global_functionv() #0 !dbg !32 {
+entry:
+  ret i32 -1, !dbg !33
+}
+
+; Function Attrs: nounwind uwtable
+define void @_ZN2ns25global_namespace_functionEv() #0 !dbg !34 {
+entry:
+  call void @_ZN1C15member_functionEv(%struct.C* @global_variable), !dbg !37
+  ret void, !dbg !38
+}
+
+attributes #0 = { nounwind uwtable }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!20}
+!llvm.module.flags = !{!22}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "static_member_variable", linkageName: "_ZN1C22static_member_variableE", scope: !2, file: !3, line: 7, type: !6, isLocal: false, isDefinition: true, declaration: !5)
+!2 = !DICompositeType(tag: DW_TAG_structure_type, name: "C", file: !3, line: 1, size: 8, align: 8, elements: !4)
+!3 = !DIFile(filename: "dwarf-public-names.cpp", directory: "/usr2/kparzysz/s.hex/t")
+!4 = !{!5, !7, !12}
+!5 = !DIDerivedType(tag: DW_TAG_member, name: "static_member_variable", scope: !2, file: !3, line: 4, baseType: !6, flags: DIFlagStaticMember)
+!6 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!7 = !DISubprogram(name: "member_function", linkageName: "_ZN1C15member_functionEv", scope: !2, file: !3, line: 2, type: !8, isLocal: false, isDefinition: false, scopeLine: 2, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, retainedNodes: !11)
+!8 = !DISubroutineType(types: !9)
+!9 = !{null, !10}
+!10 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !2, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!11 = !{}
+!12 = !DISubprogram(name: "static_member_function", linkageName: "_ZN1C22static_member_functionEv", scope: !2, file: !3, line: 3, type: !13, isLocal: false, isDefinition: false, scopeLine: 3, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, retainedNodes: !11)
+!13 = !DISubroutineType(types: !14)
+!14 = !{!6}
+!15 = !DIGlobalVariableExpression(var: !16, expr: !DIExpression())
+!16 = !DIGlobalVariable(name: "global_variable", scope: null, file: !3, line: 17, type: !2, isLocal: false, isDefinition: true) ; previously: invalid DW_TAG_base_type
+!17 = !DIGlobalVariableExpression(var: !18, expr: !DIExpression())
+!18 = !DIGlobalVariable(name: "global_namespace_variable", linkageName: "_ZN2ns25global_namespace_variableE", scope: !19, file: !3, line: 27, type: !6, isLocal: false, isDefinition: true)
+!19 = !DINamespace(name: "ns", scope: null)
+!20 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !3, producer: "clang version 3.3 (http://llvm.org/git/clang.git a09cd8103a6a719cb2628cdf0c91682250a17bd2) (http://llvm.org/git/llvm.git 47d03cec0afca0c01ae42b82916d1d731716cd20)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !11, retainedTypes: !11, globals: !21, imports: !11) ; previously: invalid DW_TAG_base_type
+!21 = !{!0, !15, !17}
+!22 = !{i32 1, !"Debug Info Version", i32 3}
+!23 = distinct !DISubprogram(name: "member_function", linkageName: "_ZN1C15member_functionEv", scope: null, file: !3, line: 9, type: !8, isLocal: false, isDefinition: true, scopeLine: 9, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !20, declaration: !7, retainedNodes: !11)
+!24 = !DILocalVariable(name: "this", arg: 1, scope: !23, file: !3, line: 9, type: !25, flags: DIFlagArtificial | DIFlagObjectPointer)
+!25 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !2, size: 64, align: 64)
+!26 = !DIExpression()
+!27 = !DILocation(line: 9, scope: !23)
+!28 = !DILocation(line: 10, scope: !23)
+!29 = !DILocation(line: 11, scope: !23)
+!30 = distinct !DISubprogram(name: "static_member_function", linkageName: "_ZN1C22static_member_functionEv", scope: null, file: !3, line: 13, type: !13, isLocal: false, isDefinition: true, scopeLine: 13, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !20, declaration: !12, retainedNodes: !11)
+!31 = !DILocation(line: 14, scope: !30)
+!32 = distinct !DISubprogram(name: "global_function", linkageName: "_Z15global_functionv", scope: !3, file: !3, line: 19, type: !13, isLocal: false, isDefinition: true, scopeLine: 19, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !20, retainedNodes: !11)
+!33 = !DILocation(line: 20, scope: !32)
+!34 = distinct !DISubprogram(name: "global_namespace_function", linkageName: "_ZN2ns25global_namespace_functionEv", scope: !19, file: !3, line: 24, type: !35, isLocal: false, isDefinition: true, scopeLine: 24, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !20, retainedNodes: !11)
+!35 = !DISubroutineType(types: !36)
+!36 = !{null}
+!37 = !DILocation(line: 25, scope: !34)
+!38 = !DILocation(line: 26, scope: !34)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/enum.ll b/test/DebugInfo/Generic/enum.ll
new file mode 100644
index 0000000..71c47f4
--- /dev/null
+++ b/test/DebugInfo/Generic/enum.ll
@@ -0,0 +1,89 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll > %t
+; RUN: llvm-dwarfdump -v %t | FileCheck %s
+
+; IR generated from the following code compiled with clang -g:
+; enum e1 { I, J = 0xffffffffU, K = 0xf000000000000000ULL } a;
+; enum e2 { X };
+; void func() {
+;   int b = X;
+; }
+
+; These values were previously being truncated to -1 and 0 respectively.
+
+; CHECK: debug_info contents
+; CHECK: DW_TAG_enumeration_type
+; CHECK-NEXT: DW_AT_name{{.*}} = "e1"
+; CHECK-NOT: NULL
+; CHECK: DW_TAG_enumerator
+; CHECK-NOT: NULL
+; CHECK: DW_TAG_enumerator
+; CHECK-NEXT: DW_AT_name{{.*}} = "J"
+; CHECK-NEXT: DW_AT_const_value [DW_FORM_sdata]     (4294967295)
+; CHECK-NOT: NULL
+; CHECK: DW_TAG_enumerator
+; CHECK-NEXT: DW_AT_name{{.*}} = "K"
+; CHECK-NEXT: DW_AT_const_value [DW_FORM_sdata]     (-1152921504606846976)
+
+; Check that we retain enums that aren't referenced by any variables, etc
+; CHECK: DW_TAG_enumeration_type
+; CHECK-NEXT: DW_AT_name{{.*}} = "e2"
+; CHECK-NOT: NULL
+; CHECK: DW_TAG_enumerator
+; CHECK-NEXT: DW_AT_name{{.*}} = "X"
+
+source_filename = "test/DebugInfo/Generic/enum.ll"
+
+@a = global i64 0, align 8, !dbg !0
+
+; Function Attrs: nounwind uwtable
+define void @_Z4funcv() #0 !dbg !17 {
+entry:
+  %b = alloca i32, align 4
+  call void @llvm.dbg.declare(metadata i32* %b, metadata !20, metadata !22), !dbg !23
+  store i32 0, i32* %b, align 4, !dbg !23
+  ret void, !dbg !24
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!8}
+!llvm.module.flags = !{!15, !16}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "a", scope: null, file: !2, line: 1, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "enum.cpp", directory: "/tmp")
+!3 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "e1", file: !2, line: 1, size: 64, align: 64, elements: !4)
+!4 = !{!5, !6, !7}
+!5 = !DIEnumerator(name: "I", value: 0)
+!6 = !DIEnumerator(name: "J", value: 4294967295) ; [ DW_TAG_enumerator ] [I :: 0]
+!7 = !DIEnumerator(name: "K", value: -1152921504606846976) ; [ DW_TAG_enumerator ] [J :: 4294967295]
+!8 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.4 ", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !9, retainedTypes: !13, globals: !14, imports: !13) ; [ DW_TAG_enumerator ] [K :: 17293822569102704640]
+!9 = !{!3, !10}
+!10 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "e2", file: !2, line: 2, size: 32, align: 32, elements: !11)
+!11 = !{!12}
+!12 = !DIEnumerator(name: "X", value: 0) ; [ DW_TAG_enumerator ] [X :: 0]
+!13 = !{}
+!14 = !{!0}
+!15 = !{i32 2, !"Dwarf Version", i32 3}
+!16 = !{i32 1, !"Debug Info Version", i32 3}
+!17 = distinct !DISubprogram(name: "func", linkageName: "_Z4funcv", scope: !2, file: !2, line: 3, type: !18, isLocal: false, isDefinition: true, scopeLine: 3, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !8, retainedNodes: !13)
+!18 = !DISubroutineType(types: !19)
+!19 = !{null}
+!20 = !DILocalVariable(name: "b", scope: !17, file: !2, line: 4, type: !21)
+!21 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!22 = !DIExpression()
+!23 = !DILocation(line: 4, scope: !17)
+!24 = !DILocation(line: 5, scope: !17)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/global.ll b/test/DebugInfo/Generic/global.ll
new file mode 100644
index 0000000..6683991
--- /dev/null
+++ b/test/DebugInfo/Generic/global.ll
@@ -0,0 +1,50 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll > %t
+; RUN: llvm-dwarfdump %t | FileCheck %s
+
+; Also test that the null streamer doesn't crash with debug info.
+; RUN: llc -mtriple=%triple -O0 -filetype=null < %t.ll
+
+; generated from the following source compiled to bitcode with clang -g -O1
+; static int i;
+; int main() {
+;   (void)&i;
+; }
+
+; CHECK: debug_info contents
+; CHECK: DW_TAG_variable
+
+source_filename = "test/DebugInfo/Generic/global.ll"
+
+; Function Attrs: nounwind readnone uwtable
+define i32 @main() #0 !dbg !9 {
+entry:
+  ret i32 0, !dbg !12
+}
+
+attributes #0 = { nounwind readnone uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!7, !8}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 3.4 ", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, globals: !3, imports: !2)
+!1 = !DIFile(filename: "global.cpp", directory: "/tmp")
+!2 = !{}
+!3 = !{!4}
+!4 = !DIGlobalVariableExpression(var: !5, expr: !DIExpression())
+!5 = !DIGlobalVariable(name: "i", linkageName: "_ZL1i", scope: null, file: !1, line: 1, type: !6, isLocal: true, isDefinition: true)
+!6 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!7 = !{i32 2, !"Dwarf Version", i32 3}
+!8 = !{i32 1, !"Debug Info Version", i32 3}
+!9 = distinct !DISubprogram(name: "main", scope: !1, file: !1, line: 2, type: !10, isLocal: false, isDefinition: true, scopeLine: 2, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !2)
+!10 = !DISubroutineType(types: !11)
+!11 = !{!6}
+!12 = !DILocation(line: 4, scope: !9)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/gmlt_profiling.ll b/test/DebugInfo/Generic/gmlt_profiling.ll
new file mode 100644
index 0000000..81b2d03
--- /dev/null
+++ b/test/DebugInfo/Generic/gmlt_profiling.ll
@@ -0,0 +1,38 @@
+; REQUIRES: object-emission
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %S/gmlt_profiling.ll | llvm-dwarfdump -v - | FileCheck %S/gmlt_profiling.ll
+
+; CHECK: .debug_info
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_name {{.*}} "f1"
+; With debug-info-for-profiling attribute, we need to emit decl_file and
+; decl_line of the subprogram.
+; CHECK-NEXT: DW_AT_decl_file
+; CHECK-NEXT: DW_AT_decl_line
+
+; Function Attrs: nounwind uwtable
+define void @_Z2f1v() !dbg !4 {
+entry:
+  ret void, !dbg !13
+}
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!10, !11}
+!llvm.ident = !{!12}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.6.0 ", isOptimized: false, emissionKind: LineTablesOnly, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2, debugInfoForProfiling: true)
+!1 = !DIFile(filename: "gmlt.cpp", directory: "/tmp/dbginfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "f1", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 1, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "gmlt.cpp", directory: "/tmp/dbginfo")
+!6 = !DISubroutineType(types: !2)
+!10 = !{i32 2, !"Dwarf Version", i32 4}
+!11 = !{i32 2, !"Debug Info Version", i32 3}
+!12 = !{!"clang version 3.6.0 "}
+!13 = !DILocation(line: 1, column: 12, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/imported-name-inlined.ll b/test/DebugInfo/Generic/imported-name-inlined.ll
new file mode 100644
index 0000000..f79a51c
--- /dev/null
+++ b/test/DebugInfo/Generic/imported-name-inlined.ll
@@ -0,0 +1,72 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck --implicit-check-not "{{DW_TAG|NULL}}" %s
+
+; Generated from the following source:
+; namespace ns {
+; void f();
+; }
+; inline __attribute__((always_inline)) void f1() {
+;   using ns::f;
+;   f();
+; }
+; void f2() { f1(); }
+
+; Ensure that top level imported declarations don't produce an extra degenerate
+; concrete subprogram definition.
+
+; FIXME: imported entities should only be emitted to the abstract origin if one is present
+
+; CHECK: DW_TAG_compile_unit
+; CHECK:   DW_TAG_subprogram
+; CHECK:     DW_AT_name {{.*}} "f1"
+; CHECK:     DW_TAG_imported_declaration
+; CHECK:     NULL
+; CHECK:   DW_TAG_namespace
+; CHECK:     DW_TAG_subprogram
+; CHECK:     NULL
+; CHECK:   DW_TAG_subprogram
+; CHECK:     DW_AT_name {{.*}} "f2"
+; CHECK:     DW_TAG_inlined_subroutine
+; CHECK:       DW_TAG_imported_declaration
+; CHECK:       NULL
+; CHECK:     NULL
+; CHECK:   NULL
+
+; Function Attrs: noinline
+define void @_Z2f2v() noinline !dbg !14 {
+entry:
+  call void @_ZN2ns1fEv(), !dbg !15
+  ret void, !dbg !17
+}
+
+declare void @_ZN2ns1fEv()
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!10, !11, !12}
+!llvm.ident = !{!13}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 6.0.0 (trunk 309061) (llvm/trunk 309076)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, imports: !3)
+!1 = !DIFile(filename: "imported-name-inlined.cpp", directory: "/usr/local/google/home/blaikie/dev/scratch")
+!2 = !{}
+!3 = !{!4}
+!4 = !DIImportedEntity(tag: DW_TAG_imported_declaration, scope: !5, entity: !8, file: !1, line: 5)
+!5 = distinct !DISubprogram(name: "f1", linkageName: "_Z2f1v", scope: !1, file: !1, line: 4, type: !6, isLocal: false, isDefinition: true, scopeLine: 4, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!6 = !DISubroutineType(types: !7)
+!7 = !{null}
+!8 = !DISubprogram(name: "f", linkageName: "_ZN2ns1fEv", scope: !9, file: !1, line: 2, type: !6, isLocal: false, isDefinition: false, flags: DIFlagPrototyped, isOptimized: false)
+!9 = !DINamespace(name: "ns", scope: null)
+!10 = !{i32 2, !"Dwarf Version", i32 4}
+!11 = !{i32 2, !"Debug Info Version", i32 3}
+!12 = !{i32 1, !"wchar_size", i32 4}
+!13 = !{!"clang version 6.0.0 (trunk 309061) (llvm/trunk 309076)"}
+!14 = distinct !DISubprogram(name: "f2", linkageName: "_Z2f2v", scope: !1, file: !1, line: 8, type: !6, isLocal: false, isDefinition: true, scopeLine: 8, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!15 = !DILocation(line: 6, column: 3, scope: !5, inlinedAt: !16)
+!16 = distinct !DILocation(line: 8, column: 13, scope: !14)
+!17 = !DILocation(line: 8, column: 19, scope: !14)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/incorrect-variable-debugloc1.ll b/test/DebugInfo/Generic/incorrect-variable-debugloc1.ll
new file mode 100644
index 0000000..fe4b64b
--- /dev/null
+++ b/test/DebugInfo/Generic/incorrect-variable-debugloc1.ll
@@ -0,0 +1,86 @@
+; REQUIRES: object-emission
+; This test is failing for powerpc64, because a location list for the
+; variable 'c' is not generated at all. Temporary marking this test as XFAIL 
+; for powerpc, until PR21881 is fixed.
+; XFAIL: powerpc64
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O2  -dwarf-version 2 -filetype=obj < %t.ll | llvm-dwarfdump - | FileCheck %s  --check-prefix=DWARF23
+; RUN: llc -mtriple=%triple -O2  -dwarf-version 3 -filetype=obj < %t.ll | llvm-dwarfdump - | FileCheck %s  --check-prefix=DWARF23
+; RUN: llc -mtriple=%triple -O2  -dwarf-version 4 -filetype=obj < %t.ll | llvm-dwarfdump - | FileCheck %s  --check-prefix=DWARF4
+
+; This is a test for PR21176.
+; DW_OP_const <const> doesn't describe a constant value, but a value at a constant address. 
+; The proper way to describe a constant value is DW_OP_constu <const>, DW_OP_stack_value.
+
+; Generated with clang -S -emit-llvm -g -O2 test.cpp
+
+; extern int func();
+; 
+; int main()
+; {
+;   volatile int c = 13;
+;   c = func();
+;   return c;
+; }
+
+; CHECK: DW_TAG_variable
+; CHECK: DW_AT_location
+; CHECK-NOT: DW_AT
+; DWARF23: DW_OP_constu 0xd{{$}}
+; DWARF4: DW_OP_constu 0xd, DW_OP_stack_value{{$}}
+
+; Function Attrs: uwtable
+define i32 @main() #0 !dbg !4 {
+entry:
+  %c = alloca i32, align 4
+  tail call void @llvm.dbg.value(metadata i32 13, metadata !10, metadata !16), !dbg !17
+  store volatile i32 13, i32* %c, align 4, !dbg !18
+  %call = tail call i32 @_Z4funcv(), !dbg !19
+  tail call void @llvm.dbg.value(metadata i32 %call, metadata !10, metadata !16), !dbg !17
+  store volatile i32 %call, i32* %c, align 4, !dbg !19
+  tail call void @llvm.dbg.value(metadata i32* %c, metadata !10, metadata !21), !dbg !17
+  %c.0.c.0. = load volatile i32, i32* %c, align 4, !dbg !20
+  ret i32 %c.0.c.0., !dbg !20
+}
+
+declare i32 @_Z4funcv() #1
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #2
+
+attributes #0 = { uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #2 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!12, !13}
+!llvm.ident = !{!14}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.6.0 (trunk 223522)", isOptimized: true, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "test.cpp", directory: "/home/kromanova/ngh/ToT_latest/llvm/test/DebugInfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "main", line: 3, isLocal: false, isDefinition: true, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 4, file: !1, scope: !5, type: !6, retainedNodes: !9)
+!5 = !DIFile(filename: "test.cpp", directory: "/home/kromanova/ngh/ToT_latest/llvm/test/DebugInfo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = !{!10}
+!10 = !DILocalVariable(name: "c", line: 5, scope: !4, file: !5, type: !11)
+!11 = !DIDerivedType(tag: DW_TAG_volatile_type, baseType: !8)
+!12 = !{i32 2, !"Dwarf Version", i32 2}
+!13 = !{i32 2, !"Debug Info Version", i32 3}
+!14 = !{!"clang version 3.6.0 (trunk 223522)"}
+!15 = !{i32 13}
+!16 = !DIExpression()
+!17 = !DILocation(line: 5, column: 16, scope: !4)
+!18 = !DILocation(line: 5, column: 3, scope: !4)
+!19 = !DILocation(line: 6, column: 7, scope: !4)
+!20 = !DILocation(line: 7, column: 3, scope: !4)
+!21 = !DIExpression(DW_OP_deref)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/inline-scopes.ll b/test/DebugInfo/Generic/inline-scopes.ll
new file mode 100644
index 0000000..d58fc44
--- /dev/null
+++ b/test/DebugInfo/Generic/inline-scopes.ll
@@ -0,0 +1,135 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll | llvm-dwarfdump -debug-info - | FileCheck %s
+
+; bool f();
+; inline __attribute__((always_inline)) int f1() {
+;   if (bool b = f())
+;     return 1;
+;   return 2;
+; }
+;
+; inline __attribute__((always_inline)) int f2() {
+; # 2 "y.cc"
+;   if (bool b = f())
+;     return 3;
+;   return 4;
+; }
+;
+; int main() {
+;   f1();
+;   f2();
+; }
+
+; Ensure that lexical_blocks within inlined_subroutines are preserved/emitted.
+; CHECK: DW_TAG_inlined_subroutine
+; CHECK-NOT: DW_TAG
+; CHECK-NOT: NULL
+; CHECK: DW_TAG_lexical_block
+; CHECK-NOT: DW_TAG
+; CHECK-NOT: NULL
+; CHECK: DW_TAG_variable
+; Ensure that file changes don't interfere with creating inlined subroutines.
+; (see the line directive inside 'f2' in thesource)
+; CHECK: DW_TAG_inlined_subroutine
+; CHECK:   DW_TAG_variable
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_abstract_origin
+
+; Function Attrs: uwtable
+define i32 @main() #0 !dbg !4 {
+entry:
+  %retval.i2 = alloca i32, align 4
+  %b.i3 = alloca i8, align 1
+  %retval.i = alloca i32, align 4
+  %b.i = alloca i8, align 1
+  call void @llvm.dbg.declare(metadata i8* %b.i, metadata !16, metadata !DIExpression()), !dbg !19
+  %call.i = call zeroext i1 @_Z1fv(), !dbg !19
+  %frombool.i = zext i1 %call.i to i8, !dbg !19
+  store i8 %frombool.i, i8* %b.i, align 1, !dbg !19
+  %0 = load i8, i8* %b.i, align 1, !dbg !19
+  %tobool.i = trunc i8 %0 to i1, !dbg !19
+  br i1 %tobool.i, label %if.then.i, label %if.end.i, !dbg !19
+
+if.then.i:                                        ; preds = %entry
+  store i32 1, i32* %retval.i, !dbg !21
+  br label %_Z2f1v.exit, !dbg !21
+
+if.end.i:                                         ; preds = %entry
+  store i32 2, i32* %retval.i, !dbg !22
+  br label %_Z2f1v.exit, !dbg !22
+
+_Z2f1v.exit:                                      ; preds = %if.then.i, %if.end.i
+  %1 = load i32, i32* %retval.i, !dbg !23
+  call void @llvm.dbg.declare(metadata i8* %b.i3, metadata !24, metadata !DIExpression()), !dbg !27
+  %call.i4 = call zeroext i1 @_Z1fv(), !dbg !27
+  %frombool.i5 = zext i1 %call.i4 to i8, !dbg !27
+  store i8 %frombool.i5, i8* %b.i3, align 1, !dbg !27
+  %2 = load i8, i8* %b.i3, align 1, !dbg !27
+  %tobool.i6 = trunc i8 %2 to i1, !dbg !27
+  br i1 %tobool.i6, label %if.then.i7, label %if.end.i8, !dbg !27
+
+if.then.i7:                                       ; preds = %_Z2f1v.exit
+  store i32 3, i32* %retval.i2, !dbg !29
+  br label %_Z2f2v.exit, !dbg !29
+
+if.end.i8:                                        ; preds = %_Z2f1v.exit
+  store i32 4, i32* %retval.i2, !dbg !30
+  br label %_Z2f2v.exit, !dbg !30
+
+_Z2f2v.exit:                                      ; preds = %if.then.i7, %if.end.i8
+  %3 = load i32, i32* %retval.i2, !dbg !31
+  ret i32 0, !dbg !32
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+declare zeroext i1 @_Z1fv() #2
+
+attributes #0 = { uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+attributes #2 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!13, !14}
+!llvm.ident = !{!15}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "inline-scopes.cpp", directory: "/tmp/dbginfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "main", line: 7, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 7, file: !5, scope: !6, type: !7, retainedNodes: !2)
+!5 = !DIFile(filename: "y.cc", directory: "/tmp/dbginfo")
+!6 = !DIFile(filename: "y.cc", directory: "/tmp/dbginfo")
+!7 = !DISubroutineType(types: !8)
+!8 = !{!9}
+!9 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!10 = distinct !DISubprogram(name: "f2", linkageName: "_Z2f2v", line: 8, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 8, file: !1, scope: !11, type: !7, retainedNodes: !2)
+!11 = !DIFile(filename: "inline-scopes.cpp", directory: "/tmp/dbginfo")
+!12 = distinct !DISubprogram(name: "f1", linkageName: "_Z2f1v", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 2, file: !1, scope: !11, type: !7, retainedNodes: !2)
+!13 = !{i32 2, !"Dwarf Version", i32 4}
+!14 = !{i32 1, !"Debug Info Version", i32 3}
+!15 = !{!"clang version 3.5.0 "}
+!16 = !DILocalVariable(name: "b", line: 3, scope: !17, file: !11, type: !18)
+!17 = distinct !DILexicalBlock(line: 3, column: 0, file: !1, scope: !12)
+!18 = !DIBasicType(tag: DW_TAG_base_type, name: "bool", size: 8, align: 8, encoding: DW_ATE_boolean)
+!19 = !DILocation(line: 3, scope: !17, inlinedAt: !20)
+!20 = !DILocation(line: 8, scope: !4)
+!21 = !DILocation(line: 4, scope: !17, inlinedAt: !20)
+!22 = !DILocation(line: 5, scope: !12, inlinedAt: !20)
+!23 = !DILocation(line: 6, scope: !12, inlinedAt: !20)
+!24 = !DILocalVariable(name: "b", line: 2, scope: !25, file: !6, type: !18)
+!25 = distinct !DILexicalBlock(line: 2, column: 0, file: !5, scope: !26)
+!26 = !DILexicalBlockFile(discriminator: 0, file: !5, scope: !10)
+!27 = !DILocation(line: 2, scope: !25, inlinedAt: !28)
+!28 = !DILocation(line: 9, scope: !4)
+!29 = !DILocation(line: 3, scope: !25, inlinedAt: !28)
+!30 = !DILocation(line: 4, scope: !26, inlinedAt: !28)
+!31 = !DILocation(line: 5, scope: !26, inlinedAt: !28)
+!32 = !DILocation(line: 10, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/inlined-arguments.ll b/test/DebugInfo/Generic/inlined-arguments.ll
new file mode 100644
index 0000000..eb79274
--- /dev/null
+++ b/test/DebugInfo/Generic/inlined-arguments.ll
@@ -0,0 +1,84 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj < %t.ll > %t
+; RUN: llvm-dwarfdump %t | FileCheck %s
+
+; IR generated from clang -O -g with the following source
+;
+; void f1(int x, int y);
+; void f3(int line);
+; void f2() {
+;   f1(1, 2);
+; }
+; void f1(int x, int y) {
+;   f3(y);
+; }
+
+; CHECK: DW_AT_name{{.*}}"f1"
+; CHECK: DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_name{{.*}}"x"
+; CHECK: DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_name{{.*}}"y"
+
+; Function Attrs: uwtable
+define void @_Z2f2v() #0 !dbg !4 {
+  tail call void @llvm.dbg.value(metadata i32 undef, metadata !16, metadata !DIExpression()), !dbg !18
+  tail call void @llvm.dbg.value(metadata i32 2, metadata !20, metadata !DIExpression()), !dbg !18
+  tail call void @_Z2f3i(i32 2), !dbg !21
+  ret void, !dbg !22
+}
+
+; Function Attrs: uwtable
+define void @_Z2f1ii(i32 %x, i32 %y) #0 !dbg !8 {
+  tail call void @llvm.dbg.value(metadata i32 %x, metadata !13, metadata !DIExpression()), !dbg !23
+  tail call void @llvm.dbg.value(metadata i32 %y, metadata !14, metadata !DIExpression()), !dbg !23
+  tail call void @_Z2f3i(i32 %y), !dbg !24
+  ret void, !dbg !25
+}
+
+declare void @_Z2f3i(i32) #1
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #2
+
+attributes #0 = { uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #2 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!26}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.4 ", isOptimized: true, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "exp.cpp", directory: "/usr/local/google/home/blaikie/dev/scratch")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "f2", linkageName: "_Z2f2v", line: 3, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 3, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "exp.cpp", directory: "/usr/local/google/home/blaikie/dev/scratch")
+!6 = !DISubroutineType(types: !7)
+!7 = !{null}
+!8 = distinct !DISubprogram(name: "f1", linkageName: "_Z2f1ii", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 6, file: !1, scope: !5, type: !9, retainedNodes: !12)
+!9 = !DISubroutineType(types: !10)
+!10 = !{null, !11, !11}
+!11 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!12 = !{!13, !14}
+!13 = !DILocalVariable(name: "x", line: 6, arg: 1, scope: !8, file: !5, type: !11)
+!14 = !DILocalVariable(name: "y", line: 6, arg: 2, scope: !8, file: !5, type: !11)
+!15 = !{i32 undef}
+!16 = !DILocalVariable(name: "x", line: 6, arg: 1, scope: !8, file: !5, type: !11)
+!17 = !DILocation(line: 4, scope: !4)
+!18 = !DILocation(line: 6, scope: !8, inlinedAt: !17)
+!19 = !{i32 2}
+!20 = !DILocalVariable(name: "y", line: 6, arg: 2, scope: !8, file: !5, type: !11)
+!21 = !DILocation(line: 7, scope: !8, inlinedAt: !17)
+!22 = !DILocation(line: 5, scope: !4)
+!23 = !DILocation(line: 6, scope: !8)
+!24 = !DILocation(line: 7, scope: !8)
+!25 = !DILocation(line: 8, scope: !8)
+!26 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/inlined-vars.ll b/test/DebugInfo/Generic/inlined-vars.ll
new file mode 100644
index 0000000..a12c88b
--- /dev/null
+++ b/test/DebugInfo/Generic/inlined-vars.ll
@@ -0,0 +1,61 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 < %t.ll | FileCheck %s -check-prefix ARGUMENT
+; RUN: llc -mtriple=%triple -O0 < %t.ll | FileCheck %s -check-prefix VARIABLE
+; PR 13202
+
+define i32 @main() uwtable !dbg !5 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 0, metadata !18, metadata !DIExpression()), !dbg !21
+  tail call void @llvm.dbg.value(metadata i32 0, metadata !22, metadata !DIExpression()), !dbg !23
+  tail call void @smth(i32 0), !dbg !24
+  tail call void @smth(i32 0), !dbg !25
+  ret i32 0, !dbg !19
+}
+
+declare void @smth(i32)
+
+declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!27}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.2 (trunk 159419)", isOptimized: true, emissionKind: FullDebug, file: !26, enums: !2, retainedTypes: !2, globals: !2, imports:  !2)
+!1 = !{i32 0}
+!2 = !{}
+!5 = distinct !DISubprogram(name: "main", line: 10, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 10, file: !26, scope: !6, type: !7, retainedNodes: !2)
+!6 = !DIFile(filename: "inline-bug.cc", directory: "/tmp/dbginfo/pr13202")
+!7 = !DISubroutineType(types: !8)
+!8 = !{!9}
+!9 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!10 = distinct !DISubprogram(name: "f", linkageName: "_ZL1fi", line: 3, isLocal: true, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 3, file: !26, scope: !6, type: !11, retainedNodes: !13)
+!11 = !DISubroutineType(types: !12)
+!12 = !{!9, !9}
+!13 = !{!15, !16}
+!15 = !DILocalVariable(name: "argument", line: 3, arg: 1, scope: !10, file: !6, type: !9)
+
+; Two DW_TAG_formal_parameter: one abstract and one inlined.
+; ARGUMENT: {{.*Abbrev.*DW_TAG_formal_parameter}}
+; ARGUMENT: {{.*Abbrev.*DW_TAG_formal_parameter}}
+; ARGUMENT-NOT: {{.*Abbrev.*DW_TAG_formal_parameter}}
+
+!16 = !DILocalVariable(name: "local", line: 4, scope: !10, file: !6, type: !9)
+
+; Two DW_TAG_variable: one abstract and one inlined.
+; VARIABLE: {{.*Abbrev.*DW_TAG_variable}}
+; VARIABLE: {{.*Abbrev.*DW_TAG_variable}}
+; VARIABLE-NOT: {{.*Abbrev.*DW_TAG_variable}}
+
+!18 = !DILocalVariable(name: "argument", line: 3, arg: 1, scope: !10, file: !6, type: !9)
+!19 = !DILocation(line: 11, column: 10, scope: !5)
+!21 = !DILocation(line: 3, column: 25, scope: !10, inlinedAt: !19)
+!22 = !DILocalVariable(name: "local", line: 4, scope: !10, file: !6, type: !9)
+!23 = !DILocation(line: 4, column: 16, scope: !10, inlinedAt: !19)
+!24 = !DILocation(line: 5, column: 3, scope: !10, inlinedAt: !19)
+!25 = !DILocation(line: 6, column: 3, scope: !10, inlinedAt: !19)
+!26 = !DIFile(filename: "inline-bug.cc", directory: "/tmp/dbginfo/pr13202")
+!27 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/linear-dbg-value.ll b/test/DebugInfo/Generic/linear-dbg-value.ll
new file mode 100644
index 0000000..6e53ff9
--- /dev/null
+++ b/test/DebugInfo/Generic/linear-dbg-value.ll
@@ -0,0 +1,82 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -stop-before=expand-isel-pseudos -pre-RA-sched=linearize < %t.ll | FileCheck %s
+
+; RUN: llvm-spirv %t.spv -to-text -o - | FileCheck --check-prefix CHECK-SPIRV %s
+; CHECK-SPIRV: ExtInstImport [[Set:[0-9]+]] "SPIRV.debug"
+; CHECK-SPIRV: TypeVoid [[Void:[0-9]+]]
+; CHECK-SPIRV: ExtInst [[Void]] {{[0-9]+}} [[Set]] DebugValue
+
+source_filename = "linear-dbg-value.ll"
+
+; Function Attrs: nounwind readonly uwtable
+define i32 @foo(i32* nocapture readonly %a, i32 %N) local_unnamed_addr #0 !dbg !6 {
+entry:
+  %cmp6 = icmp sgt i32 %N, 0, !dbg !11
+  br i1 %cmp6, label %for.body.preheader, label %for.cond.cleanup, !dbg !15
+
+for.body.preheader:                               ; preds = %entry
+  %wide.trip.count = zext i32 %N to i64
+  br label %for.body, !dbg !17
+
+for.cond.cleanup.loopexit:                        ; preds = %for.body
+  br label %for.cond.cleanup, !dbg !19
+
+for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
+  %x.0.lcssa = phi i32 [ 0, %entry ], [ %add, %for.cond.cleanup.loopexit ]
+  ret i32 %x.0.lcssa, !dbg !19
+
+for.body:                                         ; preds = %for.body, %for.body.preheader
+; CHECK: ![[X:[0-9]+]] = !DILocalVariable(name: "x",
+; CHECK-LABEL: bb.3.for.body:
+; CHECK: DBG_VALUE {{.*}} ![[X]], !DIExpression()
+; CHECK: DBG_VALUE {{.*}} ![[X]], !DIExpression()
+  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ]
+  %x.07 = phi i32 [ %add, %for.body ], [ 0, %for.body.preheader ]
+  %arrayidx = getelementptr inbounds i32, i32* %a, i64 %indvars.iv, !dbg !17
+  %0 = load i32, i32* %arrayidx, align 4, !dbg !17
+  %add = add nsw i32 %0, %x.07, !dbg !17
+  call void @llvm.dbg.value(metadata i32 %add, metadata !9, metadata !DIExpression()), !dbg !20
+  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !21
+  call void @llvm.dbg.value(metadata i32 %add, metadata !9, metadata !DIExpression()), !dbg !20
+  %exitcond = icmp eq i64 %indvars.iv.next, %wide.trip.count, !dbg !11
+  br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body, !dbg !15
+}
+
+; Function Attrs: nounwind readnone speculatable
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind readonly uwtable }
+attributes #1 = { nounwind readnone speculatable }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+!llvm.ident = !{!5}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 4.0.1 ", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "foo.c", directory: "/tmp")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{!"clang version 4.0.1 "}
+!6 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 2, type: !7, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !8)
+!7 = !DISubroutineType(types: !2)
+!8 = !{!9}
+!9 = !DILocalVariable(name: "x", scope: !6, file: !1, line: 3, type: !10)
+!10 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!11 = !DILocation(line: 4, scope: !12)
+!12 = !DILexicalBlockFile(scope: !13, file: !1, discriminator: 1)
+!13 = distinct !DILexicalBlock(scope: !14, file: !1, line: 4, column: 3)
+!14 = distinct !DILexicalBlock(scope: !6, file: !1, line: 4, column: 3)
+!15 = !DILocation(line: 4, scope: !16)
+!16 = !DILexicalBlockFile(scope: !14, file: !1, discriminator: 1)
+!17 = !DILocation(line: 5, scope: !18)
+!18 = distinct !DILexicalBlock(scope: !13, file: !1, line: 4, column: 31)
+!19 = !DILocation(line: 7, scope: !6)
+!20 = !DILocation(line: 3, scope: !6)
+!21 = !DILocation(line: 4, scope: !22)
+!22 = !DILexicalBlockFile(scope: !13, file: !1, discriminator: 3)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/linkage-name-abstract.ll b/test/DebugInfo/Generic/linkage-name-abstract.ll
new file mode 100644
index 0000000..43c752b
--- /dev/null
+++ b/test/DebugInfo/Generic/linkage-name-abstract.ll
@@ -0,0 +1,138 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj -dwarf-linkage-names=Abstract < %t.ll | llvm-dwarfdump -v -debug-info - > %t
+; RUN: FileCheck %s -check-prefix=ONENAME < %t
+; RUN: FileCheck %s -check-prefix=REF < %t 
+; Verify tuning for SCE gets us Abstract only.
+; RUN: llc -mtriple=%triple -O0 -filetype=obj -debugger-tune=sce < %t.ll | llvm-dwarfdump -v -debug-info - > %t
+; RUN: FileCheck %s -check-prefix=ONENAME < %t
+; RUN: FileCheck %s -check-prefix=REF < %t 
+; REQUIRES: object-emission
+
+; Verify that the only linkage-name present is the abstract origin of the
+; inlined subprogram.
+
+; IR generated from clang -O0 with:
+; void f1();
+; __attribute__((always_inline)) void f2() { 
+;   f1();
+; }
+; void f3() {
+;   f2();
+; }
+;
+; struct F4 {
+;   __attribute__((always_inline)) void f5();
+; };
+; void F4::f5() {
+;   f1();
+; }
+; void f6() {
+;   F4::f5();
+; }
+
+; Show that the only linkage names are for the inlined functions,
+; because those are the ones with an abstract origin.
+; ONENAME-NOT: {{DW_AT(_MIPS)?_linkage_name}}
+; ONENAME:     {{DW_AT(_MIPS)?_linkage_name}} {{.*}} "_Z2f2v"
+; ONENAME-NOT: {{DW_AT(_MIPS)?_linkage_name}}
+; ONENAME:     {{DW_AT(_MIPS)?_linkage_name}} {{.*}} "_ZN2F42f5Ev"
+; ONENAME-NOT: {{DW_AT(_MIPS)?_linkage_name}}
+
+; For f2() we see the definition pointing to an abstract origin DIE,
+; which in turn is where the linkage_name is; and then there's
+; an inlined_subroutine pointing back to the abstract origin.
+; The order of these DIEs is not important of course, just the links.
+; REF:      DW_TAG_subprogram
+; REF-NOT:  {{DW_TAG|NULL}}
+; REF:      DW_AT_abstract_origin {{.*}} {[[F2:0x.*]]} "_Z2f2v"
+; REF:      [[F2]]: DW_TAG_subprogram
+; REF-NEXT: linkage_name {{.*}} "_Z2f2v"
+; REF:      DW_TAG_inlined_subroutine
+; REF-NOT:  {{DW_TAG|NULL}}
+; REF:      DW_AT_abstract_origin {{.*}} {[[F2]]}
+
+; For F4::f5(), first we see the in-class declaration,
+; then the definition, abstract origin, and the inlined_subroutine.
+; REF:      DW_TAG_structure_type
+; REF-NEXT: DW_AT_name {{.*}} "F4"
+; REF-NOT:  {{DW_TAG|NULL}}
+; REF:      [[F5_DECL:0x.*]]: DW_TAG_subprogram
+; REF-NEXT: DW_AT_name {{.*}} "f5"
+; REF:      DW_TAG_subprogram
+; REF-NOT:  {{DW_TAG|NULL}}
+; REF:      DW_AT_abstract_origin {{.*}} {[[F5_ABS:0x.*]]} "_ZN2F42f5Ev"
+; REF:      [[F5_ABS]]: DW_TAG_subprogram
+; REF-NOT:  {{DW_TAG|NULL}}
+; REF:      linkage_name {{.*}} "_ZN2F42f5Ev"
+; REF-NEXT: DW_AT_specification {{.*}} {[[F5_DECL]]}
+; REF:      DW_TAG_inlined_subroutine
+; REF-NOT:  {{DW_TAG|NULL}}
+; REF:      DW_AT_abstract_origin {{.*}} {[[F5_ABS]]}
+
+
+; Function Attrs: alwaysinline uwtable
+define void @_Z2f2v() #0 !dbg !6 {
+entry:
+  call void @_Z2f1v(), !dbg !9
+  ret void, !dbg !10
+}
+
+declare void @_Z2f1v()
+
+; Function Attrs: uwtable
+define void @_Z2f3v() !dbg !11 {
+entry:
+  call void @_Z2f1v(), !dbg !12
+  ret void, !dbg !14
+}
+
+; Function Attrs: alwaysinline uwtable
+define void @_ZN2F42f5Ev() #0 align 2 !dbg !15 {
+entry:
+  call void @_Z2f1v(), !dbg !19
+  ret void, !dbg !20
+}
+
+; Function Attrs: uwtable
+define void @_Z2f6v() !dbg !21 {
+entry:
+  call void @_Z2f1v(), !dbg !22
+  ret void, !dbg !24
+}
+
+attributes #0 = { alwaysinline }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+!llvm.ident = !{!5}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 4.0.0 (trunk 288231)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "linkage-name-abstract-static.cpp", directory: "/home/probinson/projects/scratch")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{!"clang version 4.0.0 (trunk 288231)"}
+!6 = distinct !DISubprogram(name: "f2", linkageName: "_Z2f2v", scope: !1, file: !1, line: 2, type: !7, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!7 = !DISubroutineType(types: !8)
+!8 = !{null}
+!9 = !DILocation(line: 3, column: 3, scope: !6)
+!10 = !DILocation(line: 4, column: 1, scope: !6)
+!11 = distinct !DISubprogram(name: "f3", linkageName: "_Z2f3v", scope: !1, file: !1, line: 5, type: !7, isLocal: false, isDefinition: true, scopeLine: 5, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!12 = !DILocation(line: 3, column: 3, scope: !6, inlinedAt: !13)
+!13 = distinct !DILocation(line: 6, column: 3, scope: !11)
+!14 = !DILocation(line: 7, column: 1, scope: !11)
+!15 = distinct !DISubprogram(name: "f5", linkageName: "_ZN2F42f5Ev", scope: !16, file: !1, line: 12, type: !7, isLocal: false, isDefinition: true, scopeLine: 12, flags: DIFlagPrototyped, isOptimized: false, unit: !0, declaration: !18, retainedNodes: !2)
+!16 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "F4", file: !1, line: 9, size: 8, elements: !17, identifier: "_ZTS2F4")
+!17 = !{!18}
+!18 = !DISubprogram(name: "f5", linkageName: "_ZN2F42f5Ev", scope: !16, file: !1, line: 10, type: !7, isLocal: false, isDefinition: false, scopeLine: 10, flags: DIFlagPrototyped, isOptimized: false)
+!19 = !DILocation(line: 13, column: 3, scope: !15)
+!20 = !DILocation(line: 14, column: 1, scope: !15)
+!21 = distinct !DISubprogram(name: "f6", linkageName: "_Z2f6v", scope: !1, file: !1, line: 15, type: !7, isLocal: false, isDefinition: true, scopeLine: 15, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!22 = !DILocation(line: 13, column: 3, scope: !15, inlinedAt: !23)
+!23 = distinct !DILocation(line: 16, column: 3, scope: !21)
+!24 = !DILocation(line: 17, column: 1, scope: !21)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/member-order.ll b/test/DebugInfo/Generic/member-order.ll
new file mode 100644
index 0000000..9a8dc7c
--- /dev/null
+++ b/test/DebugInfo/Generic/member-order.ll
@@ -0,0 +1,71 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj -O0 < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck %s
+
+; generated by clang from:
+; struct foo {
+;   void f1();
+;   void f2();
+; };
+;
+; void foo::f1() {
+; }
+
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_name {{.*}} "foo"
+; CHECK-NOT: NULL
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: NULL
+; CHECK: DW_AT_name {{.*}} "f1"
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: NULL
+; CHECK: DW_AT_name {{.*}} "f2"
+
+
+%struct.foo = type { i8 }
+
+; Function Attrs: nounwind uwtable
+define void @_ZN3foo2f1Ev(%struct.foo* %this) #0 align 2 !dbg !14 {
+entry:
+  %this.addr = alloca %struct.foo*, align 8
+  store %struct.foo* %this, %struct.foo** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.foo** %this.addr, metadata !16, metadata !DIExpression()), !dbg !18
+  %this1 = load %struct.foo*, %struct.foo** %this.addr
+  ret void, !dbg !19
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!15, !20}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.4 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !3, globals: !2, imports: !2)
+!1 = !DIFile(filename: "member-order.cpp", directory: "/tmp/dbginfo")
+!2 = !{}
+!3 = !{!4}
+!4 = !DICompositeType(tag: DW_TAG_structure_type, name: "foo", line: 1, size: 8, align: 8, file: !1, elements: !5, identifier: "_ZTS3foo")
+!5 = !{!6, !11}
+!6 = !DISubprogram(name: "f1", linkageName: "_ZN3foo2f1Ev", line: 2, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, scopeLine: 2, file: !1, scope: !4, type: !7)
+!7 = !DISubroutineType(types: !8)
+!8 = !{null, !9}
+!9 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer, baseType: !4)
+!10 = !{i32 786468}
+!11 = !DISubprogram(name: "f2", linkageName: "_ZN3foo2f2Ev", line: 3, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, scopeLine: 3, file: !1, scope: !4, type: !7)
+!12 = !{i32 786468}
+!14 = distinct !DISubprogram(name: "f1", linkageName: "_ZN3foo2f1Ev", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 6, file: !1, scope: null, type: !7, declaration: !6, retainedNodes: !2)
+!15 = !{i32 2, !"Dwarf Version", i32 4}
+!16 = !DILocalVariable(name: "this", arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !14, type: !17)
+!17 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !4)
+!18 = !DILocation(line: 0, scope: !14)
+!19 = !DILocation(line: 7, scope: !14)
+!20 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/missing-abstract-variable.ll b/test/DebugInfo/Generic/missing-abstract-variable.ll
new file mode 100644
index 0000000..8936691
--- /dev/null
+++ b/test/DebugInfo/Generic/missing-abstract-variable.ll
@@ -0,0 +1,182 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck %s
+
+; Build from the following source with clang -O2.
+
+; The important details are that 'x's abstract definition is first built during
+; the definition of 'b', where the parameter to 'x' is constant and so 'x's 's'
+; variable is optimized away. No abstract definition DIE for 's' is constructed.
+; Then, during 'a' emission, the abstract DbgVariable for 's' is created, but
+; the abstract DIE isn't (since the abstract definition for 'b' is already
+; built). This results in 's' inlined in 'a' being emitted with its name, line,
+; file there, rather than referencing an abstract definition.
+
+; extern int t;
+;
+; void f(int);
+;
+; inline void x(bool b) {
+;   if (b) {
+;     int s = t;
+;     f(s);
+;   }
+;   f(0);
+; }
+;
+; void b() {
+;   x(false);
+; }
+;
+; void a(bool u) {
+;   x(u);
+; }
+
+; CHECK: [[X_DECL:.*]]: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_name {{.*}} "x"
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_name {{.*}} "b"
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:       DW_TAG_lexical_block
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_TAG_variable
+; CHECK-NOT: DW_TAG
+; CHECK:         DW_AT_name {{.*}} "s"
+
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_name {{.*}} "b"
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_TAG_inlined_subroutine
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_abstract_origin {{.*}} {[[X_DECL]]}
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:     DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK:       DW_AT_abstract_origin {{.*}} "b"
+; Notice 'x's local variable 's' is missing. Not necessarily a bug here,
+; since it's been optimized entirely away and it should be described in
+; abstract subprogram.
+; CHECK-NOT: DW_TAG
+; CHECK: NULL
+; CHECK-NOT: DW_TAG
+; CHECK: NULL
+
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_name {{.*}} "a"
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_TAG_formal_parameter
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:   DW_TAG_inlined_subroutine
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_abstract_origin {{.*}} {[[X_DECL]]}
+; CHECK-NOT: {{DW_TAG|NULL}}
+; FIXME: This formal parameter goes missing at least at -O2 (& on
+; mips/powerpc), maybe before that. Perhaps SelectionDAG is to blame (and
+; fastisel succeeds).
+; CHECK:     DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK:       DW_AT_abstract_origin {{.*}} "b"
+
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:     DW_TAG_lexical_block
+; CHECK-NOT: {{DW_TAG|NULL}}
+; CHECK:       DW_TAG_variable
+; CHECK-NOT: DW_TAG
+; CHECK:         DW_AT_abstract_origin {{.*}} "s"
+
+@t = external global i32
+
+; Function Attrs: uwtable
+define void @_Z1bv() #0 !dbg !4 {
+entry:
+  tail call void @llvm.dbg.value(metadata i1 false, metadata !25, metadata !DIExpression()), !dbg !27
+  tail call void @_Z1fi(i32 0), !dbg !28
+  ret void, !dbg !29
+}
+
+; Function Attrs: uwtable
+define void @_Z1ab(i1 zeroext %u) #0 !dbg !8 {
+entry:
+  tail call void @llvm.dbg.value(metadata i1 %u, metadata !13, metadata !DIExpression()), !dbg !30
+  tail call void @llvm.dbg.value(metadata i1 %u, metadata !31, metadata !DIExpression()), !dbg !33
+  br i1 %u, label %if.then.i, label %_Z1xb.exit, !dbg !34
+
+if.then.i:                                        ; preds = %entry
+  %0 = load i32, i32* @t, align 4, !dbg !35, !tbaa !36
+  tail call void @llvm.dbg.value(metadata i32 %0, metadata !40, metadata !DIExpression()), !dbg !35
+  tail call void @_Z1fi(i32 %0), !dbg !41
+  br label %_Z1xb.exit, !dbg !42
+
+_Z1xb.exit:                                       ; preds = %entry, %if.then.i
+  tail call void @_Z1fi(i32 0), !dbg !43
+  ret void, !dbg !44
+}
+
+declare void @_Z1fi(i32) #1
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #2
+
+attributes #0 = { uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #2 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!21, !22}
+!llvm.ident = !{!23}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: true, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "missing-abstract-variables.cc", directory: "/tmp/dbginfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "b", linkageName: "_Z1bv", line: 13, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 13, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "missing-abstract-variables.cc", directory: "/tmp/dbginfo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{null}
+!8 = distinct !DISubprogram(name: "a", linkageName: "_Z1ab", line: 17, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 17, file: !1, scope: !5, type: !9, retainedNodes: !12)
+!9 = !DISubroutineType(types: !10)
+!10 = !{null, !11}
+!11 = !DIBasicType(tag: DW_TAG_base_type, name: "bool", size: 8, align: 8, encoding: DW_ATE_boolean)
+!12 = !{!13}
+!13 = !DILocalVariable(name: "u", line: 17, arg: 1, scope: !8, file: !5, type: !11)
+!14 = distinct !DISubprogram(name: "x", linkageName: "_Z1xb", line: 5, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 5, file: !1, scope: !5, type: !9, retainedNodes: !15)
+!15 = !{!16, !17}
+!16 = !DILocalVariable(name: "b", line: 5, arg: 1, scope: !14, file: !5, type: !11)
+!17 = !DILocalVariable(name: "s", line: 7, scope: !18, file: !5, type: !20)
+!18 = distinct !DILexicalBlock(line: 6, column: 0, file: !1, scope: !19)
+!19 = distinct !DILexicalBlock(line: 6, column: 0, file: !1, scope: !14)
+!20 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!21 = !{i32 2, !"Dwarf Version", i32 4}
+!22 = !{i32 2, !"Debug Info Version", i32 3}
+!23 = !{!"clang version 3.5.0 "}
+!24 = !{i1 false}
+!25 = !DILocalVariable(name: "b", line: 5, arg: 1, scope: !14, file: !5, type: !11)
+!26 = !DILocation(line: 14, scope: !4)
+!27 = !DILocation(line: 5, scope: !14, inlinedAt: !26)
+!28 = !DILocation(line: 10, scope: !14, inlinedAt: !26)
+!29 = !DILocation(line: 15, scope: !4)
+!30 = !DILocation(line: 17, scope: !8)
+!31 = !DILocalVariable(name: "b", line: 5, arg: 1, scope: !14, file: !5, type: !11)
+!32 = !DILocation(line: 18, scope: !8)
+!33 = !DILocation(line: 5, scope: !14, inlinedAt: !32)
+!34 = !DILocation(line: 6, scope: !19, inlinedAt: !32)
+!35 = !DILocation(line: 7, scope: !18, inlinedAt: !32)
+!36 = !{!37, !37, i64 0}
+!37 = !{!"int", !38, i64 0}
+!38 = !{!"omnipotent char", !39, i64 0}
+!39 = !{!"Simple C/C++ TBAA"}
+!40 = !DILocalVariable(name: "s", line: 7, scope: !18, file: !5, type: !20)
+!41 = !DILocation(line: 8, scope: !18, inlinedAt: !32)
+!42 = !DILocation(line: 9, scope: !18, inlinedAt: !32)
+!43 = !DILocation(line: 10, scope: !14, inlinedAt: !32)
+!44 = !DILocation(line: 19, scope: !8)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/multiline.ll b/test/DebugInfo/Generic/multiline.ll
new file mode 100644
index 0000000..3d0eda8
--- /dev/null
+++ b/test/DebugInfo/Generic/multiline.ll
@@ -0,0 +1,86 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=asm -asm-verbose=0 -O0 < %t.ll | FileCheck %s
+; RUN: llc -mtriple=%triple -filetype=obj -O0 < %t.ll | llvm-dwarfdump -debug-line - | FileCheck %s --check-prefix=INT
+
+; Check that the assembly output properly handles is_stmt changes. And since
+; we're testing anyway, check the integrated assembler too.
+
+; Generated with clang from multiline.c:
+; void f1();
+; void f2() {
+;   f1(); f1(); f1();
+;   f1(); f1(); f1();
+; }
+
+
+; CHECK: .loc	1 2 0{{$}}
+; CHECK-NOT: .loc{{ }}
+; CHECK: .loc	1 3 3 prologue_end{{$}}
+; CHECK-NOT: .loc
+; CHECK: .loc	1 3 9 is_stmt 0{{$}}
+; CHECK-NOT: .loc
+; CHECK: .loc	1 3 15{{$}}
+; CHECK-NOT: .loc
+; CHECK: .loc	1 4 3 is_stmt 1{{$}}
+; CHECK-NOT: .loc
+; CHECK: .loc	1 4 9 is_stmt 0{{$}}
+; CHECK-NOT: .loc
+; CHECK: .loc	1 4 15{{$}}
+; CHECK-NOT: .loc
+; CHECK: .loc	1 5 1 is_stmt 1{{$}}
+
+; INT: {{^}}Address
+; INT: -----
+; INT-NEXT: 2 0 1 0 0 is_stmt{{$}}
+; INT-NEXT: 3 3 1 0 0 is_stmt prologue_end{{$}}
+; INT-NEXT: 3 9 1 0 0 {{$}}
+; INT-NEXT: 3 15 1 0 0 {{$}}
+; INT-NEXT: 4 3 1 0 0 is_stmt{{$}}
+; INT-NEXT: 4 9 1 0 0 {{$}}
+; INT-NEXT: 4 15 1 0 0 {{$}}
+; INT-NEXT: 5 1 1 0 0 is_stmt{{$}}
+
+
+; Function Attrs: nounwind uwtable
+define void @f2() #0 !dbg !4 {
+entry:
+  call void (...) @f1(), !dbg !11
+  call void (...) @f1(), !dbg !12
+  call void (...) @f1(), !dbg !13
+  call void (...) @f1(), !dbg !14
+  call void (...) @f1(), !dbg !15
+  call void (...) @f1(), !dbg !16
+  ret void, !dbg !17
+}
+
+declare void @f1(...) #1
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!8, !9}
+!llvm.ident = !{!10}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.6.0 (trunk 225000) (llvm/trunk 224999)", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "multiline.c", directory: "/tmp/dbginfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "f2", line: 2, isLocal: false, isDefinition: true, isOptimized: false, unit: !0, scopeLine: 2, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "multiline.c", directory: "/tmp/dbginfo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{null}
+!8 = !{i32 2, !"Dwarf Version", i32 4}
+!9 = !{i32 2, !"Debug Info Version", i32 3}
+!10 = !{!"clang version 3.6.0 (trunk 225000) (llvm/trunk 224999)"}
+!11 = !DILocation(line: 3, column: 3, scope: !4)
+!12 = !DILocation(line: 3, column: 9, scope: !4)
+!13 = !DILocation(line: 3, column: 15, scope: !4)
+!14 = !DILocation(line: 4, column: 3, scope: !4)
+!15 = !DILocation(line: 4, column: 9, scope: !4)
+!16 = !DILocation(line: 4, column: 15, scope: !4)
+!17 = !DILocation(line: 5, column: 1, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/namespace_function_definition.ll b/test/DebugInfo/Generic/namespace_function_definition.ll
new file mode 100644
index 0000000..1eaf1c6
--- /dev/null
+++ b/test/DebugInfo/Generic/namespace_function_definition.ll
@@ -0,0 +1,49 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj -dwarf-linkage-names=All < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck %s
+
+; Generated from clang with the following source:
+; namespace ns {
+; void func() {
+; }
+; }
+
+; CHECK: DW_TAG_namespace
+; CHECK-NEXT: DW_AT_name {{.*}} "ns"
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_low_pc
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_linkage_name {{.*}} "_ZN2ns4funcEv"
+; CHECK: NULL
+; CHECK: NULL
+
+; Function Attrs: nounwind uwtable
+define void @_ZN2ns4funcEv() #0 !dbg !4 {
+entry:
+  ret void, !dbg !11
+}
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!8, !9}
+!llvm.ident = !{!10}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "namespace_function_definition.cpp", directory: "/tmp/dbginfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "func", linkageName: "_ZN2ns4funcEv", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 2, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DINamespace(name: "ns", scope: null)
+!6 = !DISubroutineType(types: !7)
+!7 = !{null}
+!8 = !{i32 2, !"Dwarf Version", i32 4}
+!9 = !{i32 1, !"Debug Info Version", i32 3}
+!10 = !{!"clang version 3.5.0 "}
+!11 = !DILocation(line: 3, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/namespace_inline_function_definition.ll b/test/DebugInfo/Generic/namespace_inline_function_definition.ll
new file mode 100644
index 0000000..3ac3726
--- /dev/null
+++ b/test/DebugInfo/Generic/namespace_inline_function_definition.ll
@@ -0,0 +1,100 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj -dwarf-linkage-names=All < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck %s
+
+; Generate from clang with the following source. Note that the definition of
+; the inline function follows its use to workaround another bug that should be
+; fixed soon.
+; namespace ns {
+; int func(int i);
+; }
+; extern int x;
+; int main() { return ns::func(x); }
+; int __attribute__((always_inline)) ns::func(int i) { return i * 2; }
+
+; CHECK: DW_TAG_namespace
+; CHECK-NEXT: DW_AT_name {{.*}} "ns"
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_AT_linkage_name {{.*}} "_ZN2ns4funcEi"
+; CHECK-NOT: DW_TAG
+; CHECK:   DW_TAG_formal_parameter
+; CHECK:   NULL
+; CHECK-NOT: NULL
+; CHECK:   DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_abstract_origin {{.*}} "_ZN2ns4funcEi"
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_TAG_formal_parameter
+; CHECK:       DW_AT_abstract_origin {{.*}} "i"
+; CHECK:     NULL
+; CHECK:   NULL
+; CHECK: NULL
+
+@x = external global i32
+
+; Function Attrs: uwtable
+define i32 @main() #0 !dbg !4 {
+entry:
+  %i.addr.i = alloca i32, align 4
+  %retval = alloca i32, align 4
+  store i32 0, i32* %retval
+  %0 = load i32, i32* @x, align 4, !dbg !16
+  store i32 %0, i32* %i.addr.i, align 4
+  call void @llvm.dbg.declare(metadata i32* %i.addr.i, metadata !117, metadata !DIExpression()), !dbg !18
+  %1 = load i32, i32* %i.addr.i, align 4, !dbg !18
+  %mul.i = mul nsw i32 %1, 2, !dbg !18
+  ret i32 %mul.i, !dbg !16
+}
+
+; Function Attrs: alwaysinline nounwind uwtable
+define i32 @_ZN2ns4funcEi(i32 %i) #1 !dbg !9 {
+entry:
+  %i.addr = alloca i32, align 4
+  store i32 %i, i32* %i.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %i.addr, metadata !17, metadata !DIExpression()), !dbg !19
+  %0 = load i32, i32* %i.addr, align 4, !dbg !19
+  %mul = mul nsw i32 %0, 2, !dbg !19
+  ret i32 %mul, !dbg !19
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #2
+
+attributes #0 = { uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { alwaysinline nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #2 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!13, !14}
+!llvm.ident = !{!15}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "namespace_inline_function_definition.cpp", directory: "/tmp/dbginfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "main", line: 5, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 5, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "namespace_inline_function_definition.cpp", directory: "/tmp/dbginfo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = distinct !DISubprogram(name: "func", linkageName: "_ZN2ns4funcEi", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 6, file: !1, scope: !10, type: !11, retainedNodes: !2)
+!10 = !DINamespace(name: "ns", scope: null)
+!11 = !DISubroutineType(types: !12)
+!12 = !{!8, !8}
+!13 = !{i32 2, !"Dwarf Version", i32 4}
+!14 = !{i32 2, !"Debug Info Version", i32 3}
+!15 = !{!"clang version 3.5.0 "}
+!16 = !DILocation(line: 5, scope: !4)
+!17 = !DILocalVariable(name: "i", line: 6, arg: 1, scope: !9, file: !5, type: !8)
+
+!117 = !DILocalVariable(name: "i", line: 6, arg: 1, scope: !9, file: !5, type: !8)
+
+!18 = !DILocation(line: 6, scope: !9, inlinedAt: !16)
+!19 = !DILocation(line: 6, scope: !9)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/noscopes.ll b/test/DebugInfo/Generic/noscopes.ll
new file mode 100644
index 0000000..505ab86
--- /dev/null
+++ b/test/DebugInfo/Generic/noscopes.ll
@@ -0,0 +1,39 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll | llvm-dwarfdump - | FileCheck %s
+
+; Just because there are no scopes/locations on any instructions in the
+; function doesn't mean we can't describe the address range of the function.
+; Check that we do that
+
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: TAG
+; CHECK:   DW_AT_low_pc
+
+; Function Attrs: nounwind uwtable
+define void @f() #0 !dbg !6 {
+entry:
+  ret void
+}
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+!llvm.ident = !{!5}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 4.0.0 (trunk 289692) (llvm/trunk 289697)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "noscopes.c", directory: "/tmp/dbginfo")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{!"clang version 4.0.0 (trunk 289692) (llvm/trunk 289697)"}
+!6 = distinct !DISubprogram(name: "f", scope: !1, file: !1, line: 1, type: !7, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: false, unit: !0, retainedNodes: !2)
+!7 = !DISubroutineType(types: !8)
+!8 = !{null}
+!9 = !DILocation(line: 2, column: 1, scope: !6)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/ptrsize.ll b/test/DebugInfo/Generic/ptrsize.ll
new file mode 100755
index 0000000..0d930b2
--- /dev/null
+++ b/test/DebugInfo/Generic/ptrsize.ll
@@ -0,0 +1,52 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll > %t
+; RUN: llvm-dwarfdump -v %t | FileCheck %s
+
+; Check that pointers and references get emitted without size information in
+; DWARF, even if they are so specified in the IR
+
+; CHECK: 0x[[O1:[0-9a-f]+]]:   DW_TAG_pointer_type
+; CHECK-NEXT: DW_AT_type [DW_FORM_ref4]
+; CHECK-NOT: DW_AT_byte_size
+; CHECK: 0x[[O2:[0-9a-f]+]]:   DW_TAG_
+
+; CHECK: 0x[[O3:[0-9a-f]+]]:   DW_TAG_reference_type
+; CHECK-NEXT: DW_AT_type [DW_FORM_ref4]
+; CHECK-NOT: DW_AT_byte_size
+
+define i32 @foo() !dbg !4 {
+entry:
+  ret i32 0, !dbg !13
+}
+
+define i32 @bar() !dbg !5 {
+entry:
+  ret i32 0, !dbg !16
+}
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!11, !12}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "dwarf-test.c", directory: "test")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "foo", scope: !0, file: !1, line: 6, type: !6, isLocal: false, isDefinition: true, scopeLine: 6, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!5 = distinct !DISubprogram(name: "bar", scope: !0, file: !1, line: 6, type: !15, isLocal: false, isDefinition: true, scopeLine: 6, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!6 = !DISubroutineType(types: !7)
+!7 = !{!9}
+!8 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = !DIDerivedType(tag: DW_TAG_pointer_type, scope: !0, baseType: !8, size: 64, align: 64)
+!10 = !DIDerivedType(tag: DW_TAG_reference_type, scope: !0, baseType: !8, size: 64, align: 64)
+!11 = !{i32 2, !"Dwarf Version", i32 3}
+!12 = !{i32 1, !"Debug Info Version", i32 3}
+!13 = !DILocation(line: 7, scope: !4)
+!14 = !{!10}
+!15 = !DISubroutineType(types: !14)
+!16 = !DILocation(line: 7, scope: !5)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/restrict.ll b/test/DebugInfo/Generic/restrict.ll
new file mode 100644
index 0000000..0d4a895
--- /dev/null
+++ b/test/DebugInfo/Generic/restrict.ll
@@ -0,0 +1,58 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -dwarf-version=2 -O0 -filetype=obj < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck --check-prefix=CHECK --check-prefix=V2 %s
+; RUN: llc -mtriple=%triple -dwarf-version=3 -O0 -filetype=obj < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck --check-prefix=CHECK --check-prefix=V3 %s
+
+; CHECK: DW_AT_name {{.*}} "dst"
+; V2: DW_AT_type {{.*}} {[[PTR:0x.*]]}
+; V3: DW_AT_type {{.*}} {[[RESTRICT:0x.*]]}
+; V3: [[RESTRICT]]: {{.*}}DW_TAG_restrict_type
+; V3-NEXT: DW_AT_type {{.*}} {[[PTR:0x.*]]}
+; CHECK: [[PTR]]: {{.*}}DW_TAG_pointer_type
+; CHECK-NOT: DW_AT_type
+
+; Generated with clang from:
+; void foo(void* __restrict__ dst) {
+; }
+
+
+; Function Attrs: nounwind uwtable
+define void @_Z3fooPv(i8* noalias %dst) #0 !dbg !4 {
+entry:
+  %dst.addr = alloca i8*, align 8
+  store i8* %dst, i8** %dst.addr, align 8
+  call void @llvm.dbg.declare(metadata i8** %dst.addr, metadata !13, metadata !DIExpression()), !dbg !14
+  ret void, !dbg !15
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!10, !11}
+!llvm.ident = !{!12}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "restrict.c", directory: "/tmp/dbginfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "foo", linkageName: "_Z3fooPv", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 1, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "restrict.c", directory: "/tmp/dbginfo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{null, !8}
+!8 = !DIDerivedType(tag: DW_TAG_restrict_type, baseType: !9)
+!9 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: null)
+!10 = !{i32 2, !"Dwarf Version", i32 4}
+!11 = !{i32 1, !"Debug Info Version", i32 3}
+!12 = !{!"clang version 3.5.0 "}
+!13 = !DILocalVariable(name: "dst", line: 1, arg: 1, scope: !4, file: !5, type: !8)
+!14 = !DILocation(line: 1, scope: !4)
+!15 = !DILocation(line: 2, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/template-recursive-void.ll b/test/DebugInfo/Generic/template-recursive-void.ll
new file mode 100644
index 0000000..0282402
--- /dev/null
+++ b/test/DebugInfo/Generic/template-recursive-void.ll
@@ -0,0 +1,70 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll > %t
+; RUN: llvm-dwarfdump -v %t | FileCheck %s
+
+; This was pulled from clang's debug-info-template-recursive.cpp test.
+; class base { };
+
+; template <class T> class foo : public base  {
+;   void operator=(const foo r) { }
+; };
+
+; class bar : public foo<void> { };
+; bar filters;
+
+; CHECK: DW_TAG_template_type_parameter [{{.*}}]
+; CHECK-NEXT: DW_AT_name{{.*}}"T"
+; CHECK-NOT: DW_AT_type
+; CHECK: NULL
+
+source_filename = "test/DebugInfo/Generic/template-recursive-void.ll"
+
+%class.bar = type { i8 }
+
+@filters = global %class.bar zeroinitializer, align 1, !dbg !0
+
+!llvm.dbg.cu = !{!29}
+!llvm.module.flags = !{!32, !33}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "filters", scope: null, file: !2, line: 10, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "debug-info-template-recursive.cpp", directory: "/usr/local/google/home/echristo/tmp")
+!3 = !DICompositeType(tag: DW_TAG_class_type, name: "bar", file: !2, line: 9, size: 8, align: 8, elements: !4)
+!4 = !{!5, !25}
+!5 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !3, baseType: !6)
+!6 = !DICompositeType(tag: DW_TAG_class_type, name: "foo<void>", file: !2, line: 5, size: 8, align: 8, elements: !7, templateParams: !23)
+!7 = !{!8, !15, !20}
+!8 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !6, baseType: !9)
+!9 = !DICompositeType(tag: DW_TAG_class_type, name: "base", file: !2, line: 3, size: 8, align: 8, elements: !10)
+!10 = !{!11}
+!11 = !DISubprogram(name: "base", scope: !9, file: !2, line: 3, type: !12, isLocal: false, isDefinition: false, scopeLine: 3, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false)
+!12 = !DISubroutineType(types: !13)
+!13 = !{null, !14}
+!14 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !9, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!15 = !DISubprogram(name: "operator=", linkageName: "_ZN3fooIvEaSES0_", scope: !6, file: !2, line: 6, type: !16, isLocal: false, isDefinition: false, scopeLine: 6, virtualIndex: 6, flags: DIFlagPrivate | DIFlagPrototyped, isOptimized: false)
+!16 = !DISubroutineType(types: !17)
+!17 = !{null, !18, !19}
+!18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !6, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!19 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !6)
+!20 = !DISubprogram(name: "foo", scope: !6, file: !2, line: 5, type: !21, isLocal: false, isDefinition: false, scopeLine: 5, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false)
+!21 = !DISubroutineType(types: !22)
+!22 = !{null, !18}
+!23 = !{!24}
+!24 = !DITemplateTypeParameter(name: "T", type: null)
+!25 = !DISubprogram(name: "bar", scope: !3, file: !2, line: 9, type: !26, isLocal: false, isDefinition: false, scopeLine: 9, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false)
+!26 = !DISubroutineType(types: !27)
+!27 = !{null, !28}
+!28 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !3, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!29 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.4 (trunk 187958) (llvm/trunk 187964)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !30, retainedTypes: !30, globals: !31, imports: !30)
+!30 = !{}
+!31 = !{!0}
+!32 = !{i32 2, !"Dwarf Version", i32 3}
+!33 = !{i32 1, !"Debug Info Version", i32 3}
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/tu-member-pointer.ll b/test/DebugInfo/Generic/tu-member-pointer.ll
new file mode 100644
index 0000000..5dea4a6
--- /dev/null
+++ b/test/DebugInfo/Generic/tu-member-pointer.ll
@@ -0,0 +1,39 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj -O0 < %t.ll > %t
+; RUN: llvm-dwarfdump -v -debug-info %t | FileCheck %s
+; CHECK: DW_TAG_ptr_to_member_type
+; CHECK-NEXT: DW_AT_type [DW_FORM_ref4]       (cu + {{.*}} => {[[TYPE:0x[0-9a-f]+]]}
+; CHECK: [[TYPE]]:   DW_TAG_base_type
+; IR generated from clang -g with the following source:
+; struct Foo {
+;   int e;
+; };
+; int Foo:*x = 0;
+
+source_filename = "test/DebugInfo/Generic/tu-member-pointer.ll"
+
+@x = global i64 -1, align 8, !dbg !0
+
+!llvm.dbg.cu = !{!6}
+!llvm.module.flags = !{!10, !11}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "x", scope: null, file: !2, line: 4, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "foo.cpp", directory: ".")
+!3 = !DIDerivedType(tag: DW_TAG_ptr_to_member_type, baseType: !4, extraData: !5)
+!4 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!5 = !DICompositeType(tag: DW_TAG_structure_type, name: "Foo", file: !2, line: 1, flags: DIFlagFwdDecl, identifier: "_ZTS3Foo")
+!6 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.4", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !7, retainedTypes: !8, globals: !9, imports: !7)
+!7 = !{}
+!8 = !{!5}
+!9 = !{!0}
+!10 = !{i32 2, !"Dwarf Version", i32 2}
+!11 = !{i32 1, !"Debug Info Version", i32 3}
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/two-cus-from-same-file.ll b/test/DebugInfo/Generic/two-cus-from-same-file.ll
new file mode 100644
index 0000000..fcc5e4d
--- /dev/null
+++ b/test/DebugInfo/Generic/two-cus-from-same-file.ll
@@ -0,0 +1,76 @@
+; For http://llvm.org/bugs/show_bug.cgi?id=12942
+;   There are two CUs coming from /tmp/foo.c in this module. Make sure it doesn't
+;   blow llc up and produces something reasonable.
+;
+
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple %t.ll -o %t -filetype=obj -O0
+; RUN: llvm-dwarfdump -debug-info %t | FileCheck %s
+
+; ModuleID = 'test.bc'
+
+@str = private unnamed_addr constant [4 x i8] c"FOO\00"
+@str1 = private unnamed_addr constant [6 x i8] c"Main!\00"
+
+define void @foo() nounwind !dbg !5 {
+entry:
+  %puts = tail call i32 @puts(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str, i32 0, i32 0)), !dbg !23
+  ret void, !dbg !25
+}
+
+declare i32 @puts(i8* nocapture) nounwind
+
+define i32 @main(i32 %argc, i8** nocapture %argv) nounwind !dbg !12 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 %argc, metadata !21, metadata !DIExpression()), !dbg !26
+  ; Avoid talking about the pointer size in debug info because that's target dependent
+  tail call void @llvm.dbg.value(metadata i8** %argv, metadata !22, metadata !DIExpression(DW_OP_deref, DW_OP_deref)), !dbg !27
+  %puts = tail call i32 @puts(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str1, i32 0, i32 0)), !dbg !28
+  tail call void @foo() nounwind, !dbg !30
+  ret i32 0, !dbg !31
+}
+
+declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!0, !9}
+!llvm.module.flags = !{!33}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.2 (trunk 156513)", isOptimized: true, emissionKind: FullDebug, file: !32, enums: !1, retainedTypes: !1, globals: !1, imports: !1)
+!1 = !{}
+!5 = distinct !DISubprogram(name: "foo", line: 5, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 5, file: !32, scope: !6, type: !7, retainedNodes: !1)
+!6 = !DIFile(filename: "foo.c", directory: "/tmp")
+!7 = !DISubroutineType(types: !8)
+!8 = !{null}
+!9 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.2 (trunk 156513)", isOptimized: true, emissionKind: FullDebug, file: !32, enums: !1, retainedTypes: !1, globals: !1, imports: !1)
+!12 = distinct !DISubprogram(name: "main", line: 11, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !9, scopeLine: 11, file: !32, scope: !6, type: !13, retainedNodes: !19)
+!13 = !DISubroutineType(types: !14)
+!14 = !{!15, !15, !18}
+!15 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!18 = !DIBasicType(tag: DW_TAG_base_type, name: "char", size: 8, align: 8, encoding: DW_ATE_signed_char)
+!19 = !{!21, !22}
+!21 = !DILocalVariable(name: "argc", line: 11, arg: 1, scope: !12, file: !6, type: !15)
+!22 = !DILocalVariable(name: "argv", line: 11, arg: 2, scope: !12, file: !6, type: !18)
+!23 = !DILocation(line: 6, column: 3, scope: !24)
+!24 = distinct !DILexicalBlock(line: 5, column: 16, file: !32, scope: !5)
+!25 = !DILocation(line: 7, column: 1, scope: !24)
+!26 = !DILocation(line: 11, column: 14, scope: !12)
+!27 = !DILocation(line: 11, column: 26, scope: !12)
+!28 = !DILocation(line: 12, column: 3, scope: !29)
+!29 = distinct !DILexicalBlock(line: 11, column: 34, file: !32, scope: !12)
+!30 = !DILocation(line: 13, column: 3, scope: !29)
+!31 = !DILocation(line: 14, column: 3, scope: !29)
+!32 = !DIFile(filename: "foo.c", directory: "/tmp")
+
+; This test is simple to be cross platform (many targets don't yet have
+; sufficiently good DWARF emission and/or dumping)
+; CHECK: {{DW_TAG_compile_unit}}
+; CHECK: {{foo\.c}}
+
+!33 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/typedef.ll b/test/DebugInfo/Generic/typedef.ll
new file mode 100644
index 0000000..2601e0f
--- /dev/null
+++ b/test/DebugInfo/Generic/typedef.ll
@@ -0,0 +1,40 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll | llvm-dwarfdump -debug-info - | FileCheck %s
+
+; From source:
+; typedef void x;
+; x *y;
+
+; Check that a typedef with no DW_AT_type is produced. The absence of a type is used to imply the 'void' type.
+
+; CHECK: DW_TAG_typedef
+; CHECK-NOT: DW_AT_type
+; CHECK: {{DW_TAG|NULL}}
+
+source_filename = "test/DebugInfo/Generic/typedef.ll"
+
+@y = global i8* null, align 8, !dbg !0
+
+!llvm.dbg.cu = !{!5}
+!llvm.module.flags = !{!8, !9}
+!llvm.ident = !{!10}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "y", scope: null, file: !2, line: 2, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "typedef.cpp", directory: "/tmp/dbginfo")
+!3 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !4, size: 64, align: 64)
+!4 = !DIDerivedType(tag: DW_TAG_typedef, name: "x", file: !2, line: 1, baseType: null)
+!5 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.5.0 ", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !6, retainedTypes: !6, globals: !7, imports: !6)
+!6 = !{}
+!7 = !{!0}
+!8 = !{i32 2, !"Dwarf Version", i32 4}
+!9 = !{i32 1, !"Debug Info Version", i32 3}
+!10 = !{!"clang version 3.5.0 "}
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/Generic/version.ll b/test/DebugInfo/Generic/version.ll
new file mode 100644
index 0000000..d565f08
--- /dev/null
+++ b/test/DebugInfo/Generic/version.ll
@@ -0,0 +1,37 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -filetype=obj < %t.ll > %t
+; RUN: llvm-dwarfdump %t | FileCheck %s
+
+; Make sure we are generating DWARF version 3 when module flag says so.
+; CHECK: Compile Unit: length = {{.*}} version = 0x0003
+
+define i32 @main() #0 !dbg !4 {
+entry:
+  %retval = alloca i32, align 4
+  store i32 0, i32* %retval
+  ret i32 0, !dbg !10
+}
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!9, !11}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.4 (trunk 185475)", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "CodeGen/dwarf-version.c", directory: "test")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "main", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 6, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "CodeGen/dwarf-version.c", directory: "test")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = !{i32 2, !"Dwarf Version", i32 3}
+!10 = !DILocation(line: 7, scope: !4)
+!11 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/2010-04-13-PubType.ll b/test/DebugInfo/X86/2010-04-13-PubType.ll
new file mode 100644
index 0000000..3593919
--- /dev/null
+++ b/test/DebugInfo/X86/2010-04-13-PubType.ll
@@ -0,0 +1,59 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -O0 -asm-verbose -mtriple=x86_64-macosx -debugger-tune=gdb < %t.ll | FileCheck %s
+; CHECK-NOT: .asciz "X" ## External Name
+; CHECK: .asciz "Y" ## External Name
+; Test to check type with no definition is listed in pubtypes section.
+%struct.X = type opaque
+%struct.Y = type { i32 }
+
+define i32 @foo(%struct.X* %x, %struct.Y* %y) nounwind ssp !dbg !1 {
+entry:
+  %x_addr = alloca %struct.X*                     ; <%struct.X**> [#uses=1]
+  %y_addr = alloca %struct.Y*                     ; <%struct.Y**> [#uses=1]
+  %retval = alloca i32                            ; <i32*> [#uses=2]
+  %0 = alloca i32                                 ; <i32*> [#uses=2]
+  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
+  call void @llvm.dbg.declare(metadata %struct.X** %x_addr, metadata !0, metadata !DIExpression()), !dbg !13
+  store %struct.X* %x, %struct.X** %x_addr
+  call void @llvm.dbg.declare(metadata %struct.Y** %y_addr, metadata !14, metadata !DIExpression()), !dbg !13
+  store %struct.Y* %y, %struct.Y** %y_addr
+  store i32 0, i32* %0, align 4, !dbg !13
+  %1 = load i32, i32* %0, align 4, !dbg !13            ; <i32> [#uses=1]
+  store i32 %1, i32* %retval, align 4, !dbg !13
+  br label %return, !dbg !13
+
+return:                                           ; preds = %entry
+  %retval1 = load i32, i32* %retval, !dbg !13          ; <i32> [#uses=1]
+  ret i32 %retval1, !dbg !15
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!3}
+!llvm.module.flags = !{!20}
+
+!0 = !DILocalVariable(name: "x", line: 7, arg: 1, scope: !1, file: !2, type: !7)
+!1 = distinct !DISubprogram(name: "foo", linkageName: "foo", line: 7, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !3, scopeLine: 7, file: !18, scope: !2, type: !4)
+!2 = !DIFile(filename: "a.c", directory: "/tmp/")
+!3 = distinct !DICompileUnit(language: DW_LANG_C89, producer: "4.2.1 (Based on Apple Inc. build 5658) (LLVM build)", isOptimized: false, emissionKind: FullDebug, file: !18, enums: !19, retainedTypes: !19, imports:  null)
+!4 = !DISubroutineType(types: !5)
+!5 = !{!6, !7, !9}
+!6 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!7 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, file: !18, scope: !2, baseType: !8)
+!8 = !DICompositeType(tag: DW_TAG_structure_type, name: "X", line: 3, flags: DIFlagFwdDecl, file: !18, scope: !2)
+!9 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, file: !18, scope: !2, baseType: !10)
+!10 = !DICompositeType(tag: DW_TAG_structure_type, name: "Y", line: 4, size: 32, align: 32, file: !18, scope: !2, elements: !11)
+!11 = !{!12}
+!12 = !DIDerivedType(tag: DW_TAG_member, name: "x", line: 5, size: 32, align: 32, file: !18, scope: !10, baseType: !6)
+!13 = !DILocation(line: 7, scope: !1)
+!14 = !DILocalVariable(name: "y", line: 7, arg: 2, scope: !1, file: !2, type: !9)
+!15 = !DILocation(line: 7, scope: !16)
+!16 = distinct !DILexicalBlock(line: 7, column: 0, file: !18, scope: !1)
+!18 = !DIFile(filename: "a.c", directory: "/tmp/")
+!19 = !{}
+!20 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/2011-12-16-BadStructRef.ll b/test/DebugInfo/X86/2011-12-16-BadStructRef.ll
new file mode 100644
index 0000000..59becd8
--- /dev/null
+++ b/test/DebugInfo/X86/2011-12-16-BadStructRef.ll
@@ -0,0 +1,171 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-macosx10.7 %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -debug-info %t | FileCheck %s
+
+; CHECK: b_ref
+; CHECK-NOT: AT_bit_size
+
+%struct.bar = type { %struct.baz, %struct.baz* }
+%struct.baz = type { i32 }
+
+define i32 @main(i32 %argc, i8** %argv) uwtable ssp !dbg !29 {
+entry:
+  %retval = alloca i32, align 4
+  %argc.addr = alloca i32, align 4
+  %argv.addr = alloca i8**, align 8
+  %myBar = alloca %struct.bar, align 8
+  store i32 0, i32* %retval
+  store i32 %argc, i32* %argc.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %argc.addr, metadata !49, metadata !DIExpression()), !dbg !50
+  store i8** %argv, i8*** %argv.addr, align 8
+  call void @llvm.dbg.declare(metadata i8*** %argv.addr, metadata !51, metadata !DIExpression()), !dbg !52
+  call void @llvm.dbg.declare(metadata %struct.bar* %myBar, metadata !53, metadata !DIExpression()), !dbg !55
+  call void @_ZN3barC1Ei(%struct.bar* %myBar, i32 1), !dbg !56
+  ret i32 0, !dbg !57
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+define linkonce_odr void @_ZN3barC1Ei(%struct.bar* %this, i32 %x) unnamed_addr uwtable ssp align 2 !dbg !37 {
+entry:
+  %this.addr = alloca %struct.bar*, align 8
+  %x.addr = alloca i32, align 4
+  store %struct.bar* %this, %struct.bar** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.bar** %this.addr, metadata !58, metadata !DIExpression()), !dbg !59
+  store i32 %x, i32* %x.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %x.addr, metadata !60, metadata !DIExpression()), !dbg !61
+  %this1 = load %struct.bar*, %struct.bar** %this.addr
+  %0 = load i32, i32* %x.addr, align 4, !dbg !62
+  call void @_ZN3barC2Ei(%struct.bar* %this1, i32 %0), !dbg !62
+  ret void, !dbg !62
+}
+
+define linkonce_odr void @_ZN3barC2Ei(%struct.bar* %this, i32 %x) unnamed_addr uwtable ssp align 2 !dbg !40 {
+entry:
+  %this.addr = alloca %struct.bar*, align 8
+  %x.addr = alloca i32, align 4
+  store %struct.bar* %this, %struct.bar** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.bar** %this.addr, metadata !63, metadata !DIExpression()), !dbg !64
+  store i32 %x, i32* %x.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %x.addr, metadata !65, metadata !DIExpression()), !dbg !66
+  %this1 = load %struct.bar*, %struct.bar** %this.addr
+  %b = getelementptr inbounds %struct.bar, %struct.bar* %this1, i32 0, i32 0, !dbg !67
+  %0 = load i32, i32* %x.addr, align 4, !dbg !67
+  call void @_ZN3bazC1Ei(%struct.baz* %b, i32 %0), !dbg !67
+  %1 = getelementptr inbounds %struct.bar, %struct.bar* %this1, i32 0, i32 1, !dbg !67
+  %b2 = getelementptr inbounds %struct.bar, %struct.bar* %this1, i32 0, i32 0, !dbg !67
+  store %struct.baz* %b2, %struct.baz** %1, align 8, !dbg !67
+  ret void, !dbg !68
+}
+
+define linkonce_odr void @_ZN3bazC1Ei(%struct.baz* %this, i32 %a) unnamed_addr uwtable ssp align 2 !dbg !43 {
+entry:
+  %this.addr = alloca %struct.baz*, align 8
+  %a.addr = alloca i32, align 4
+  store %struct.baz* %this, %struct.baz** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.baz** %this.addr, metadata !70, metadata !DIExpression()), !dbg !71
+  store i32 %a, i32* %a.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %a.addr, metadata !72, metadata !DIExpression()), !dbg !73
+  %this1 = load %struct.baz*, %struct.baz** %this.addr
+  %0 = load i32, i32* %a.addr, align 4, !dbg !74
+  call void @_ZN3bazC2Ei(%struct.baz* %this1, i32 %0), !dbg !74
+  ret void, !dbg !74
+}
+
+define linkonce_odr void @_ZN3bazC2Ei(%struct.baz* %this, i32 %a) unnamed_addr nounwind uwtable ssp align 2 !dbg !46 {
+entry:
+  %this.addr = alloca %struct.baz*, align 8
+  %a.addr = alloca i32, align 4
+  store %struct.baz* %this, %struct.baz** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.baz** %this.addr, metadata !75, metadata !DIExpression()), !dbg !76
+  store i32 %a, i32* %a.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %a.addr, metadata !77, metadata !DIExpression()), !dbg !78
+  %this1 = load %struct.baz*, %struct.baz** %this.addr
+  %h = getelementptr inbounds %struct.baz, %struct.baz* %this1, i32 0, i32 0, !dbg !79
+  %0 = load i32, i32* %a.addr, align 4, !dbg !79
+  store i32 %0, i32* %h, align 4, !dbg !79
+  ret void, !dbg !80
+}
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!83}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.1 (trunk 146596)", isOptimized: false, emissionKind: FullDebug, file: !82, enums: !1, retainedTypes: !3, globals: !1, imports:  !1)
+!1 = !{}
+!3 = !{!5, !9}
+!5 = !DICompositeType(tag: DW_TAG_class_type, name: "bar", line: 9, size: 128, align: 64, file: !82, elements: !7)
+!6 = !DIFile(filename: "main.cpp", directory: "/Users/echristo/tmp/bad-struct-ref")
+!7 = !{!8, !19, !21}
+!8 = !DIDerivedType(tag: DW_TAG_member, name: "b", line: 11, size: 32, align: 32, file: !82, scope: !5, baseType: !9)
+!9 = !DICompositeType(tag: DW_TAG_class_type, name: "baz", line: 3, size: 32, align: 32, file: !82, elements: !10)
+!10 = !{!11, !13}
+!11 = !DIDerivedType(tag: DW_TAG_member, name: "h", line: 5, size: 32, align: 32, file: !82, scope: !9, baseType: !12)
+!12 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!13 = !DISubprogram(name: "baz", line: 6, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, file: !82, scope: !9, type: !14)
+!14 = !DISubroutineType(types: !15)
+!15 = !{null, !16, !12}
+!16 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, flags: DIFlagArtificial, baseType: !9)
+!19 = !DIDerivedType(tag: DW_TAG_member, name: "b_ref", line: 12, size: 64, align: 64, offset: 64, file: !82, scope: !5, baseType: !20)
+!20 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !9)
+!21 = !DISubprogram(name: "bar", line: 13, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, file: !82, scope: !5, type: !22)
+!22 = !DISubroutineType(types: !23)
+!23 = !{null, !24, !12}
+!24 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, flags: DIFlagArtificial, baseType: !5)
+!29 = distinct !DISubprogram(name: "main", line: 17, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, file: !82, scope: !6, type: !30)
+!30 = !DISubroutineType(types: !31)
+!31 = !{!12, !12, !32}
+!32 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !33)
+!33 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !34)
+!34 = !DIBasicType(tag: DW_TAG_base_type, name: "char", size: 8, align: 8, encoding: DW_ATE_signed_char)
+!35 = !{!36}
+!36 = !{} ; previously: invalid DW_TAG_base_type
+!37 = distinct !DISubprogram(name: "bar", linkageName: "_ZN3barC1Ei", line: 13, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, file: !82, scope: null, type: !22, declaration: !21)
+!38 = !{!39}
+!39 = !{} ; previously: invalid DW_TAG_base_type
+!40 = distinct !DISubprogram(name: "bar", linkageName: "_ZN3barC2Ei", line: 13, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, file: !82, scope: null, type: !22, declaration: !21)
+!41 = !{!42}
+!42 = !{} ; previously: invalid DW_TAG_base_type
+!43 = distinct !DISubprogram(name: "baz", linkageName: "_ZN3bazC1Ei", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, file: !82, scope: null, type: !14, declaration: !13)
+!44 = !{!45}
+!45 = !{} ; previously: invalid DW_TAG_base_type
+!46 = distinct !DISubprogram(name: "baz", linkageName: "_ZN3bazC2Ei", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, file: !82, scope: null, type: !14, declaration: !13)
+!49 = !DILocalVariable(name: "argc", line: 16, arg: 1, scope: !29, file: !6, type: !12)
+!50 = !DILocation(line: 16, column: 14, scope: !29)
+!51 = !DILocalVariable(name: "argv", line: 16, arg: 2, scope: !29, file: !6, type: !32)
+!52 = !DILocation(line: 16, column: 27, scope: !29)
+!53 = !DILocalVariable(name: "myBar", line: 18, scope: !54, file: !6, type: !5)
+!54 = distinct !DILexicalBlock(line: 17, column: 1, file: !82, scope: !29)
+!55 = !DILocation(line: 18, column: 9, scope: !54)
+!56 = !DILocation(line: 18, column: 17, scope: !54)
+!57 = !DILocation(line: 19, column: 5, scope: !54)
+!58 = !DILocalVariable(name: "this", line: 13, arg: 1, flags: DIFlagArtificial, scope: !37, file: !6, type: !24)
+!59 = !DILocation(line: 13, column: 5, scope: !37)
+!60 = !DILocalVariable(name: "x", line: 13, arg: 2, scope: !37, file: !6, type: !12)
+!61 = !DILocation(line: 13, column: 13, scope: !37)
+!62 = !DILocation(line: 13, column: 34, scope: !37)
+!63 = !DILocalVariable(name: "this", line: 13, arg: 1, flags: DIFlagArtificial, scope: !40, file: !6, type: !24)
+!64 = !DILocation(line: 13, column: 5, scope: !40)
+!65 = !DILocalVariable(name: "x", line: 13, arg: 2, scope: !40, file: !6, type: !12)
+!66 = !DILocation(line: 13, column: 13, scope: !40)
+!67 = !DILocation(line: 13, column: 33, scope: !40)
+!68 = !DILocation(line: 13, column: 34, scope: !69)
+!69 = distinct !DILexicalBlock(line: 13, column: 33, file: !82, scope: !40)
+!70 = !DILocalVariable(name: "this", line: 6, arg: 1, flags: DIFlagArtificial, scope: !43, file: !6, type: !16)
+!71 = !DILocation(line: 6, column: 5, scope: !43)
+!72 = !DILocalVariable(name: "a", line: 6, arg: 2, scope: !43, file: !6, type: !12)
+!73 = !DILocation(line: 6, column: 13, scope: !43)
+!74 = !DILocation(line: 6, column: 24, scope: !43)
+!75 = !DILocalVariable(name: "this", line: 6, arg: 1, flags: DIFlagArtificial, scope: !46, file: !6, type: !16)
+!76 = !DILocation(line: 6, column: 5, scope: !46)
+!77 = !DILocalVariable(name: "a", line: 6, arg: 2, scope: !46, file: !6, type: !12)
+!78 = !DILocation(line: 6, column: 13, scope: !46)
+!79 = !DILocation(line: 6, column: 23, scope: !46)
+!80 = !DILocation(line: 6, column: 24, scope: !81)
+!81 = distinct !DILexicalBlock(line: 6, column: 23, file: !82, scope: !46)
+!82 = !DIFile(filename: "main.cpp", directory: "/Users/echristo/tmp/bad-struct-ref")
+!83 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/DW_AT_byte_size.ll b/test/DebugInfo/X86/DW_AT_byte_size.ll
new file mode 100644
index 0000000..f650bbc
--- /dev/null
+++ b/test/DebugInfo/X86/DW_AT_byte_size.ll
@@ -0,0 +1,51 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -all %t | FileCheck %s
+
+; Checks that we don't emit a size for a pointer type.
+; CHECK: DW_TAG_pointer_type
+; CHECK-NEXT: DW_AT_type
+; CHECK-NOT: DW_AT_byte_size
+; CHECK: DW_TAG
+; CHECK: .debug_info contents
+
+%struct.A = type { i32 }
+
+define i32 @_Z3fooP1A(%struct.A* %a) nounwind uwtable ssp !dbg !5 {
+entry:
+  %a.addr = alloca %struct.A*, align 8
+  store %struct.A* %a, %struct.A** %a.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.A** %a.addr, metadata !16, metadata !DIExpression()), !dbg !17
+  %0 = load %struct.A*, %struct.A** %a.addr, align 8, !dbg !18
+  %b = getelementptr inbounds %struct.A, %struct.A* %0, i32 0, i32 0, !dbg !18
+  %1 = load i32, i32* %b, align 4, !dbg !18
+  ret i32 %1, !dbg !18
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!21}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.1 (trunk 150996)", isOptimized: false, emissionKind: FullDebug, file: !20, enums: !1, retainedTypes: !1, globals: !1, imports:  !1)
+!1 = !{}
+!5 = distinct !DISubprogram(name: "foo", linkageName: "_Z3fooP1A", line: 3, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 3, file: !20, scope: !6, type: !7)
+!6 = !DIFile(filename: "foo.cpp", directory: "/Users/echristo")
+!7 = !DISubroutineType(types: !8)
+!8 = !{!9, !10}
+!9 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!10 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !11)
+!11 = !DICompositeType(tag: DW_TAG_class_type, name: "A", line: 1, size: 32, align: 32, file: !20, elements: !12)
+!12 = !{!13}
+!13 = !DIDerivedType(tag: DW_TAG_member, name: "b", line: 1, size: 32, align: 32, file: !20, scope: !11, baseType: !9)
+!16 = !DILocalVariable(name: "a", line: 3, arg: 1, scope: !5, file: !6, type: !10)
+!17 = !DILocation(line: 3, column: 13, scope: !5)
+!18 = !DILocation(line: 4, column: 3, scope: !19)
+!19 = distinct !DILexicalBlock(line: 3, column: 16, file: !20, scope: !5)
+!20 = !DIFile(filename: "foo.cpp", directory: "/Users/echristo")
+!21 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/DW_AT_linkage_name.ll b/test/DebugInfo/X86/DW_AT_linkage_name.ll
new file mode 100644
index 0000000..4e9c986
--- /dev/null
+++ b/test/DebugInfo/X86/DW_AT_linkage_name.ll
@@ -0,0 +1,117 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-macosx %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -v -debug-info %t | FileCheck %s
+;
+; struct A {
+;   A(int i);
+;   ~A();
+; };
+;
+; A::~A() {}
+;
+; void foo() {
+;   A a(1);
+; }
+;
+; rdar://problem/16362674
+;
+; Test that we do not emit a linkage name for the declaration of a destructor.
+; Test that we do emit a linkage name for a specific instance of it.
+
+; CHECK: DW_TAG_subprogram
+; CHECK: DW_TAG_subprogram
+; CHECK: DW_AT_name {{.*}} "~A"
+; CHECK-NOT: DW_AT_MIPS_linkage_name
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_MIPS_linkage_name {{.*}} "_ZN1AD2Ev"
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_specification {{.*}} "~A"
+
+
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+%struct.A = type { i8 }
+
+; Function Attrs: nounwind ssp uwtable
+define void @_ZN1AD2Ev(%struct.A* %this) unnamed_addr #0 align 2 !dbg !17 {
+entry:
+  %this.addr = alloca %struct.A*, align 8
+  store %struct.A* %this, %struct.A** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.A** %this.addr, metadata !26, metadata !DIExpression()), !dbg !28
+  %this1 = load %struct.A*, %struct.A** %this.addr
+  ret void, !dbg !29
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+; Function Attrs: nounwind ssp uwtable
+define void @_ZN1AD1Ev(%struct.A* %this) unnamed_addr #0 align 2 !dbg !18 {
+entry:
+  %this.addr = alloca %struct.A*, align 8
+  store %struct.A* %this, %struct.A** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %struct.A** %this.addr, metadata !30, metadata !DIExpression()), !dbg !31
+  %this1 = load %struct.A*, %struct.A** %this.addr
+  call void @_ZN1AD2Ev(%struct.A* %this1), !dbg !32
+  ret void, !dbg !33
+}
+
+; Function Attrs: ssp uwtable
+define void @_Z3foov() #2 !dbg !19 {
+entry:
+  %a = alloca %struct.A, align 1
+  call void @llvm.dbg.declare(metadata %struct.A* %a, metadata !34, metadata !DIExpression()), !dbg !35
+  call void @_ZN1AC1Ei(%struct.A* %a, i32 1), !dbg !35
+  call void @_ZN1AD1Ev(%struct.A* %a), !dbg !36
+  ret void, !dbg !36
+}
+
+declare void @_ZN1AC1Ei(%struct.A*, i32)
+
+attributes #0 = { nounwind ssp uwtable }
+attributes #1 = { nounwind readnone }
+attributes #2 = { ssp uwtable }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!23, !24}
+!llvm.ident = !{!25}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !3, globals: !2, imports: !2)
+!1 = !DIFile(filename: "linkage-name.cpp", directory: "")
+!2 = !{}
+!3 = !{!4}
+!4 = !DICompositeType(tag: DW_TAG_structure_type, name: "A", line: 1, size: 8, align: 8, file: !1, elements: !5, identifier: "_ZTS1A")
+!5 = !{!6, !12}
+!6 = !DISubprogram(name: "A", line: 2, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, scopeLine: 2, file: !1, scope: !4, type: !7)
+!7 = !DISubroutineType(types: !8)
+!8 = !{null, !9, !10}
+!9 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer, baseType: !4)
+!10 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!12 = !DISubprogram(name: "~A", line: 3, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, scopeLine: 3, file: !1, scope: !4, type: !13)
+!13 = !DISubroutineType(types: !14)
+!14 = !{null, !9}
+!17 = distinct !DISubprogram(name: "~A", linkageName: "_ZN1AD2Ev", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 6, file: !1, scope: !4, type: !13, declaration: !12, retainedNodes: !2)
+!18 = distinct !DISubprogram(name: "~A", linkageName: "_ZN1AD1Ev", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 6, file: !1, scope: !4, type: !13, declaration: !12, retainedNodes: !2)
+!19 = distinct !DISubprogram(name: "foo", linkageName: "_Z3foov", line: 10, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 10, file: !1, scope: !20, type: !21, retainedNodes: !2)
+!20 = !DIFile(filename: "linkage-name.cpp", directory: "")
+!21 = !DISubroutineType(types: !22)
+!22 = !{null}
+!23 = !{i32 2, !"Dwarf Version", i32 2}
+!24 = !{i32 1, !"Debug Info Version", i32 3}
+!25 = !{!"clang version 3.5.0 "}
+!26 = !DILocalVariable(name: "this", arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !17, type: !27)
+!27 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !4)
+!28 = !DILocation(line: 0, scope: !17)
+!29 = !DILocation(line: 8, scope: !17)
+!30 = !DILocalVariable(name: "this", arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !18, type: !27)
+!31 = !DILocation(line: 0, scope: !18)
+!32 = !DILocation(line: 6, scope: !18)
+!33 = !DILocation(line: 8, scope: !18)
+!34 = !DILocalVariable(name: "a", line: 11, scope: !19, file: !20, type: !4)
+!35 = !DILocation(line: 11, scope: !19)
+!36 = !DILocation(line: 12, scope: !19)
diff --git a/test/DebugInfo/X86/DW_AT_specification.ll b/test/DebugInfo/X86/DW_AT_specification.ll
new file mode 100644
index 0000000..e57d735
--- /dev/null
+++ b/test/DebugInfo/X86/DW_AT_specification.ll
@@ -0,0 +1,49 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -v -debug-info %t | FileCheck %s
+
+; test that the DW_AT_specification is a back edge in the file.
+
+; CHECK: DW_TAG_subprogram
+; CHECK-NEXT: DW_AT_linkage_name {{.*}} "_ZN3foo3barEv"
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_specification {{.*}} "_ZN3foo3barEv"
+
+source_filename = "test/DebugInfo/X86/DW_AT_specification.ll"
+
+@_ZZN3foo3barEvE1x = constant i32 0, align 4, !dbg !0
+
+define void @_ZN3foo3barEv() !dbg !2 {
+entry:
+  ret void, !dbg !17
+}
+
+!llvm.dbg.cu = !{!8}
+!llvm.module.flags = !{!16}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "x", scope: !2, file: !3, line: 5, type: !14, isLocal: true, isDefinition: true)
+!2 = distinct !DISubprogram(name: "bar", linkageName: "_ZN3foo3barEv", scope: null, file: !3, line: 4, type: !4, isLocal: false, isDefinition: true, scopeLine: 4, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !8, declaration: !11)
+!3 = !DIFile(filename: "nsNativeAppSupportBase.ii", directory: "/Users/espindola/mozilla-central/obj-x86_64-apple-darwin11.2.0/toolkit/library")
+!4 = !DISubroutineType(types: !5)
+!5 = !{null, !6}
+!6 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !7, size: 64, align: 64, flags: DIFlagArtificial)
+!7 = !DICompositeType(tag: DW_TAG_structure_type, name: "foo", file: !3, line: 1, flags: DIFlagFwdDecl)
+!8 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !3, producer: "clang version 3.0 ()", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !9, retainedTypes: !9, globals: !10, imports: !9)
+!9 = !{}
+!10 = !{!0}
+!11 = !DISubprogram(name: "bar", linkageName: "_ZN3foo3barEv", scope: !12, file: !3, line: 2, type: !4, isLocal: false, isDefinition: false, scopeLine: 2, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false)
+!12 = !DICompositeType(tag: DW_TAG_class_type, name: "foo", file: !3, line: 1, size: 8, align: 8, elements: !13)
+!13 = !{!11}
+!14 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !15)
+!15 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!16 = !{i32 1, !"Debug Info Version", i32 3}
+!17 = !DILocation(line: 6, column: 1, scope: !18)
+!18 = distinct !DILexicalBlock(scope: !2, file: !3, line: 4, column: 17)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/DW_AT_stmt_list_sec_offset.ll b/test/DebugInfo/X86/DW_AT_stmt_list_sec_offset.ll
new file mode 100644
index 0000000..d81c85e
--- /dev/null
+++ b/test/DebugInfo/X86/DW_AT_stmt_list_sec_offset.ll
@@ -0,0 +1,47 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=i686-w64-mingw32 -o %t -filetype=obj %t.ll
+; RUN: llvm-dwarfdump -v -all %t | FileCheck %s
+; RUN: llc -mtriple=i686-w64-mingw32 -o %t -filetype=obj -dwarf-version=3 %t.ll
+; RUN: llvm-dwarfdump -v -all %t | FileCheck %s -check-prefix=DWARF3
+
+; CHECK:         DW_AT_stmt_list [DW_FORM_sec_offset]
+; DWARF3:        DW_AT_stmt_list [DW_FORM_data4]
+;
+; generated from:
+; clang -g -S -emit-llvm test.c -o test.ll
+; int main()
+; {
+;       return 0;
+; }
+
+; ModuleID = 'test.c'
+target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-f80:128:128-v64:64:64-v128:128:128-a0:0:64-f80:32:32-n8:16:32-S32"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind
+define i32 @main() #0 !dbg !4 {
+entry:
+  %retval = alloca i32, align 4
+  store i32 0, i32* %retval
+  ret i32 0, !dbg !10
+}
+
+attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!9, !11}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.4 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "test.c", directory: "C:\5CProjects")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "main", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !0, scopeLine: 2, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "test.c", directory: "C:CProjects")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = !{i32 2, !"Dwarf Version", i32 4}
+!10 = !DILocation(line: 3, scope: !4)
+!11 = !{i32 1, !"Debug Info Version", i32 3}
diff --git a/test/DebugInfo/X86/InlinedFnLocalVar.ll b/test/DebugInfo/X86/InlinedFnLocalVar.ll
new file mode 100644
index 0000000..49b1059
--- /dev/null
+++ b/test/DebugInfo/X86/InlinedFnLocalVar.ll
@@ -0,0 +1,70 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple i686-pc-cygwin -O2 %t.ll -o - | FileCheck %s
+; Check struct X for dead variable xyz from inlined function foo.
+
+; CHECK: Lsection_info
+; CHECK:	DW_TAG_structure_type
+; CHECK-NEXT:	info_string
+
+source_filename = "test/DebugInfo/X86/InlinedFnLocalVar.ll"
+
+@i = common global i32 0, !dbg !0
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #0
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #0
+
+; Function Attrs: nounwind ssp
+define i32 @bar() #1 !dbg !8 {
+entry:
+  %0 = load i32, i32* @i, align 4, !dbg !11
+  tail call void @llvm.dbg.value(metadata i32 %0, metadata !13, metadata !24), !dbg !25
+  tail call void @llvm.dbg.declare(metadata !5, metadata !18, metadata !24), !dbg !26
+  %1 = mul nsw i32 %0, %0, !dbg !27
+  store i32 %1, i32* @i, align 4, !dbg !11
+  ret i32 %1, !dbg !28
+}
+
+attributes #0 = { nounwind readnone }
+attributes #1 = { nounwind ssp }
+
+!llvm.dbg.cu = !{!4}
+!llvm.module.flags = !{!7}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "i", scope: !2, file: !2, line: 5, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "bar.c", directory: "/tmp/")
+!3 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!4 = distinct !DICompileUnit(language: DW_LANG_C89, file: !2, producer: "4.2.1 (Based on Apple Inc. build 5658) (LLVM build)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !5, retainedTypes: !5, globals: !6, imports: !5)
+!5 = !{}
+!6 = !{!0}
+!7 = !{i32 1, !"Debug Info Version", i32 3}
+!8 = distinct !DISubprogram(name: "bar", linkageName: "bar", scope: !2, file: !2, line: 14, type: !9, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: true, unit: !4)
+!9 = !DISubroutineType(types: !10)
+!10 = !{!3}
+!11 = !DILocation(line: 15, scope: !12)
+!12 = distinct !DILexicalBlock(scope: !8, file: !2, line: 14)
+!13 = !DILocalVariable(name: "j", arg: 1, scope: !14, file: !2, line: 9, type: !3)
+!14 = distinct !DISubprogram(name: "foo", scope: !2, file: !2, line: 9, type: !15, isLocal: true, isDefinition: true, scopeLine: 9, virtualIndex: 6, isOptimized: true, unit: !4, retainedNodes: !17)
+!15 = !DISubroutineType(types: !16)
+!16 = !{!3, !3}
+!17 = !{!13, !18}
+!18 = !DILocalVariable(name: "xyz", scope: !19, file: !2, line: 10, type: !20)
+!19 = distinct !DILexicalBlock(scope: !14, file: !2, line: 9)
+!20 = !DICompositeType(tag: DW_TAG_structure_type, name: "X", scope: !14, file: !2, line: 10, size: 64, align: 32, elements: !21)
+!21 = !{!22, !23}
+!22 = !DIDerivedType(tag: DW_TAG_member, name: "a", scope: !20, file: !2, line: 10, baseType: !3, size: 32, align: 32)
+!23 = !DIDerivedType(tag: DW_TAG_member, name: "b", scope: !20, file: !2, line: 10, baseType: !3, size: 32, align: 32, offset: 32)
+!24 = !DIExpression()
+!25 = !DILocation(line: 9, scope: !14, inlinedAt: !11)
+!26 = !DILocation(line: 9, scope: !19, inlinedAt: !11)
+!27 = !DILocation(line: 11, scope: !19, inlinedAt: !11)
+!28 = !DILocation(line: 16, scope: !12)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/abstract_origin.ll b/test/DebugInfo/X86/abstract_origin.ll
new file mode 100644
index 0000000..aff8c7b
--- /dev/null
+++ b/test/DebugInfo/X86/abstract_origin.ll
@@ -0,0 +1,61 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj %t.ll -o - | llvm-dwarfdump -debug-info - | FileCheck %s
+; Generated at -O2 from:
+;   void f();
+;   __attribute__((always_inline)) void g() {
+;     f();
+;   }
+;   void h() {
+;     g();
+;   };
+; CHECK: DW_TAG_subprogram
+; CHECK:  DW_AT_abstract_origin {{.*}}"g"
+; CHECK-NOT:  DW_AT_abstract_origin {{.*}}"g"
+; CHECK: DW_TAG
+source_filename = "test.c"
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: alwaysinline nounwind ssp uwtable
+define void @g() #0 !dbg !7 {
+entry:
+  tail call void (...) @f() #3, !dbg !10
+  ret void, !dbg !11
+}
+
+declare void @f(...)
+
+; Function Attrs: nounwind ssp uwtable
+define void @h() #2 !dbg !12 {
+entry:
+  tail call void (...) @f() #3, !dbg !13
+  ret void, !dbg !15
+}
+
+attributes #0 = { alwaysinline nounwind ssp uwtable }
+attributes #2 = { nounwind ssp uwtable }
+attributes #3 = { nounwind }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4, !5}
+!llvm.ident = !{!6}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 3.9.0 ", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "test.c", directory: "/Volumes/Data/llvm")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 2}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{i32 1, !"PIC Level", i32 2}
+!6 = !{!"clang version 3.9.0 "}
+!7 = distinct !DISubprogram(name: "g", scope: !1, file: !1, line: 2, type: !8, isLocal: false, isDefinition: true, scopeLine: 2, isOptimized: true, unit: !0, retainedNodes: !2)
+!8 = !DISubroutineType(types: !9)
+!9 = !{null}
+!10 = !DILocation(line: 3, column: 3, scope: !7)
+!11 = !DILocation(line: 4, column: 1, scope: !7)
+!12 = distinct !DISubprogram(name: "h", scope: !1, file: !1, line: 5, type: !8, isLocal: false, isDefinition: true, scopeLine: 5, isOptimized: true, unit: !0, retainedNodes: !2)
+!13 = !DILocation(line: 3, column: 3, scope: !7, inlinedAt: !14)
+!14 = distinct !DILocation(line: 6, column: 3, scope: !12)
+!15 = !DILocation(line: 7, column: 1, scope: !12)
diff --git a/test/DebugInfo/X86/aligned_stack_var.ll b/test/DebugInfo/X86/aligned_stack_var.ll
new file mode 100644
index 0000000..4aac156
--- /dev/null
+++ b/test/DebugInfo/X86/aligned_stack_var.ll
@@ -0,0 +1,48 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc %t.ll -mtriple=x86_64-pc-linux-gnu -O0 -filetype=obj -o %t
+; RUN: llvm-dwarfdump -debug-info %t | FileCheck %s
+
+; If stack is realigned, we shouldn't describe locations of local
+; variables by giving offset from the frame pointer (%rbp):
+; push %rpb
+; mov  %rsp,%rbp
+; and  ALIGNMENT,%rsp ; (%rsp and %rbp are different now)
+; It's better to use offset from %rsp instead.
+
+; DW_AT_location of variable "x" shouldn't be equal to
+; (DW_OP_fbreg: .*): DW_OP_fbreg has code 0x91
+
+; CHECK: {{0x.* DW_TAG_variable}}
+; CHECK-NOT: {{DW_AT_location.*DW_FORM_block1.*0x.*91}}
+; CHECK: NULL
+
+define void @_Z3runv() nounwind uwtable !dbg !5 {
+entry:
+  %x = alloca i32, align 32
+  call void @llvm.dbg.declare(metadata i32* %x, metadata !9, metadata !DIExpression()), !dbg !12
+  ret void, !dbg !13
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!15}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.2 (trunk 155696:155697) (llvm/trunk 155696)", isOptimized: false, emissionKind: FullDebug, file: !14, enums: !1, retainedTypes: !1, globals: !1, imports:  !1)
+!1 = !{}
+!5 = distinct !DISubprogram(name: "run", linkageName: "_Z3runv", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 1, file: !14, scope: !6, type: !7, retainedNodes: !1)
+!6 = !DIFile(filename: "test.cc", directory: "/home/samsonov/debuginfo")
+!7 = !DISubroutineType(types: !8)
+!8 = !{null}
+!9 = !DILocalVariable(name: "x", line: 2, scope: !10, file: !6, type: !11)
+!10 = distinct !DILexicalBlock(line: 1, column: 12, file: !14, scope: !5)
+!11 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!12 = !DILocation(line: 2, column: 7, scope: !10)
+!13 = !DILocation(line: 3, column: 1, scope: !10)
+!14 = !DIFile(filename: "test.cc", directory: "/home/samsonov/debuginfo")
+!15 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/arguments.ll b/test/DebugInfo/X86/arguments.ll
new file mode 100644
index 0000000..b052c05
--- /dev/null
+++ b/test/DebugInfo/X86/arguments.ll
@@ -0,0 +1,80 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-unknown-unknown -O0 -filetype=obj < %t.ll > %t
+; RUN: llvm-dwarfdump %t | FileCheck %s
+
+; IR generated from clang -g with the following source:
+; struct foo {
+;   foo(const foo&);
+;   int i;
+; };
+;
+; void func(foo f, foo g) {
+;   f.i++;
+; }
+
+; CHECK: debug_info contents
+; CHECK: DW_TAG_subprogram
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_linkage_name{{.*}}"_Z4func3fooS_"
+; CHECK-NOT: NULL
+; CHECK: DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_name{{.*}}"f"
+; CHECK-NOT: NULL
+; CHECK: DW_TAG_formal_parameter
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_name{{.*}}"g"
+
+%struct.foo = type { i32 }
+
+; Function Attrs: nounwind uwtable
+define void @_Z4func3fooS_(%struct.foo* %f, %struct.foo* %g) #0 !dbg !4 {
+entry:
+  call void @llvm.dbg.declare(metadata %struct.foo* %f, metadata !19, metadata !DIExpression()), !dbg !20
+  call void @llvm.dbg.declare(metadata %struct.foo* %g, metadata !21, metadata !DIExpression()), !dbg !20
+  %i = getelementptr inbounds %struct.foo, %struct.foo* %f, i32 0, i32 0, !dbg !22
+  %0 = load i32, i32* %i, align 4, !dbg !22
+  %inc = add nsw i32 %0, 1, !dbg !22
+  store i32 %inc, i32* %i, align 4, !dbg !22
+  ret void, !dbg !23
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!24}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.4 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "scratch.cpp", directory: "/usr/local/google/home/blaikie/dev/scratch")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "func", linkageName: "_Z4func3fooS_", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 6, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "scratch.cpp", directory: "/usr/local/google/home/blaikie/dev/scratch")
+!6 = !DISubroutineType(types: !7)
+!7 = !{null, !8, !8}
+!8 = !DICompositeType(tag: DW_TAG_structure_type, name: "foo", line: 1, size: 32, align: 32, file: !1, elements: !9)
+!9 = !{!10, !12}
+!10 = !DIDerivedType(tag: DW_TAG_member, name: "i", line: 3, size: 32, align: 32, file: !1, scope: !8, baseType: !11)
+!11 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!12 = !DISubprogram(name: "foo", line: 2, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, scopeLine: 2, file: !1, scope: !8, type: !13)
+!13 = !DISubroutineType(types: !14)
+!14 = !{null, !15, !16}
+!15 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer, baseType: !8)
+!16 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !17)
+!17 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !8)
+!19 = !DILocalVariable(name: "f", line: 6, arg: 1, scope: !4, file: !5, type: !8)
+!20 = !DILocation(line: 6, scope: !4)
+!21 = !DILocalVariable(name: "g", line: 6, arg: 2, scope: !4, file: !5, type: !8)
+!22 = !DILocation(line: 7, scope: !4)
+!23 = !DILocation(line: 8, scope: !4)
+!24 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/coff_debug_info_type.ll b/test/DebugInfo/X86/coff_debug_info_type.ll
new file mode 100644
index 0000000..f0a4318
--- /dev/null
+++ b/test/DebugInfo/X86/coff_debug_info_type.ll
@@ -0,0 +1,50 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=i686-pc-mingw32 -accel-tables=Apple -filetype=asm -O0 < %t.ll | FileCheck %s
+; RUN: llc -mtriple=i686-pc-cygwin -accel-tables=Apple -filetype=asm -O0 < %t.ll | FileCheck %s
+; RUN: llc -mtriple=i686-w64-mingw32 -accel-tables=Apple -filetype=asm -O0 < %t.ll | FileCheck %s
+; CHECK:    .section  .debug_info
+; CHECK:    .section  .apple_names
+; CHECK:    .section  .apple_types
+
+; RUN: sed -e 's/"Dwarf Version"/"CodeView"/' %s \
+; RUN:     | llc -mtriple=i686-pc-win32 -filetype=asm -O0 \
+; RUN:     | FileCheck -check-prefix=WIN32 %s
+; WIN32:    .section .debug$S,"dr"
+
+; RUN: llc -mtriple=i686-pc-win32 -filetype=null -O0 < %t.ll
+
+; generated from:
+; clang -g -S -emit-llvm test.c -o test.ll
+; int main()
+; {
+; 	return 0;
+; }
+
+define i32 @main() #0 !dbg !4 {
+entry:
+  %retval = alloca i32, align 4
+  store i32 0, i32* %retval
+  ret i32 0, !dbg !10
+}
+
+attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!9, !11}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.4 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "test.c", directory: "C:\5CProjects")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "main", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !0, scopeLine: 2, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "test.c", directory: "C:CProjects")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = !{i32 2, !"Dwarf Version", i32 3}
+!10 = !DILocation(line: 3, scope: !4)
+!11 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/coff_relative_names.ll b/test/DebugInfo/X86/coff_relative_names.ll
new file mode 100644
index 0000000..beba48f
--- /dev/null
+++ b/test/DebugInfo/X86/coff_relative_names.ll
@@ -0,0 +1,42 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=i686-w64-mingw32 -filetype=asm -O0 < %t.ll | FileCheck %s
+
+; CHECK:  	.secrel32 Linfo_string0
+; CHECK:  	.secrel32 Linfo_string1
+;
+; generated from:
+; clang -g -S -emit-llvm test.c -o test.ll
+; int main()
+; {
+; 	return 0;
+; }
+
+; Function Attrs: nounwind
+define i32 @main() #0 !dbg !4 {
+entry:
+  %retval = alloca i32, align 4
+  store i32 0, i32* %retval
+  ret i32 0, !dbg !10
+}
+
+attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf"="true" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!9, !11}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.4 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "test.c", directory: "C:\5CProjects")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "main", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !0, scopeLine: 2, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "test.c", directory: "C:CProjects")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = !{i32 2, !"Dwarf Version", i32 3}
+!10 = !DILocation(line: 3, scope: !4)
+!11 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/constant-aggregate.ll b/test/DebugInfo/X86/constant-aggregate.ll
new file mode 100644
index 0000000..8d7f76b
--- /dev/null
+++ b/test/DebugInfo/X86/constant-aggregate.ll
@@ -0,0 +1,121 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple %t.ll -filetype=obj -o %t.o
+; RUN: llvm-dwarfdump -v -debug-info %t.o | FileCheck %s
+; Test emitting a constant for an aggregate type.
+;
+; clang -S -O1 -emit-llvm
+;
+; typedef struct { unsigned i; } S;
+;
+; unsigned foo(S s) {
+;   s.i = 1;
+;   return s.i;
+; }
+;
+; class C { public: unsigned i; };
+;
+; unsigned foo(C c) {
+;   c.i = 2;
+;   return c.i;
+; }
+;
+; unsigned bar() {
+;  int a[1] = { 3 };
+;   return a[0];
+; }
+;
+; CHECK:  DW_TAG_formal_parameter
+; CHECK-NEXT: DW_AT_const_value [DW_FORM_udata]	(1)
+; CHECK-NEXT: DW_AT_name {{.*}} "s"
+;
+; CHECK:  DW_TAG_formal_parameter
+; CHECK-NEXT: DW_AT_const_value [DW_FORM_udata]	(2)
+; CHECK-NEXT: DW_AT_name {{.*}} "c"
+;
+; CHECK:  DW_TAG_variable
+; CHECK-NEXT: DW_AT_const_value [DW_FORM_udata]	(3)
+; CHECK-NEXT: DW_AT_name {{.*}} "a"
+
+; ModuleID = 'sroasplit-4.cpp'
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind readnone ssp uwtable
+define i32 @_Z3foo1S(i32 %s.coerce) #0 !dbg !12 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 %s.coerce, metadata !18, metadata !37), !dbg !38
+  tail call void @llvm.dbg.value(metadata i32 1, metadata !18, metadata !37), !dbg !38
+  ret i32 1, !dbg !39
+}
+
+; Function Attrs: nounwind readnone ssp uwtable
+define i32 @_Z3foo1C(i32 %c.coerce) #0 !dbg !19 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 %c.coerce, metadata !23, metadata !37), !dbg !40
+  tail call void @llvm.dbg.value(metadata i32 2, metadata !23, metadata !37), !dbg !40
+  ret i32 2, !dbg !41
+}
+
+; Function Attrs: nounwind readnone ssp uwtable
+define i32 @_Z3barv() #0 !dbg !24 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 3, metadata !28, metadata !37), !dbg !42
+  ret i32 3, !dbg !43
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind readnone ssp uwtable }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!33, !34, !35}
+!llvm.ident = !{!36}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.6.0 (trunk 225364) (llvm/trunk 225366)", isOptimized: true, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !3, globals: !2, imports: !2)
+!1 = !DIFile(filename: "sroasplit-4.cpp", directory: "")
+!2 = !{}
+!3 = !{!4, !8}
+!4 = !DICompositeType(tag: DW_TAG_structure_type, line: 1, size: 32, align: 32, file: !1, elements: !5, identifier: "_ZTS1S")
+!5 = !{!6}
+!6 = !DIDerivedType(tag: DW_TAG_member, name: "i", line: 1, size: 32, align: 32, file: !1, scope: !4, baseType: !7)
+!7 = !DIBasicType(tag: DW_TAG_base_type, name: "unsigned int", size: 32, align: 32, encoding: DW_ATE_unsigned)
+!8 = !DICompositeType(tag: DW_TAG_class_type, name: "C", line: 8, size: 32, align: 32, file: !1, elements: !9, identifier: "_ZTS1C")
+!9 = !{!10}
+!10 = !DIDerivedType(tag: DW_TAG_member, name: "i", line: 8, size: 32, align: 32, flags: DIFlagPublic, file: !1, scope: !8, baseType: !7)
+!12 = distinct !DISubprogram(name: "foo", linkageName: "_Z3foo1S", line: 3, isLocal: false, isDefinition: true, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 3, file: !1, scope: !13, type: !14, retainedNodes: !17)
+!13 = !DIFile(filename: "sroasplit-4.cpp", directory: "")
+!14 = !DISubroutineType(types: !15)
+!15 = !{!7, !16}
+!16 = !DIDerivedType(tag: DW_TAG_typedef, name: "S", line: 1, file: !1, baseType: !4)
+!17 = !{!18}
+!18 = !DILocalVariable(name: "s", line: 3, arg: 1, scope: !12, file: !13, type: !16)
+!19 = distinct !DISubprogram(name: "foo", linkageName: "_Z3foo1C", line: 10, isLocal: false, isDefinition: true, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 10, file: !1, scope: !13, type: !20, retainedNodes: !22)
+!20 = !DISubroutineType(types: !21)
+!21 = !{!7, !8}
+!22 = !{!23}
+!23 = !DILocalVariable(name: "c", line: 10, arg: 1, scope: !19, file: !13, type: !8)
+!24 = distinct !DISubprogram(name: "bar", linkageName: "_Z3barv", line: 15, isLocal: false, isDefinition: true, flags: DIFlagPrototyped, isOptimized: true, unit: !0, scopeLine: 15, file: !1, scope: !13, type: !25, retainedNodes: !27)
+!25 = !DISubroutineType(types: !26)
+!26 = !{!7}
+!27 = !{!28}
+!28 = !DILocalVariable(name: "a", line: 16, scope: !24, file: !13, type: !29)
+!29 = !DICompositeType(tag: DW_TAG_array_type, size: 32, align: 32, baseType: !30, elements: !31)
+!30 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!31 = !{!32}
+!32 = !DISubrange(count: 1)
+!33 = !{i32 2, !"Dwarf Version", i32 2}
+!34 = !{i32 2, !"Debug Info Version", i32 3}
+!35 = !{i32 1, !"PIC Level", i32 2}
+!36 = !{!"clang version 3.6.0 (trunk 225364) (llvm/trunk 225366)"}
+!37 = !DIExpression()
+!38 = !DILocation(line: 3, column: 16, scope: !12)
+!39 = !DILocation(line: 5, column: 3, scope: !12)
+!40 = !DILocation(line: 10, column: 16, scope: !19)
+!41 = !DILocation(line: 12, column: 3, scope: !19)
+!42 = !DILocation(line: 16, column: 6, scope: !24)
+!43 = !DILocation(line: 17, column: 3, scope: !24)
diff --git a/test/DebugInfo/X86/constant-loclist.ll b/test/DebugInfo/X86/constant-loclist.ll
new file mode 100644
index 0000000..151a4c6
--- /dev/null
+++ b/test/DebugInfo/X86/constant-loclist.ll
@@ -0,0 +1,78 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj %t.ll -o - | llvm-dwarfdump -v -debug-info - | FileCheck %s
+
+; A hand-written testcase to check 64-bit constant handling in location lists.
+
+; CHECK: .debug_info contents:
+; CHECK: DW_TAG_variable
+; CHECK-NEXT: DW_AT_location [DW_FORM_data4]	(
+; CHECK-NEXT:   0x{{.*}}, 0x{{.*}}: DW_OP_constu 0x4000000000000000)
+; CHECK-NEXT: DW_AT_name {{.*}}"d"
+; CHECK: DW_TAG_variable
+; CHECK-NEXT: DW_AT_location [DW_FORM_data4]	(
+; CHECK-NEXT:   0x{{.*}}, 0x{{.*}}: DW_OP_consts +0
+; CHECK-NEXT:   0x{{.*}}, 0x{{.*}}: DW_OP_consts +4611686018427387904)
+; CHECK-NEXT: DW_AT_name {{.*}}"i"
+; CHECK: DW_TAG_variable
+; CHECK-NEXT: DW_AT_location [DW_FORM_data4]	(
+; CHECK-NEXT:   0x{{.*}}, 0x{{.*}}: DW_OP_constu 0x0 
+; CHECK-NEXT:   0x{{.*}}, 0x{{.*}}: DW_OP_constu 0x4000000000000000)
+; CHECK-NEXT: DW_AT_name {{.*}}"u"
+
+source_filename = "test.c"
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind ssp uwtable
+define void @main() #0 !dbg !7 {
+  %1 = alloca double, align 8
+  %2 = alloca i64, align 8
+  %3 = alloca i64, align 8
+  store double 2.000000e+00, double* %1, align 8, !dbg !21
+  call void @llvm.dbg.value(metadata i64 0, metadata !22, metadata !15), !dbg !24
+  call void @llvm.dbg.value(metadata i64 0, metadata !25, metadata !15), !dbg !27
+  call void @llvm.dbg.value(metadata double 2.000000e+00, metadata !19, metadata !15), !dbg !21
+  store i64 4611686018427387904, i64* %2, align 8, !dbg !24
+  call void @llvm.dbg.value(metadata i64 4611686018427387904, metadata !22, metadata !15), !dbg !24
+  call void @llvm.dbg.value(metadata i64 4611686018427387904, metadata !25, metadata !15), !dbg !27
+  store i64 4611686018427387904, i64* %3, align 8, !dbg !27
+  ret void, !dbg !28
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+
+attributes #0 = { nounwind ssp uwtable }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4, !5}
+!llvm.ident = !{!6}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "test.c", directory: "/tmp")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 2}
+!4 = !{i32 2, !"Debug Info Version", i32 00000003}
+!5 = !{i32 1, !"PIC Level", i32 2}
+!6 = !{!"clang"}
+!7 = distinct !DISubprogram(name: "main", scope: !1, file: !1, line: 1, type: !8, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!8 = !DISubroutineType(types: !{})
+!15 = !DIExpression()
+!16 = !DILocation(line: 1, column: 14, scope: !7)
+!18 = !DILocation(line: 1, column: 24, scope: !7)
+!19 = !DILocalVariable(name: "d", scope: !7, file: !1, line: 2, type: !20)
+!20 = !DIBasicType(name: "double", size: 64, align: 64, encoding: DW_ATE_float)
+!21 = !DILocation(line: 2, column: 10, scope: !7)
+!22 = !DILocalVariable(name: "u", scope: !7, file: !1, line: 3, type: !23)
+!23 = !DIBasicType(name: "long long unsigned int", size: 64, align: 64, encoding: DW_ATE_unsigned)
+!24 = !DILocation(line: 3, column: 22, scope: !7)
+!25 = !DILocalVariable(name: "i", scope: !7, file: !1, line: 4, type: !26)
+!26 = !DIBasicType(name: "long long int", size: 64, align: 64, encoding: DW_ATE_signed)
+!27 = !DILocation(line: 4, column: 20, scope: !7)
+!28 = !DILocation(line: 5, column: 3, scope: !7)
diff --git a/test/DebugInfo/X86/cu-ranges.ll b/test/DebugInfo/X86/cu-ranges.ll
new file mode 100644
index 0000000..fe2c390
--- /dev/null
+++ b/test/DebugInfo/X86/cu-ranges.ll
@@ -0,0 +1,80 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -split-dwarf-file=foo.dwo -O0 %t.ll -function-sections -mtriple=x86_64-unknown-linux-gnu -filetype=obj -o %t
+; RUN: llvm-dwarfdump -debug-abbrev %t | FileCheck --check-prefix=FUNCTION-SECTIONS %s
+; RUN: llvm-readobj --relocations %t | FileCheck --check-prefix=FUNCTION-SECTIONS-RELOCS %s
+
+; RUN: llc -split-dwarf-file=foo.dwo -O0 %t.ll -mtriple=x86_64-unknown-linux-gnu -filetype=obj -o %t
+; RUN: llvm-dwarfdump -debug-abbrev %t | FileCheck --check-prefix=NO-FUNCTION-SECTIONS %s
+
+; From:
+; int foo (int a) {
+;   return a+1;
+; }
+; int bar (int b) {
+;   return b+2;
+; }
+
+; With function sections enabled make sure that we have a DW_AT_ranges attribute.
+; FUNCTION-SECTIONS: DW_AT_ranges
+
+; Check that we have a relocation against the .debug_ranges section.
+; FUNCTION-SECTIONS-RELOCS: R_X86_64_32 .debug_ranges 0x0
+
+; Without function sections enabled make sure that we have no DW_AT_ranges attribute.
+; NO-FUNCTION-SECTIONS-NOT: DW_AT_ranges
+; NO-FUNCTION-SECTIONS: DW_AT_low_pc DW_FORM_addr
+; NO-FUNCTION-SECTIONS-NOT: DW_AT_ranges
+
+; Function Attrs: nounwind uwtable
+define i32 @foo(i32 %a) #0 !dbg !4 {
+entry:
+  %a.addr = alloca i32, align 4
+  store i32 %a, i32* %a.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %a.addr, metadata !13, metadata !DIExpression()), !dbg !14
+  %0 = load i32, i32* %a.addr, align 4, !dbg !14
+  %add = add nsw i32 %0, 1, !dbg !14
+  ret i32 %add, !dbg !14
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+; Function Attrs: nounwind uwtable
+define i32 @bar(i32 %b) #0 !dbg !9 {
+entry:
+  %b.addr = alloca i32, align 4
+  store i32 %b, i32* %b.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %b.addr, metadata !15, metadata !DIExpression()), !dbg !16
+  %0 = load i32, i32* %b.addr, align 4, !dbg !16
+  %add = add nsw i32 %0, 2, !dbg !16
+  ret i32 %add, !dbg !16
+}
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!10, !11}
+!llvm.ident = !{!12}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.5.0 (trunk 204164) (llvm/trunk 204183)", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "z.c", directory: "/usr/local/google/home/echristo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "foo", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 1, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "z.c", directory: "/usr/local/google/home/echristo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8, !8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = distinct !DISubprogram(name: "bar", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 2, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!10 = !{i32 2, !"Dwarf Version", i32 4}
+!11 = !{i32 1, !"Debug Info Version", i32 3}
+!12 = !{!"clang version 3.5.0 (trunk 204164) (llvm/trunk 204183)"}
+!13 = !DILocalVariable(name: "a", line: 1, arg: 1, scope: !4, file: !5, type: !8)
+!14 = !DILocation(line: 1, scope: !4)
+!15 = !DILocalVariable(name: "b", line: 2, arg: 1, scope: !9, file: !5, type: !8)
+!16 = !DILocation(line: 2, scope: !9)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/data_member_location.ll b/test/DebugInfo/X86/data_member_location.ll
new file mode 100644
index 0000000..ee3ebf1
--- /dev/null
+++ b/test/DebugInfo/X86/data_member_location.ll
@@ -0,0 +1,61 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-linux -O0 -o - -filetype=obj < %t.ll | llvm-dwarfdump -v -debug-info -| FileCheck %s
+; RUN: llc -mtriple=x86_64-linux -dwarf-version=2 -O0 -o - -filetype=obj < %t.ll | llvm-dwarfdump -v -debug-info -| FileCheck -check-prefix=DWARF2 %s
+
+; Generated from Clang with the following source:
+;
+; struct foo {
+;   char c;
+;   int i;
+; };
+; 
+; foo f;
+
+; CHECK: DW_AT_name {{.*}} "c"
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_data_member_location {{.*}} (0x00)
+
+; CHECK: DW_AT_name {{.*}} "i"
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_data_member_location {{.*}} (0x04)
+
+; DWARF2: DW_AT_name {{.*}} "c"
+; DWARF2-NOT: DW_TAG
+; DWARF2: DW_AT_data_member_location {{.*}} (DW_OP_plus_uconst 0x0)
+
+; DWARF2: DW_AT_name {{.*}} "i"
+; DWARF2-NOT: DW_TAG
+; DWARF2: DW_AT_data_member_location {{.*}} (DW_OP_plus_uconst 0x4)
+
+source_filename = "test/DebugInfo/X86/data_member_location.ll"
+
+%struct.foo = type { i8, i32 }
+
+@f = global %struct.foo zeroinitializer, align 4, !dbg !0
+
+!llvm.dbg.cu = !{!9}
+!llvm.module.flags = !{!13, !14}
+!llvm.ident = !{!15}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "f", scope: null, file: !2, line: 6, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "data_member_location.cpp", directory: "/tmp/dbginfo")
+!3 = !DICompositeType(tag: DW_TAG_structure_type, name: "foo", file: !2, line: 1, size: 64, align: 32, elements: !4, identifier: "_ZTS3foo")
+!4 = !{!5, !7}
+!5 = !DIDerivedType(tag: DW_TAG_member, name: "c", scope: !3, file: !2, line: 2, baseType: !6, size: 8, align: 8)
+!6 = !DIBasicType(name: "char", size: 8, align: 8, encoding: DW_ATE_signed_char)
+!7 = !DIDerivedType(tag: DW_TAG_member, name: "i", scope: !3, file: !2, line: 3, baseType: !8, size: 32, align: 32, offset: 32)
+!8 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.4 ", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !10, retainedTypes: !11, globals: !12, imports: !10)
+!10 = !{}
+!11 = !{!3}
+!12 = !{!0}
+!13 = !{i32 2, !"Dwarf Version", i32 4}
+!14 = !{i32 1, !"Debug Info Version", i32 3}
+!15 = !{!"clang version 3.4 "}
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/dbg-byval-parameter.ll b/test/DebugInfo/X86/dbg-byval-parameter.ll
new file mode 100644
index 0000000..cd67996
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-byval-parameter.ll
@@ -0,0 +1,57 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -march=x86 -asm-verbose < %t.ll | grep DW_TAG_formal_parameter
+
+
+%struct.Pt = type { double, double }
+%struct.Rect = type { %struct.Pt, %struct.Pt }
+
+define double @foo(%struct.Rect* byval %my_r0) nounwind ssp !dbg !1 {
+entry:
+  %retval = alloca double                         ; <double*> [#uses=2]
+  %0 = alloca double                              ; <double*> [#uses=2]
+  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
+  call void @llvm.dbg.declare(metadata %struct.Rect* %my_r0, metadata !0, metadata !DIExpression()), !dbg !15
+  %1 = getelementptr inbounds %struct.Rect, %struct.Rect* %my_r0, i32 0, i32 0, !dbg !16 ; <%struct.Pt*> [#uses=1]
+  %2 = getelementptr inbounds %struct.Pt, %struct.Pt* %1, i32 0, i32 0, !dbg !16 ; <double*> [#uses=1]
+  %3 = load double, double* %2, align 8, !dbg !16         ; <double> [#uses=1]
+  store double %3, double* %0, align 8, !dbg !16
+  %4 = load double, double* %0, align 8, !dbg !16         ; <double> [#uses=1]
+  store double %4, double* %retval, align 8, !dbg !16
+  br label %return, !dbg !16
+
+return:                                           ; preds = %entry
+  %retval1 = load double, double* %retval, !dbg !16       ; <double> [#uses=1]
+  ret double %retval1, !dbg !16
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!3}
+!llvm.module.flags = !{!21}
+
+!0 = !DILocalVariable(name: "my_r0", line: 11, arg: 1, scope: !1, file: !2, type: !7)
+!1 = distinct !DISubprogram(name: "foo", linkageName: "foo", line: 11, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !3, file: !19, scope: !2, type: !4)
+!2 = !DIFile(filename: "b2.c", directory: "/tmp/")
+!3 = distinct !DICompileUnit(language: DW_LANG_C89, producer: "4.2.1 (Based on Apple Inc. build 5658) (LLVM build)", isOptimized: false, emissionKind: FullDebug, file: !19, enums: !20, retainedTypes: !20, imports:  null)
+!4 = !DISubroutineType(types: !5)
+!5 = !{!6, !7}
+!6 = !DIBasicType(tag: DW_TAG_base_type, name: "double", size: 64, align: 64, encoding: DW_ATE_float)
+!7 = !DICompositeType(tag: DW_TAG_structure_type, name: "Rect", line: 6, size: 256, align: 64, file: !19, scope: !2, elements: !8)
+!8 = !{!9, !14}
+!9 = !DIDerivedType(tag: DW_TAG_member, name: "P1", line: 7, size: 128, align: 64, file: !19, scope: !7, baseType: !10)
+!10 = !DICompositeType(tag: DW_TAG_structure_type, name: "Pt", line: 1, size: 128, align: 64, file: !19, scope: !2, elements: !11)
+!11 = !{!12, !13}
+!12 = !DIDerivedType(tag: DW_TAG_member, name: "x", line: 2, size: 64, align: 64, file: !19, scope: !10, baseType: !6)
+!13 = !DIDerivedType(tag: DW_TAG_member, name: "y", line: 3, size: 64, align: 64, offset: 64, file: !19, scope: !10, baseType: !6)
+!14 = !DIDerivedType(tag: DW_TAG_member, name: "P2", line: 8, size: 128, align: 64, offset: 128, file: !19, scope: !7, baseType: !10)
+!15 = !DILocation(line: 11, scope: !1)
+!16 = !DILocation(line: 12, scope: !17)
+!17 = distinct !DILexicalBlock(line: 11, column: 0, file: !19, scope: !1)
+!19 = !DIFile(filename: "b2.c", directory: "/tmp/")
+!20 = !{}
+!21 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/dbg-declare-alloca.ll b/test/DebugInfo/X86/dbg-declare-alloca.ll
new file mode 100644
index 0000000..883b074
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-declare-alloca.ll
@@ -0,0 +1,66 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll | FileCheck %s
+; RUN: llc -mtriple=%triple < %t.ll -filetype=obj | llvm-dwarfdump -v - --debug-info | FileCheck %s --check-prefix=DWARF
+
+; This should use the frame index side table for allocas, not DBG_VALUE
+; instructions. For SDAG ISel, this test would see an SDNode materializing the
+; argument to escape_foo and we'd get DBG_VALUE MachineInstr.
+
+; CHECK-LABEL: use_dbg_declare:
+; CHECK-NOT: #DEBUG_VALUE
+
+; DWARF: DW_TAG_variable
+; DWARF-NEXT:              DW_AT_location [DW_FORM_exprloc]      (DW_OP_fbreg +0)
+; DWARF-NEXT:              DW_AT_name [DW_FORM_strp]     ( {{.*}} = "o")
+
+
+; ModuleID = 't.c'
+source_filename = "t.c"
+target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+%struct.Foo = type { i32 }
+
+; Function Attrs: noinline nounwind uwtable
+define void @use_dbg_declare() #0 !dbg !7 {
+entry:
+  %o = alloca %struct.Foo, align 4
+  call void @llvm.dbg.declare(metadata %struct.Foo* %o, metadata !10, metadata !15), !dbg !16
+  call void @escape_foo(%struct.Foo* %o), !dbg !17
+  ret void, !dbg !18
+}
+
+; Function Attrs: nounwind readnone speculatable
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+declare void @escape_foo(%struct.Foo*)
+
+attributes #0 = { noinline nounwind uwtable }
+attributes #1 = { nounwind readnone speculatable }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4, !5}
+!llvm.ident = !{!6}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 6.0.0 ", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "t.c", directory: "C:\5Csrc\5Cllvm-project\5Cbuild")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{i32 1, !"wchar_size", i32 4}
+!6 = !{!"clang version 6.0.0 "}
+!7 = distinct !DISubprogram(name: "use_dbg_declare", scope: !1, file: !1, line: 3, type: !8, isLocal: false, isDefinition: true, scopeLine: 3, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!8 = !DISubroutineType(types: !9)
+!9 = !{null}
+!10 = !DILocalVariable(name: "o", scope: !7, file: !1, line: 4, type: !11)
+!11 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "Foo", file: !1, line: 1, size: 32, elements: !12)
+!12 = !{!13}
+!13 = !DIDerivedType(tag: DW_TAG_member, name: "x", scope: !11, file: !1, line: 1, baseType: !14, size: 32)
+!14 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!15 = !DIExpression()
+!16 = !DILocation(line: 4, column: 14, scope: !7)
+!17 = !DILocation(line: 5, column: 3, scope: !7)
+!18 = !DILocation(line: 6, column: 1, scope: !7)
diff --git a/test/DebugInfo/X86/dbg-declare-arg.ll b/test/DebugInfo/X86/dbg-declare-arg.ll
new file mode 100644
index 0000000..cfcd462
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-declare-arg.ll
@@ -0,0 +1,149 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 -fast-isel=true  -filetype=obj -o - %t.ll | llvm-dwarfdump -v - | FileCheck %s
+
+target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"
+target triple = "spir64-unknown-unknown"
+; rdar://problem/9321650
+
+; C++ source:
+; class A { public: int x; int y; int z; int o; ~A() { x = 1; }};
+; 
+; A foo(int i) {
+;   int j = 0;
+;   if (i == 42) {
+;     j = i + 1;
+;   };
+;   A my_a;
+;   my_a.x = j;
+;   return my_a;
+; }
+
+; CHECK: DW_AT_name {{.*}}"j"
+; CHECK: DW_TAG_variable  
+; CHECK-NEXT:   DW_AT_location [DW_FORM_sec_offset] (
+; CHECK-NEXT:     0x{{.*}}, 0x{{.*}}: DW_OP_breg7 RSP+8, DW_OP_deref)
+; CHECK-NEXT:   DW_AT_name {{.*}}"my_a"
+
+%class.A = type { i32, i32, i32, i32 }
+
+define void @_Z3fooi(%class.A* sret %agg.result, i32 %i) ssp !dbg !19 {
+entry:
+  %i.addr = alloca i32, align 4
+  %j = alloca i32, align 4
+  %nrvo = alloca i1
+  %cleanup.dest.slot = alloca i32
+  store i32 %i, i32* %i.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %i.addr, metadata !26, metadata !DIExpression()), !dbg !27
+  call void @llvm.dbg.declare(metadata i32* %j, metadata !28, metadata !DIExpression()), !dbg !30
+  store i32 0, i32* %j, align 4, !dbg !31
+  %tmp = load i32, i32* %i.addr, align 4, !dbg !32
+  %cmp = icmp eq i32 %tmp, 42, !dbg !32
+  br i1 %cmp, label %if.then, label %if.end, !dbg !32
+
+if.then:                                          ; preds = %entry
+  %tmp1 = load i32, i32* %i.addr, align 4, !dbg !33
+  %add = add nsw i32 %tmp1, 1, !dbg !33
+  store i32 %add, i32* %j, align 4, !dbg !33
+  br label %if.end, !dbg !35
+
+if.end:                                           ; preds = %if.then, %entry
+  store i1 false, i1* %nrvo, !dbg !36
+  call void @llvm.dbg.declare(metadata %class.A* %agg.result, metadata !37, metadata !DIExpression()), !dbg !39
+  %tmp2 = load i32, i32* %j, align 4, !dbg !40
+  %x = getelementptr inbounds %class.A, %class.A* %agg.result, i32 0, i32 0, !dbg !40
+  store i32 %tmp2, i32* %x, align 4, !dbg !40
+  store i1 true, i1* %nrvo, !dbg !41
+  store i32 1, i32* %cleanup.dest.slot
+  %nrvo.val = load i1, i1* %nrvo, !dbg !42
+  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused, !dbg !42
+
+nrvo.unused:                                      ; preds = %if.end
+  call void @_ZN1AD1Ev(%class.A* %agg.result), !dbg !42
+  br label %nrvo.skipdtor, !dbg !42
+
+nrvo.skipdtor:                                    ; preds = %nrvo.unused, %if.end
+  ret void, !dbg !42
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+define linkonce_odr void @_ZN1AD1Ev(%class.A* %this) unnamed_addr ssp align 2 !dbg !22 {
+entry:
+  %this.addr = alloca %class.A*, align 8
+  store %class.A* %this, %class.A** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %class.A** %this.addr, metadata !43, metadata !DIExpression()), !dbg !44
+  %this1 = load %class.A*, %class.A** %this.addr
+  call void @_ZN1AD2Ev(%class.A* %this1), !dbg !53
+  ret void, !dbg !45
+}
+
+define linkonce_odr void @_ZN1AD2Ev(%class.A* %this) unnamed_addr nounwind ssp align 2 !dbg !25 {
+entry:
+  %this.addr = alloca %class.A*, align 8
+  store %class.A* %this, %class.A** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %class.A** %this.addr, metadata !46, metadata !DIExpression()), !dbg !47
+  %this1 = load %class.A*, %class.A** %this.addr
+  %x = getelementptr inbounds %class.A, %class.A* %this1, i32 0, i32 0, !dbg !48
+  store i32 1, i32* %x, align 4, !dbg !48
+  ret void, !dbg !48
+}
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!52}
+
+!0 = !DISubprogram(name: "~A", line: 2, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, file: !51, scope: !1, type: !11)
+!1 = !DICompositeType(tag: DW_TAG_class_type, name: "A", line: 2, size: 128, align: 32, file: !51, scope: !2, elements: !4)
+!2 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.0 (trunk 130127)", isOptimized: false, emissionKind: FullDebug, file: !51, enums: !{}, retainedTypes: !{})
+!3 = !DIFile(filename: "a.cc", directory: "/private/tmp")
+!4 = !{!5, !7, !8, !9, !0, !10, !14}
+!5 = !DIDerivedType(tag: DW_TAG_member, name: "x", line: 2, size: 32, align: 32, file: !51, scope: !3, baseType: !6)
+!6 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!7 = !DIDerivedType(tag: DW_TAG_member, name: "y", line: 2, size: 32, align: 32, offset: 32, file: !51, scope: !3, baseType: !6)
+!8 = !DIDerivedType(tag: DW_TAG_member, name: "z", line: 2, size: 32, align: 32, offset: 64, file: !51, scope: !3, baseType: !6)
+!9 = !DIDerivedType(tag: DW_TAG_member, name: "o", line: 2, size: 32, align: 32, offset: 96, file: !51, scope: !3, baseType: !6)
+!10 = !DISubprogram(name: "A", line: 2, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false, file: !51, scope: !1, type: !11)
+!11 = !DISubroutineType(types: !12)
+!12 = !{null, !13}
+!13 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, flags: DIFlagArtificial, file: !3, baseType: !1)
+!14 = !DISubprogram(name: "A", line: 2, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false, file: !51, scope: !1, type: !15)
+!15 = !DISubroutineType(types: !16)
+!16 = !{null, !13, !17}
+!17 = !DIDerivedType(tag: DW_TAG_reference_type, scope: !2, baseType: !18)
+!18 = !DIDerivedType(tag: DW_TAG_const_type, file: !3, baseType: !1)
+!19 = distinct !DISubprogram(name: "foo", linkageName: "_Z3fooi", line: 4, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !2, file: !51, scope: !3, type: !20)
+!20 = !DISubroutineType(types: !21)
+!21 = !{!1}
+!22 = distinct !DISubprogram(name: "~A", linkageName: "_ZN1AD1Ev", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !2, file: !51, scope: !3, type: !23)
+!23 = !DISubroutineType(types: !24)
+!24 = !{null}
+!25 = distinct !DISubprogram(name: "~A", linkageName: "_ZN1AD2Ev", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !2, file: !51, scope: !3, type: !23)
+!26 = !DILocalVariable(name: "i", line: 4, arg: 1, scope: !19, file: !3, type: !6)
+!27 = !DILocation(line: 4, column: 11, scope: !19)
+!28 = !DILocalVariable(name: "j", line: 5, scope: !29, file: !3, type: !6)
+!29 = distinct !DILexicalBlock(line: 4, column: 14, file: !51, scope: !19)
+!30 = !DILocation(line: 5, column: 7, scope: !29)
+!31 = !DILocation(line: 5, column: 12, scope: !29)
+!32 = !DILocation(line: 6, column: 3, scope: !29)
+!33 = !DILocation(line: 7, column: 5, scope: !34)
+!34 = distinct !DILexicalBlock(line: 6, column: 16, file: !51, scope: !29)
+!35 = !DILocation(line: 8, column: 3, scope: !34)
+!36 = !DILocation(line: 9, column: 9, scope: !29)
+!37 = !DILocalVariable(name: "my_a", line: 9, scope: !29, file: !3, type: !38)
+!38 = !DIDerivedType(tag: DW_TAG_reference_type, file: !3, baseType: !1)
+!39 = !DILocation(line: 9, column: 5, scope: !29)
+!40 = !DILocation(line: 10, column: 3, scope: !29)
+!41 = !DILocation(line: 11, column: 3, scope: !29)
+!42 = !DILocation(line: 12, column: 1, scope: !29)
+!43 = !DILocalVariable(name: "this", line: 2, arg: 1, flags: DIFlagArtificial, scope: !22, file: !3, type: !13)
+!44 = !DILocation(line: 2, column: 47, scope: !22)
+!45 = !DILocation(line: 2, column: 61, scope: !22)
+!46 = !DILocalVariable(name: "this", line: 2, arg: 1, flags: DIFlagArtificial, scope: !25, file: !3, type: !13)
+!47 = !DILocation(line: 2, column: 47, scope: !25)
+!48 = !DILocation(line: 2, column: 54, scope: !49)
+!49 = distinct !DILexicalBlock(line: 2, column: 52, file: !51, scope: !25)
+!51 = !DIFile(filename: "a.cc", directory: "/private/tmp")
+!52 = !{i32 1, !"Debug Info Version", i32 3}
+!53 = !DILocation(line: 0, scope: !22)
diff --git a/test/DebugInfo/X86/dbg-declare.ll b/test/DebugInfo/X86/dbg-declare.ll
new file mode 100644
index 0000000..1851d64
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-declare.ll
@@ -0,0 +1,73 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc < %t.ll -O0 -mtriple x86_64-apple-darwin | FileCheck %s
+; RUN: llc < %t.ll -O0 -mtriple x86_64-apple-darwin -filetype=obj \
+; RUN:     | llvm-dwarfdump -v - --debug-info | FileCheck %s --check-prefix=DWARF
+; <rdar://problem/11134152>
+
+; CHECK-LABEL: _foo:
+; CHECK-NOT: #DEBUG_VALUE
+
+; "[DW_FORM_exprloc] <0x2> 91 XX" means fbreg uleb(XX)
+; DWARF-LABEL: DW_TAG_formal_parameter
+; DWARF-NEXT:              DW_AT_location [DW_FORM_exprloc]      (DW_OP_fbreg +16)
+; DWARF-NEXT:              DW_AT_name [DW_FORM_strp]     ( {{.*}} = "x")
+
+; FIXME: There is no debug info to describe "a".
+
+define i32 @foo(i32* %x) nounwind uwtable ssp !dbg !5 {
+entry:
+  %x.addr = alloca i32*, align 8
+  %saved_stack = alloca i8*
+  %cleanup.dest.slot = alloca i32
+  store i32* %x, i32** %x.addr, align 8
+  call void @llvm.dbg.declare(metadata i32** %x.addr, metadata !14, metadata !DIExpression()), !dbg !15
+  %0 = load i32*, i32** %x.addr, align 8, !dbg !16
+  %1 = load i32, i32* %0, align 4, !dbg !16
+  %2 = zext i32 %1 to i64, !dbg !16
+  %3 = call i8* @llvm_stacksave(), !dbg !16
+  store i8* %3, i8** %saved_stack, !dbg !16
+  %vla = alloca i8, i64 %2, align 16, !dbg !16
+  call void @llvm.dbg.declare(metadata i8* %vla, metadata !18, metadata !DIExpression()), !dbg !23
+  store i32 1, i32* %cleanup.dest.slot
+  %4 = load i8*, i8** %saved_stack, !dbg !24
+  call void @llvm_stackrestore(i8* %4), !dbg !24
+  ret i32 0, !dbg !25
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+declare i8* @llvm_stacksave() nounwind
+
+declare void @llvm_stackrestore(i8*) nounwind
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!27}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.1 (trunk 153698)", isOptimized: false, emissionKind: FullDebug, file: !26, enums: !1, retainedTypes: !1, globals: !1)
+!1 = !{}
+!5 = distinct !DISubprogram(name: "foo", line: 6, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, file: !26, scope: !0, type: !7)
+!6 = !DIFile(filename: "20020104-2.c", directory: "/Volumes/Sandbox/llvm")
+!7 = !DISubroutineType(types: !8)
+!8 = !{!9, !10}
+!9 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!10 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !11)
+!11 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !9)
+!14 = !DILocalVariable(name: "x", line: 5, arg: 1, scope: !5, file: !6, type: !10)
+!15 = !DILocation(line: 5, column: 21, scope: !5)
+!16 = !DILocation(line: 7, column: 13, scope: !17)
+!17 = distinct !DILexicalBlock(line: 6, column: 1, file: !26, scope: !5)
+!18 = !DILocalVariable(name: "a", line: 7, scope: !17, file: !6, type: !19)
+!19 = !DICompositeType(tag: DW_TAG_array_type, align: 8, baseType: !20, elements: !21)
+!20 = !DIBasicType(tag: DW_TAG_base_type, name: "char", size: 8, align: 8, encoding: DW_ATE_signed_char)
+!21 = !{!22}
+!22 = !DISubrange(count: -1)
+!23 = !DILocation(line: 7, column: 8, scope: !17)
+!24 = !DILocation(line: 9, column: 1, scope: !17)
+!25 = !DILocation(line: 8, column: 3, scope: !17)
+!26 = !DIFile(filename: "20020104-2.c", directory: "/Volumes/Sandbox/llvm")
+!27 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/dbg-prolog-end.ll b/test/DebugInfo/X86/dbg-prolog-end.ll
new file mode 100644
index 0000000..2c5aa87
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-prolog-end.ll
@@ -0,0 +1,68 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O0 < %t.ll | FileCheck %s
+target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"
+target triple = "spir64-unknown-unknown"
+
+;CHECK-LABEL: foo:
+;CHECK: .loc	1 2 11 prologue_end
+define i32 @foo(i32 %i) nounwind ssp !dbg !1 {
+entry:
+  %i.addr = alloca i32, align 4
+  %j = alloca i32, align 4
+  store i32 %i, i32* %i.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %i.addr, metadata !7, metadata !DIExpression()), !dbg !8
+  call void @llvm.dbg.declare(metadata i32* %j, metadata !9, metadata !DIExpression()), !dbg !11
+  store i32 2, i32* %j, align 4, !dbg !12
+  %tmp = load i32, i32* %j, align 4, !dbg !13
+  %inc = add nsw i32 %tmp, 1, !dbg !13
+  store i32 %inc, i32* %j, align 4, !dbg !13
+  %tmp1 = load i32, i32* %j, align 4, !dbg !14
+  %tmp2 = load i32, i32* %i.addr, align 4, !dbg !14
+  %add = add nsw i32 %tmp1, %tmp2, !dbg !14
+  store i32 %add, i32* %j, align 4, !dbg !14
+  %tmp3 = load i32, i32* %j, align 4, !dbg !15
+  ret i32 %tmp3, !dbg !15
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+;CHECK-LABEL: main:
+;CHECK: .loc 1 0 0 prologue_end
+
+define i32 @main() nounwind ssp !dbg !6 {
+entry:
+  %retval = alloca i32, align 4
+  store i32 0, i32* %retval, !dbg !22
+  %call = call i32 @foo(i32 21), !dbg !16
+  ret i32 %call, !dbg !16
+}
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!21}
+!18 = !{!1, !6}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.0 (trunk 131100)", isOptimized: false, emissionKind: FullDebug, file: !19, enums: !20, retainedTypes: !20, imports:  null)
+!1 = distinct !DISubprogram(name: "foo", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 1, file: !19, scope: !2, type: !3)
+!2 = !DIFile(filename: "/tmp/a.c", directory: "/private/tmp")
+!3 = !DISubroutineType(types: !4)
+!4 = !{!5}
+!5 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!6 = distinct !DISubprogram(name: "main", line: 7, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !0, scopeLine: 7, file: !19, scope: !2, type: !3)
+!7 = !DILocalVariable(name: "i", line: 1, arg: 1, scope: !1, file: !2, type: !5)
+!8 = !DILocation(line: 1, column: 13, scope: !1)
+!9 = !DILocalVariable(name: "j", line: 2, scope: !10, file: !2, type: !5)
+!10 = distinct !DILexicalBlock(line: 1, column: 16, file: !19, scope: !1)
+!11 = !DILocation(line: 2, column: 6, scope: !10)
+!12 = !DILocation(line: 2, column: 11, scope: !10)
+!13 = !DILocation(line: 3, column: 2, scope: !10)
+!14 = !DILocation(line: 4, column: 2, scope: !10)
+!15 = !DILocation(line: 5, column: 2, scope: !10)
+!16 = !DILocation(line: 8, column: 2, scope: !17)
+!17 = distinct !DILexicalBlock(line: 7, column: 12, file: !19, scope: !6)
+!19 = !DIFile(filename: "/tmp/a.c", directory: "/private/tmp")
+!20 = !{}
+!21 = !{i32 1, !"Debug Info Version", i32 3}
+!22 = !DILocation(line: 0, column: 0, scope: !17)
diff --git a/test/DebugInfo/X86/dbg-value-const-byref.ll b/test/DebugInfo/X86/dbg-value-const-byref.ll
new file mode 100644
index 0000000..8f1443a
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-value-const-byref.ll
@@ -0,0 +1,95 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -O1 -filetype=obj -o - %t.ll | llvm-dwarfdump -all - | FileCheck %s
+; Generated with -O1 from:
+; int f1();
+; void f2(int*);
+; int f3(int);
+;
+; int foo() {
+;   int i = 3;
+;   f3(i);
+;   i = 7;
+;   i = f1();
+;   f2(&i);
+;   return 0;
+; }
+;
+; Test that we generate valid debug info for optimized code,
+; particularly variables that are described as constants and passed
+; by reference.
+; rdar://problem/14874886
+;
+; CHECK: .debug_info contents:
+; CHECK: DW_TAG_variable
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_location {{.*}}({{.*}}
+; CHECK-NEXT:  0x{{0*.*}}, [[C1:0x.*]]): DW_OP_consts +3
+; CHECK-NEXT:      [[C1]], [[C2:0x.*]]): DW_OP_consts +7
+; CHECK-NEXT:      [[C2]], [[R1:0x.*]]): DW_OP_reg0 RAX
+; CHECK-NEXT:      [[R1]], [[R2:0x.*]]): DW_OP_breg7 RSP+4)
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_name{{.*}}"i"
+
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind ssp uwtable
+define i32 @foo() #0 !dbg !4 {
+entry:
+  %i = alloca i32, align 4
+  call void @llvm.dbg.value(metadata i32 3, metadata !10, metadata !DIExpression()), !dbg !15
+  %call = call i32 @f3(i32 3) #3, !dbg !16
+  call void @llvm.dbg.value(metadata i32 7, metadata !10, metadata !DIExpression()), !dbg !18
+  %call1 = call i32 (...) @f1() #3, !dbg !19
+  call void @llvm.dbg.value(metadata i32 %call1, metadata !10, metadata !DIExpression()), !dbg !19
+  store i32 %call1, i32* %i, align 4, !dbg !19, !tbaa !20
+  call void @llvm.dbg.value(metadata i32* %i, metadata !10, metadata !DIExpression(DW_OP_deref)), !dbg !24
+  call void @f2(i32* %i) #3, !dbg !24
+  ret i32 0, !dbg !25
+}
+
+declare i32 @f3(i32)
+
+declare i32 @f1(...)
+
+declare void @f2(i32*)
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #2
+
+attributes #0 = { nounwind ssp uwtable }
+attributes #2 = { nounwind readnone }
+attributes #3 = { nounwind }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!11, !12}
+!llvm.ident = !{!13}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.5.0 ", isOptimized: true, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "dbg-value-const-byref.c", directory: "")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "foo", line: 5, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: true, unit: !0, scopeLine: 5, file: !1, scope: !5, type: !6, retainedNodes: !9)
+!5 = !DIFile(filename: "dbg-value-const-byref.c", directory: "")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = !{!10}
+!10 = !DILocalVariable(name: "i", line: 6, scope: !4, file: !5, type: !8)
+!11 = !{i32 2, !"Dwarf Version", i32 2}
+!12 = !{i32 1, !"Debug Info Version", i32 3}
+!13 = !{!"clang version 3.5.0 "}
+!14 = !{i32 3}
+!15 = !DILocation(line: 6, scope: !4)
+!16 = !DILocation(line: 7, scope: !4)
+!17 = !{i32 7}
+!18 = !DILocation(line: 8, scope: !4)
+!19 = !DILocation(line: 9, scope: !4)
+!20 = !{!21, !21, i64 0}
+!21 = !{!"int", !22, i64 0}
+!22 = !{!"omnipotent char", !23, i64 0}
+!23 = !{!"Simple C/C++ TBAA"}
+!24 = !DILocation(line: 10, scope: !4)
+!25 = !DILocation(line: 11, scope: !4)
diff --git a/test/DebugInfo/X86/dbg-value-frame-index.ll b/test/DebugInfo/X86/dbg-value-frame-index.ll
new file mode 100644
index 0000000..12b00e0
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-value-frame-index.ll
@@ -0,0 +1,49 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-unknown-unknown -o - %t.ll | FileCheck %s
+; RUN: llc -mtriple=x86_64-unknown-unknown -filetype=obj < %t.ll \
+; RUN:   | llvm-dwarfdump -v - | FileCheck %s --check-prefix=DWARF
+
+define i1 @test() !dbg !4 {
+entry:
+  %end = alloca i64, align 8
+  br label %while.cond
+
+while.cond:
+  call void @llvm.dbg.value(metadata i64* %end, metadata !5, metadata !6), !dbg !7
+  %call = call i1 @fn(i64* %end, i64* %end, i64* null, i8* null, i64 0, i64* null, i32* null, i8* null), !dbg !7
+  br label %while.body
+
+while.body:
+  br i1 0, label %while.end, label %while.cond
+
+while.end:
+  ret i1 true
+}
+
+; CHECK-LABEL: test
+; CHECK:       #DEBUG_VALUE: test:w <- [DW_OP_plus_uconst 8, DW_OP_deref] $rsp
+; DWARF:  DW_AT_location [DW_FORM_sec_offset] (
+; DWARF-NEXT:   {{.*}}, {{.*}}: DW_OP_breg7 RSP+8)
+
+declare i1 @fn(i64*, i64*, i64*, i8*, i64, i64*, i32*, i8*)
+declare void @llvm.dbg.value(metadata, metadata, metadata)
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!2,!3}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 4.0.0", emissionKind: FullDebug)
+!1 = !DIFile(filename: "test.c", directory: "/")
+!2 = !{i32 2, !"Dwarf Version", i32 4}
+!3 = !{i32 2, !"Debug Info Version", i32 3}
+!4 = distinct !DISubprogram(name: "test", type: !10, unit: !0)
+!5 = !DILocalVariable(name: "w", scope: !4, type: !9)
+!6 = !DIExpression(DW_OP_deref)
+!7 = !DILocation(line: 210, column: 12, scope: !4)
+!8 = !{!9}
+!9 = !DIBasicType(name: "bool", size: 8, encoding: DW_ATE_boolean)
+!10 = !DISubroutineType(types: !8)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/dbg-value-isel.ll b/test/DebugInfo/X86/dbg-value-isel.ll
new file mode 100644
index 0000000..c3440e6
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-value-isel.ll
@@ -0,0 +1,107 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll | FileCheck %s
+target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"
+target triple = "spir64-unknown-unknown"
+; PR 9879
+
+; CHECK: #DEBUG_VALUE: tid <-
+%0 = type { i8*, i8*, i8*, i8*, i32 }
+
+@sgv = internal addrspace(2) constant [1 x i8] zeroinitializer
+@fgv = internal addrspace(2) constant [1 x i8] zeroinitializer
+
+define void @__OpenCL_nbt02_kernel(i32 addrspace(1)* %ip) nounwind !dbg !0 {
+entry:
+  call void @llvm.dbg.value(metadata i32 addrspace(1)* %ip, metadata !8, metadata !DIExpression()), !dbg !9
+  %0 = call <4 x i32> @__amdil_get_local_id_int() nounwind
+  %1 = extractelement <4 x i32> %0, i32 0
+  br label %2
+
+; <label>:2                                       ; preds = %entry
+  %3 = phi i32 [ %1, %entry ]
+  br label %4
+
+; <label>:4                                       ; preds = %2
+  %5 = phi i32 [ %3, %2 ]
+  br label %get_local_id.exit
+
+get_local_id.exit:                                ; preds = %4
+  %6 = phi i32 [ %5, %4 ]
+  call void @llvm.dbg.value(metadata i32 %6, metadata !10, metadata !DIExpression()), !dbg !12
+  %7 = call <4 x i32> @__amdil_get_global_id_int() nounwind, !dbg !12
+  %8 = extractelement <4 x i32> %7, i32 0, !dbg !12
+  br label %9
+
+; <label>:9                                       ; preds = %get_local_id.exit
+  %10 = phi i32 [ %8, %get_local_id.exit ]
+  br label %11
+
+; <label>:11                                      ; preds = %9
+  %12 = phi i32 [ %10, %9 ]
+  br label %get_global_id.exit
+
+get_global_id.exit:                               ; preds = %11
+  %13 = phi i32 [ %12, %11 ]
+  call void @llvm.dbg.value(metadata i32 %13, metadata !13, metadata !DIExpression()), !dbg !14
+  %14 = call <4 x i32> @__amdil_get_local_size_int() nounwind
+  %15 = extractelement <4 x i32> %14, i32 0
+  br label %16
+
+; <label>:16                                      ; preds = %get_global_id.exit
+  %17 = phi i32 [ %15, %get_global_id.exit ]
+  br label %18
+
+; <label>:18                                      ; preds = %16
+  %19 = phi i32 [ %17, %16 ]
+  br label %get_local_size.exit
+
+get_local_size.exit:                              ; preds = %18
+  %20 = phi i32 [ %19, %18 ]
+  call void @llvm.dbg.value(metadata i32 %20, metadata !15, metadata !DIExpression()), !dbg !16
+  %tmp5 = add i32 %6, %13, !dbg !17
+  %tmp7 = add i32 %tmp5, %20, !dbg !17
+  store i32 %tmp7, i32 addrspace(1)* %ip, align 4, !dbg !17
+  br label %return, !dbg !17
+
+return:                                           ; preds = %get_local_size.exit
+  ret void, !dbg !18
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+declare <4 x i32> @__amdil_get_local_size_int() nounwind
+
+declare <4 x i32> @__amdil_get_local_id_int() nounwind
+
+declare <4 x i32> @__amdil_get_global_id_int() nounwind
+
+declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!22}
+
+!0 = distinct !DISubprogram(name: "__OpenCL_nbt02_kernel", linkageName: "__OpenCL_nbt02_kernel", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !2, file: !20, scope: !1, type: !3)
+!1 = !DIFile(filename: "OCLlLwTXZ.cl", directory: "/tmp")
+!2 = distinct !DICompileUnit(language: DW_LANG_C89, producer: "clc", isOptimized: false, emissionKind: FullDebug, file: !20, enums: !21, retainedTypes: !21, imports:  null)
+!3 = !DISubroutineType(types: !4)
+!4 = !{null, !5}
+!5 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align:64, scope: !2, baseType: !6)
+!6 = !DIDerivedType(tag: DW_TAG_typedef, name: "uint", file: !20, scope: !2, baseType: !7)
+!7 = !DIBasicType(tag: DW_TAG_base_type, name: "unsigned int", size: 32, align: 32, encoding: DW_ATE_unsigned)
+!8 = !DILocalVariable(name: "ip", line: 1, arg: 1, scope: !0, file: !1, type: !5)
+!9 = !DILocation(line: 1, column: 32, scope: !0)
+!10 = !DILocalVariable(name: "tid", line: 3, scope: !11, file: !1, type: !6)
+!11 = distinct !DILexicalBlock(line: 2, column: 1, file: !1, scope: !0)
+!12 = !DILocation(line: 5, column: 24, scope: !11)
+!13 = !DILocalVariable(name: "gid", line: 3, scope: !11, file: !1, type: !6)
+!14 = !DILocation(line: 6, column: 25, scope: !11)
+!15 = !DILocalVariable(name: "lsz", line: 3, scope: !11, file: !1, type: !6)
+!16 = !DILocation(line: 7, column: 26, scope: !11)
+!17 = !DILocation(line: 9, column: 24, scope: !11)
+!18 = !DILocation(line: 10, column: 1, scope: !0)
+!20 = !DIFile(filename: "OCLlLwTXZ.cl", directory: "/tmp")
+!21 = !{}
+!22 = !{i32 1, !"Debug Info Version", i32 3}
diff --git a/test/DebugInfo/X86/dbg-value-location.ll b/test/DebugInfo/X86/dbg-value-location.ll
new file mode 100644
index 0000000..7fc834f
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-value-location.ll
@@ -0,0 +1,82 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj %t.ll -o - | llvm-dwarfdump -v -debug-info - | FileCheck %s
+; RUN: llc -mtriple=%triple -filetype=obj %t.ll -regalloc=basic -o - | llvm-dwarfdump -v -debug-info - | FileCheck %s
+target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"
+target triple = "spir64-unknown-unknown"
+; Test that the type for the formal parameter "var" makes it into the debug info.
+; rdar://8950491
+
+;CHECK: DW_TAG_formal_parameter
+;CHECK-NEXT: DW_AT_location
+;CHECK-NEXT: DW_AT_name {{.*}} "var"
+;CHECK-NEXT: DW_AT_decl_file
+;CHECK-NEXT: DW_AT_decl_line
+;CHECK-NEXT: DW_AT_type
+
+@dfm = external global i32, align 4
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+define i32 @foo(i32 %dev, i64 %cmd, i8* %data, i32 %data2) nounwind optsize ssp !dbg !0 {
+entry:
+  call void @llvm.dbg.value(metadata i32 %dev, metadata !12, metadata !DIExpression()), !dbg !13
+  %tmp.i = load i32, i32* @dfm, align 4, !dbg !14
+  %cmp.i = icmp eq i32 %tmp.i, 0, !dbg !14
+  br i1 %cmp.i, label %if.else, label %if.end.i, !dbg !14
+
+if.end.i:                                         ; preds = %entry
+  switch i64 %cmd, label %if.then [
+    i64 2147772420, label %bb.i
+    i64 536897538, label %bb116.i
+  ], !dbg !22
+
+bb.i:                                             ; preds = %if.end.i
+  unreachable
+
+bb116.i:                                          ; preds = %if.end.i
+  unreachable
+
+if.then:                                          ; preds = %if.end.i
+  ret i32 undef, !dbg !23
+
+if.else:                                          ; preds = %entry
+  ret i32 0
+}
+
+declare hidden fastcc i32 @bar(i32, i32* nocapture) nounwind optsize ssp
+declare hidden fastcc i32 @bar2(i32) nounwind optsize ssp
+declare hidden fastcc i32 @bar3(i32) nounwind optsize ssp
+declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!29}
+
+!0 = distinct !DISubprogram(name: "foo", line: 19510, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !2, scopeLine: 19510, file: !26, scope: !1, type: !3)
+!1 = !DIFile(filename: "/tmp/f.c", directory: "/tmp")
+!2 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 2.9 (trunk 124753)", isOptimized: true, emissionKind: FullDebug, file: !27, enums: !28, retainedTypes: !28, imports:  null)
+!3 = !DISubroutineType(types: !4)
+!4 = !{!5}
+!5 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!6 = distinct !DISubprogram(name: "bar3", line: 14827, isLocal: true, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !2, file: !26, scope: !1, type: !3)
+!7 = distinct !DISubprogram(name: "bar2", line: 15397, isLocal: true, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !2, file: !26, scope: !1, type: !3)
+!8 = distinct !DISubprogram(name: "bar", line: 12382, isLocal: true, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !2, file: !26, scope: !1, type: !9)
+!9 = !DISubroutineType(types: !10)
+!10 = !{!11}
+!11 = !DIBasicType(tag: DW_TAG_base_type, name: "unsigned char", size: 8, align: 8, encoding: DW_ATE_unsigned_char)
+!12 = !DILocalVariable(name: "var", line: 19509, arg: 1, scope: !0, file: !1, type: !5)
+!13 = !DILocation(line: 19509, column: 20, scope: !0)
+!14 = !DILocation(line: 18091, column: 2, scope: !15, inlinedAt: !17)
+!15 = distinct !DILexicalBlock(line: 18086, column: 1, file: !26, scope: !16)
+!16 = distinct !DISubprogram(name: "foo_bar", line: 18086, isLocal: true, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !2, file: !26, scope: !1, type: !3)
+!17 = !DILocation(line: 19514, column: 2, scope: !18)
+!18 = distinct !DILexicalBlock(line: 19510, column: 1, file: !26, scope: !0)
+!22 = !DILocation(line: 18094, column: 2, scope: !15, inlinedAt: !17)
+!23 = !DILocation(line: 19524, column: 1, scope: !18)
+!25 = !DIFile(filename: "f.i", directory: "/tmp")
+!26 = !DIFile(filename: "/tmp/f.c", directory: "/tmp")
+!27 = !DIFile(filename: "f.i", directory: "/tmp")
+!28 = !{}
+!29 = !{i32 1, !"Debug Info Version", i32 3}
diff --git a/test/DebugInfo/X86/dbg-value-range.ll b/test/DebugInfo/X86/dbg-value-range.ll
new file mode 100644
index 0000000..60f171f
--- /dev/null
+++ b/test/DebugInfo/X86/dbg-value-range.ll
@@ -0,0 +1,67 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin10 < %t.ll | FileCheck %s
+
+%struct.a = type { i32 }
+
+define i32 @bar(%struct.a* nocapture %b) nounwind ssp !dbg !0 {
+entry:
+  tail call void @llvm.dbg.value(metadata %struct.a* %b, metadata !6, metadata !DIExpression()), !dbg !13
+  %tmp1 = getelementptr inbounds %struct.a, %struct.a* %b, i64 0, i32 0, !dbg !14
+  %tmp2 = load i32, i32* %tmp1, align 4, !dbg !14
+  tail call void @llvm.dbg.value(metadata i32 %tmp2, metadata !11, metadata !DIExpression()), !dbg !14
+  %call = tail call i32 (i32) @foo(i32 %tmp2) nounwind , !dbg !18
+  %add = add nsw i32 %tmp2, 1, !dbg !19
+  ret i32 %add, !dbg !19
+}
+
+declare i32 @foo(i32)
+
+declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!24}
+
+!0 = distinct !DISubprogram(name: "bar", line: 5, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !2, file: !22, scope: !1, type: !3, retainedNodes: !21)
+!1 = !DIFile(filename: "bar.c", directory: "/private/tmp")
+!2 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 2.9 (trunk 122997)", isOptimized: true, emissionKind: FullDebug, file: !22, enums: !23, retainedTypes: !23, imports:  null)
+!3 = !DISubroutineType(types: !4)
+!4 = !{!5}
+!5 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!6 = !DILocalVariable(name: "b", line: 5, arg: 1, scope: !0, file: !1, type: !7)
+!7 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, scope: !2, baseType: !8)
+!8 = !DICompositeType(tag: DW_TAG_structure_type, name: "a", line: 1, size: 32, align: 32, file: !22, scope: !2, elements: !9)
+!9 = !{!10}
+!10 = !DIDerivedType(tag: DW_TAG_member, name: "c", line: 2, size: 32, align: 32, file: !22, scope: !1, baseType: !5)
+!11 = !DILocalVariable(name: "x", line: 6, scope: !12, file: !1, type: !5)
+!12 = distinct !DILexicalBlock(line: 5, column: 22, file: !22, scope: !0)
+!13 = !DILocation(line: 5, column: 19, scope: !0)
+!14 = !DILocation(line: 6, column: 14, scope: !12)
+!18 = !DILocation(line: 7, column: 2, scope: !12)
+!19 = !DILocation(line: 8, column: 2, scope: !12)
+!21 = !{!6, !11}
+!22 = !DIFile(filename: "bar.c", directory: "/private/tmp")
+!23 = !{}
+
+; Check that variable bar:b value range is appropriately truncated in debug info.
+; The variable is in %rdi which is clobbered by 'movl %ebx, %edi'
+; Here Ltmp7 is the end of the location range.
+
+;CHECK: .loc	1 7 2
+;CHECK: movl
+;CHECK-NEXT: [[CLOBBER:Ltmp[0-9]*]]
+
+;CHECK:Ldebug_loc0:
+;CHECK-NEXT: .set Lset{{.*}},
+;CHECK-NEXT:	.quad
+;CHECK-NEXT: .set [[CLOBBER_OFF:Lset.*]], [[CLOBBER]]-{{.*}}
+;CHECK-NEXT:	.quad	[[CLOBBER_OFF]]
+;CHECK-NEXT:  .short 1 ## Loc expr size
+;CHECK-NEXT:	.byte	85 ## DW_OP_reg
+;CHECK-NEXT:	.quad	0
+;CHECK-NEXT:	.quad	0
+!24 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/debug-dead-local-var.ll b/test/DebugInfo/X86/debug-dead-local-var.ll
new file mode 100644
index 0000000..ad4e70a
--- /dev/null
+++ b/test/DebugInfo/X86/debug-dead-local-var.ll
@@ -0,0 +1,59 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-linux-gnu %t.ll -filetype=obj -o %t
+; RUN: llvm-dwarfdump %t | FileCheck %s
+
+; Reconstruct this via clang and -O2.
+; static void foo() {
+;   struct X { int a; int b; } xyz;
+; }
+
+; int bar() {
+;   foo();
+;   return 1;
+; }
+
+; Check that we don't have the structure type for X since its scope has
+; been optimized away.
+; CHECK-NOT: DW_TAG_structure_type
+; CHECK: DW_TAG_subprogram
+; CHECK: DW_AT_name {{.*}}"bar"
+; CHECK-NOT: DW_TAG_structure_type
+
+; Function Attrs: nounwind readnone uwtable
+define i32 @bar() #0 !dbg !4 {
+entry:
+  ret i32 1, !dbg !21
+}
+
+attributes #0 = { nounwind readnone uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!18, !19}
+!llvm.ident = !{!20}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.5.0 (trunk 209255) (llvm/trunk 209253)", isOptimized: true, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "debug-dead-local-var.c", directory: "/usr/local/google/home/echristo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "bar", line: 11, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: true, unit: !0, scopeLine: 11, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "debug-dead-local-var.c", directory: "/usr/local/google/home/echristo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = distinct !DISubprogram(name: "foo", line: 6, isLocal: true, isDefinition: true, virtualIndex: 6, isOptimized: true, unit: !0, scopeLine: 6, file: !1, scope: !5, type: !10, retainedNodes: !12)
+!10 = !DISubroutineType(types: !11)
+!11 = !{null}
+!12 = !{!13}
+!13 = !DILocalVariable(name: "xyz", line: 8, scope: !9, file: !5, type: !14)
+!14 = !DICompositeType(tag: DW_TAG_structure_type, name: "X", line: 8, size: 64, align: 32, file: !1, scope: !9, elements: !15)
+!15 = !{!16, !17}
+!16 = !DIDerivedType(tag: DW_TAG_member, name: "a", line: 8, size: 32, align: 32, file: !1, scope: !14, baseType: !8)
+!17 = !DIDerivedType(tag: DW_TAG_member, name: "b", line: 8, size: 32, align: 32, offset: 32, file: !1, scope: !14, baseType: !8)
+!18 = !{i32 2, !"Dwarf Version", i32 4}
+!19 = !{i32 2, !"Debug Info Version", i32 3}
+!20 = !{!"clang version 3.5.0 (trunk 209255) (llvm/trunk 209253)"}
+!21 = !DILocation(line: 13, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/debug-info-access.ll b/test/DebugInfo/X86/debug-info-access.ll
new file mode 100644
index 0000000..2751640
--- /dev/null
+++ b/test/DebugInfo/X86/debug-info-access.ll
@@ -0,0 +1,157 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -debug-info %t | FileCheck %s
+;
+; Test the DW_AT_accessibility DWARF attribute.
+;
+;
+; Regenerate me:
+; clang++ -g tools/clang/test/CodeGenCXX/debug-info-access.cpp -S -emit-llvm -o -
+;
+;   struct A {
+;     void pub_default();
+;     static int pub_default_static;
+;   };
+;
+;   class B : public A {
+;   public:
+;     void pub();
+;     static int public_static;
+;   protected:
+;     void prot();
+;   private:
+;     void priv_default();
+;   };
+;
+;   union U {
+;     void union_pub_default();
+;   private:
+;     int union_priv;
+;   };
+;
+;   void free() {}
+;
+;   A a;
+;   B b;
+;   U u;
+
+; CHECK: DW_TAG_member
+; CHECK:     DW_AT_name {{.*}}"pub_default_static")
+; CHECK-NOT: DW_AT_accessibility
+; CHECK-NOT: DW_TAG
+;
+; CHECK: DW_TAG_subprogram
+; CHECK:     DW_AT_name {{.*}}"pub_default")
+; CHECK-NOT: DW_AT_accessibility
+; CHECK: DW_TAG
+;
+; CHECK: DW_TAG_inheritance
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_accessibility {{.*}}(DW_ACCESS_public)
+;
+; CHECK: DW_TAG_member
+; CHECK:     DW_AT_name {{.*}}"public_static")
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_accessibility {{.*}}(DW_ACCESS_public)
+;
+; CHECK: DW_TAG_subprogram
+; CHECK:     DW_AT_name {{.*}}"pub")
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_accessibility {{.*}}(DW_ACCESS_public)
+;
+; CHECK: DW_TAG_subprogram
+; CHECK:     DW_AT_name {{.*}}"prot")
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_accessibility {{.*}}(DW_ACCESS_protected)
+;
+; CHECK: DW_TAG_subprogram
+; CHECK:     DW_AT_name {{.*}}"priv_default")
+; CHECK-NOT: DW_AT_accessibility
+; CHECK: DW_TAG
+;
+; CHECK: DW_TAG_member
+; CHECK:     DW_AT_name {{.*}}"union_priv")
+; CHECK-NOT: DW_TAG
+; CHECK:     DW_AT_accessibility {{.*}}(DW_ACCESS_private)
+;
+; CHECK: DW_TAG_subprogram
+; CHECK:     DW_AT_name {{.*}}"union_pub_default")
+; CHECK-NOT: DW_AT_accessibility
+; CHECK: DW_TAG
+;
+; CHECK: DW_TAG_subprogram
+; CHECK:     DW_AT_name {{.*}}"free")
+; CHECK-NOT: DW_AT_accessibility
+; CHECK-NOT: DW_TAG
+;
+; ModuleID = '/llvm/tools/clang/test/CodeGenCXX/debug-info-access.cpp'
+source_filename = "test/DebugInfo/X86/debug-info-access.ll"
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+%struct.A = type { i8 }
+%class.B = type { i8 }
+%union.U = type { i32 }
+
+@a = global %struct.A zeroinitializer, align 1, !dbg !0
+@b = global %class.B zeroinitializer, align 1, !dbg !11
+@u = global %union.U zeroinitializer, align 4, !dbg !23
+
+; Function Attrs: nounwind ssp uwtable
+define void @_Z4freev() #0 !dbg !39 {
+  ret void, !dbg !42
+}
+
+attributes #0 = { nounwind ssp uwtable }
+
+!llvm.dbg.cu = !{!32}
+!llvm.module.flags = !{!36, !37}
+!llvm.ident = !{!38}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "a", scope: null, file: !2, line: 37, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "/llvm/tools/clang/test/CodeGenCXX/debug-info-access.cpp", directory: "")
+!3 = !DICompositeType(tag: DW_TAG_structure_type, name: "A", file: !2, line: 3, size: 8, align: 8, elements: !4, identifier: "_ZTS1A")
+!4 = !{!5, !7}
+!5 = !DIDerivedType(tag: DW_TAG_member, name: "pub_default_static", scope: !3, file: !2, line: 7, baseType: !6, flags: DIFlagStaticMember)
+!6 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!7 = !DISubprogram(name: "pub_default", linkageName: "_ZN1A11pub_defaultEv", scope: !3, file: !2, line: 5, type: !8, isLocal: false, isDefinition: false, scopeLine: 5, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false)
+!8 = !DISubroutineType(types: !9)
+!9 = !{null, !10}
+!10 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !3, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!11 = !DIGlobalVariableExpression(var: !12, expr: !DIExpression())
+!12 = !DIGlobalVariable(name: "b", scope: null, file: !2, line: 38, type: !13, isLocal: false, isDefinition: true)
+!13 = !DICompositeType(tag: DW_TAG_class_type, name: "B", file: !2, line: 11, size: 8, align: 8, elements: !14, identifier: "_ZTS1B")
+!14 = !{!15, !16, !17, !21, !22}
+!15 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !13, baseType: !3, flags: DIFlagPublic)
+!16 = !DIDerivedType(tag: DW_TAG_member, name: "public_static", scope: !13, file: !2, line: 16, baseType: !6, flags: DIFlagPublic | DIFlagStaticMember)
+!17 = !DISubprogram(name: "pub", linkageName: "_ZN1B3pubEv", scope: !13, file: !2, line: 14, type: !18, isLocal: false, isDefinition: false, scopeLine: 14, virtualIndex: 6, flags: DIFlagPublic | DIFlagPrototyped, isOptimized: false)
+!18 = !DISubroutineType(types: !19)
+!19 = !{null, !20}
+!20 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !13, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!21 = !DISubprogram(name: "prot", linkageName: "_ZN1B4protEv", scope: !13, file: !2, line: 19, type: !18, isLocal: false, isDefinition: false, scopeLine: 19, virtualIndex: 6, flags: DIFlagProtected | DIFlagPrototyped, isOptimized: false)
+!22 = !DISubprogram(name: "priv_default", linkageName: "_ZN1B12priv_defaultEv", scope: !13, file: !2, line: 22, type: !18, isLocal: false, isDefinition: false, scopeLine: 22, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false)
+!23 = !DIGlobalVariableExpression(var: !24, expr: !DIExpression())
+!24 = !DIGlobalVariable(name: "u", scope: null, file: !2, line: 39, type: !25, isLocal: false, isDefinition: true)
+!25 = !DICompositeType(tag: DW_TAG_union_type, name: "U", file: !2, line: 25, size: 32, align: 32, elements: !26, identifier: "_ZTS1U")
+!26 = !{!27, !28}
+!27 = !DIDerivedType(tag: DW_TAG_member, name: "union_priv", scope: !25, file: !2, line: 30, baseType: !6, size: 32, align: 32, flags: DIFlagPrivate)
+!28 = !DISubprogram(name: "union_pub_default", linkageName: "_ZN1U17union_pub_defaultEv", scope: !25, file: !2, line: 27, type: !29, isLocal: false, isDefinition: false, scopeLine: 27, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false)
+!29 = !DISubroutineType(types: !30)
+!30 = !{null, !31}
+!31 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !25, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!32 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.6.0 ", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !33, retainedTypes: !34, globals: !35, imports: !33)
+!33 = !{}
+!34 = !{!3, !13, !25}
+!35 = !{!0, !11, !23}
+!36 = !{i32 2, !"Dwarf Version", i32 2}
+!37 = !{i32 2, !"Debug Info Version", i32 3}
+!38 = !{!"clang version 3.6.0 "}
+!39 = distinct !DISubprogram(name: "free", linkageName: "_Z4freev", scope: !2, file: !2, line: 35, type: !40, isLocal: false, isDefinition: true, scopeLine: 35, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !32, retainedNodes: !33)
+!40 = !DISubroutineType(types: !41)
+!41 = !{null}
+!42 = !DILocation(line: 35, column: 14, scope: !39)
+
diff --git a/test/DebugInfo/X86/debug_frame.ll b/test/DebugInfo/X86/debug_frame.ll
new file mode 100644
index 0000000..d27f8c3
--- /dev/null
+++ b/test/DebugInfo/X86/debug_frame.ll
@@ -0,0 +1,28 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc %t.ll -mtriple=i686-pc-linux-gnu -o - | FileCheck %s
+
+; Test that we produce a .debug_frame, not an .eh_frame
+
+; CHECK: .cfi_sections .debug_frame
+
+define void @f() nounwind !dbg !0 {
+entry:
+  ret void
+}
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!7}
+!5 = !{!0}
+
+!0 = distinct !DISubprogram(name: "f", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !2, scopeLine: 1, file: !6, scope: !1, type: !3)
+!1 = !DIFile(filename: "/home/espindola/llvm/test.c", directory: "/home/espindola/llvm/build")
+!2 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.0 ()", isOptimized: true, emissionKind: FullDebug, file: !6, enums: !{}, retainedTypes: !{})
+!3 = !DISubroutineType(types: !4)
+!4 = !{null}
+!6 = !DIFile(filename: "/home/espindola/llvm/test.c", directory: "/home/espindola/llvm/build")
+!7 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/default-subrange-array.ll b/test/DebugInfo/X86/default-subrange-array.ll
new file mode 100644
index 0000000..d8640e2
--- /dev/null
+++ b/test/DebugInfo/X86/default-subrange-array.ll
@@ -0,0 +1,59 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin -O0 -filetype=obj -dwarf-version 4 \
+; RUN:     -o - < %s | llvm-dwarfdump -v - --debug-info \
+; RUN:     | FileCheck %s -check-prefixes=CHECK,DWARF4
+; RUN: llc -mtriple=x86_64-apple-darwin -O0 -filetype=obj -dwarf-version 5 \
+; RUN:     -o - < %s | llvm-dwarfdump -v - --debug-info \
+; RUN:     | FileCheck %s -check-prefixes=CHECK,DWARF5
+
+; Check that we can omit default array lower-bounds.
+; DW_LANG_C_plus_plus_11 is new in DWARF v5, so if we use that with
+; DWARF v4, we should get the DW_AT_lower_bound attribute.
+
+source_filename = "test/DebugInfo/X86/default-subrange-array.ll"
+
+%class.A = type { [42 x i32] }
+
+@a = global %class.A zeroinitializer, align 4, !dbg !0
+
+; CHECK:       DW_TAG_class_type
+; CHECK:         DW_TAG_member
+; CHECK-NEXT:      DW_AT_name {{.*}} "x"
+; CHECK-NEXT:      DW_AT_type [DW_FORM_ref4] {{.*}} => {[[ARRAY:0x[0-9a-f]+]]}
+
+; CHECK: [[ARRAY]]: DW_TAG_array_type
+; CHECK-NEXT:         DW_AT_type
+; CHECK:            DW_TAG_subrange_type
+; CHECK-NEXT:         DW_AT_type
+; DWARF4-NEXT:        DW_AT_lower_bound [DW_FORM_data1] (0x00)
+; CHECK-NEXT:         DW_AT_count [DW_FORM_data1]       (0x2a)
+; DWARF5-NOT:         DW_AT_lower_bound
+
+
+!llvm.dbg.cu = !{!14}
+!llvm.module.flags = !{!17}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "a", scope: null, file: !2, line: 1, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "t.cpp", directory: "/Volumes/Sandbox/llvm")
+!3 = !DICompositeType(tag: DW_TAG_class_type, name: "A", file: !2, line: 1, align: 32, elements: !4)
+!4 = !{!5, !10}
+!5 = !DIDerivedType(tag: DW_TAG_member, name: "x", scope: !3, file: !2, line: 1, baseType: !6, flags: DIFlagPrivate)
+!6 = !DICompositeType(tag: DW_TAG_array_type, baseType: !7, align: 32, elements: !8)
+!7 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!8 = !{!9}
+!9 = !DISubrange(count: 42, lowerBound: 0)
+!10 = !DISubprogram(name: "A", scope: !3, file: !2, line: 1, type: !11, isLocal: false, isDefinition: false, scopeLine: 1, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false)
+!11 = !DISubroutineType(types: !12)
+!12 = !{null, !13}
+!13 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !3, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!14 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_11, file: !2, producer: "clang version 3.3 (trunk 169136)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !15, retainedTypes: !15, globals: !16, imports: !15)
+!15 = !{}
+!16 = !{!0}
+!17 = !{i32 1, !"Debug Info Version", i32 3}
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/discriminator2.ll b/test/DebugInfo/X86/discriminator2.ll
new file mode 100644
index 0000000..694cb94
--- /dev/null
+++ b/test/DebugInfo/X86/discriminator2.ll
@@ -0,0 +1,67 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=i386-unknown-unknown -mcpu=core2 %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -debug-line %t | FileCheck %s
+;
+; Generated from:
+;
+; #1 void foo(int, int);
+; #2 int bar();
+; #3 void baz() {
+; #4   foo/*discriminator 1*/(bar(),
+; #5       bar());bar()/*discriminator 1*/;
+; #6 }
+;
+; The intent is to test discriminator 1 generated for both line #4 and #5.
+; The instruction sequence in the final binary is:
+; line 4 discriminator 0
+; line 5 discriminator 0
+; line 4 discriminator 1
+; line 5 discriminator 1
+; We need to ensure that the discriminators for the last two instructions
+; are both 1.
+
+; Function Attrs: uwtable
+define void @_Z3bazv() #0 !dbg !6 {
+  %1 = call i32 @_Z3barv(), !dbg !9
+  %2 = call i32 @_Z3barv(), !dbg !10
+  call void @_Z3fooii(i32 %1, i32 %2), !dbg !11
+  %3 = call i32 @_Z3barv(), !dbg !13
+  ret void, !dbg !14
+}
+
+declare void @_Z3fooii(i32, i32) #1
+
+declare i32 @_Z3barv() #1
+
+attributes #0 = { uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+!llvm.ident = !{!5}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 3.9.0 (trunk 267219)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "test.cc", directory: ".")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{!"clang version 3.9.0 (trunk 267219)"}
+!6 = distinct !DISubprogram(name: "baz", linkageName: "_Z3bazv", scope: !1, file: !1, line: 3, type: !7, isLocal: false, isDefinition: true, scopeLine: 3, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!7 = !DISubroutineType(types: !8)
+!8 = !{null}
+!9 = !DILocation(line: 4, column: 7, scope: !6)
+!10 = !DILocation(line: 5, column: 14, scope: !6)
+!11 = !DILocation(line: 4, column: 3, scope: !12)
+!12 = !DILexicalBlockFile(scope: !6, file: !1, discriminator: 1)
+!13 = !DILocation(line: 5, column: 21, scope: !12)
+!14 = !DILocation(line: 6, column: 1, scope: !6)
+
+; CHECK: Address            Line   Column File   ISA Discriminator Flags
+; CHECK: ------------------ ------ ------ ------ --- ------------- -------------
+; CHECK: {{.*}}      4      3      1   0             1  {{.*}}
+; CHECK: {{.*}}      5     21      1   0             1  {{.*}}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/discriminator3.ll b/test/DebugInfo/X86/discriminator3.ll
new file mode 100644
index 0000000..54e366e
--- /dev/null
+++ b/test/DebugInfo/X86/discriminator3.ll
@@ -0,0 +1,80 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=i386-unknown-unknown -mcpu=core2 %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -debug-line %t | FileCheck %s
+;
+; Generated from:
+;
+; #1 void foo(int);
+; #2 void baz(int i) {
+; #3   if (i) {foo(i+1);/*discriminator 1*/}
+; #4 }
+;
+; The intent is to test discriminator 1 generated for all instructions in
+; the taken branch.
+
+; Function Attrs: uwtable
+define void @_Z3bazi(i32) #0 !dbg !6 {
+  %2 = alloca i32, align 4
+  store i32 %0, i32* %2, align 4
+  call void @llvm.dbg.declare(metadata i32* %2, metadata !10, metadata !11), !dbg !12
+  %3 = load i32, i32* %2, align 4, !dbg !13
+  %4 = icmp ne i32 %3, 0, !dbg !13
+  br i1 %4, label %5, label %8, !dbg !15
+
+; <label>:5:                                      ; preds = %1
+  %6 = load i32, i32* %2, align 4, !dbg !16
+  %7 = add nsw i32 %6, 1, !dbg !19
+  call void @_Z3fooi(i32 %7), !dbg !20
+  br label %8, !dbg !21
+
+; <label>:8:                                      ; preds = %5, %1
+  ret void, !dbg !22
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+declare void @_Z3fooi(i32) #2
+
+attributes #0 = { uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+!llvm.ident = !{!5}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 3.9.0 (trunk 267518)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "test.cc", directory: ".")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{!"clang version 3.9.0 (trunk 267518)"}
+!6 = distinct !DISubprogram(name: "baz", linkageName: "_Z3bazi", scope: !1, file: !1, line: 2, type: !7, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!7 = !DISubroutineType(types: !8)
+!8 = !{null, !9}
+!9 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!10 = !DILocalVariable(name: "i", arg: 1, scope: !6, file: !1, line: 2, type: !9)
+!11 = !DIExpression()
+!12 = !DILocation(line: 2, column: 14, scope: !6)
+!13 = !DILocation(line: 3, column: 7, scope: !14)
+!14 = distinct !DILexicalBlock(scope: !6, file: !1, line: 3, column: 7)
+!15 = !DILocation(line: 3, column: 7, scope: !6)
+!16 = !DILocation(line: 3, column: 15, scope: !17)
+!17 = !DILexicalBlockFile(scope: !18, file: !1, discriminator: 1)
+!18 = distinct !DILexicalBlock(scope: !14, file: !1, line: 3, column: 10)
+!19 = !DILocation(line: 3, column: 16, scope: !17)
+!20 = !DILocation(line: 3, column: 11, scope: !17)
+!21 = !DILocation(line: 3, column: 21, scope: !17)
+!22 = !DILocation(line: 4, column: 1, scope: !6)
+
+; CHECK: Address            Line   Column File   ISA Discriminator Flags
+; CHECK: ------------------ ------ ------ ------ --- ------------- -------------
+; CHECK: {{.*}}      3     15      1   0             1 
+; CHECK: {{.*}}      3     16      1   0             1 
+; CHECK: {{.*}}      3     11      1   0             1 
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/double-declare.ll b/test/DebugInfo/X86/double-declare.ll
new file mode 100644
index 0000000..dc8057c
--- /dev/null
+++ b/test/DebugInfo/X86/double-declare.ll
@@ -0,0 +1,50 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin -O0 -filetype=obj -o - < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck %s
+; PR33157. Don't crash on duplicate dbg.declare.
+; CHECK: DW_TAG_formal_parameter
+; CHECK: DW_AT_location [DW_FORM_exprloc]
+; CHECK-NOT: DW_AT_location
+@g = external global i32
+@h = external global i32
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata)
+
+define void @f(i32* byval %p, i1 %c) !dbg !5 {
+  br i1 %c, label %x, label %y
+
+x:
+  call void @llvm.dbg.declare(metadata i32* %p, metadata !10, metadata !DIExpression()), !dbg !12
+  store i32 42, i32* @g, !dbg !12
+  br label %done
+
+y:
+  call void @llvm.dbg.declare(metadata i32* %p, metadata !10, metadata !DIExpression()), !dbg !12
+  store i32 42, i32* @h, !dbg !12
+  br label %done
+
+done:
+  ret void
+}
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!22, !23}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_ObjC, file: !1, producer: "clang version 5.0.0 ", isOptimized: true, runtimeVersion: 2, emissionKind: FullDebug)
+!1 = !DIFile(filename: "<stdin>", directory: "C:\5Csrc\5Cllvm-project\5Cbuild")
+!5 = distinct !DISubprogram(name: "f", isLocal: true, isDefinition: true, scopeLine: 37, flags: DIFlagPrototyped, isOptimized: true, unit: !0, type: !99, scope: !1)
+!6 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!10 = !DILocalVariable(name: "aRect", arg: 1, scope: !11, file: !1, line: 38, type: !6)
+!11 = distinct !DILexicalBlock(scope: !98, file: !1, line: 38)
+!12 = !DILocation(line: 43, scope: !11, inlinedAt: !13)
+!13 = distinct !DILocation(line: 43, scope: !5)
+!22 = !{i32 2, !"Dwarf Version", i32 4}
+!23 = !{i32 2, !"Debug Info Version", i32 3}
+!62 = !{!10}
+!98 = distinct !DISubprogram(name: "NSMaxX", scope: !1, file: !1, line: 27, isLocal: true, isDefinition: true, scopeLine: 27, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !62, type: !99)
+!99 = !DISubroutineType(types: !100)
+!100 = !{null}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/dw_op_minus_direct.ll b/test/DebugInfo/X86/dw_op_minus_direct.ll
new file mode 100644
index 0000000..e5ea188
--- /dev/null
+++ b/test/DebugInfo/X86/dw_op_minus_direct.ll
@@ -0,0 +1,62 @@
+; Test dwarf codegen of DW_OP_minus.
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj < %t.ll | llvm-dwarfdump -v - | FileCheck %s
+; RUN: llc -mtriple=%triple -dwarf-version=2 -filetype=obj < %t.ll | llvm-dwarfdump -v - \
+; RUN:   | FileCheck %s --check-prefix=DWARF2
+; RUN: llc -mtriple=%triple -dwarf-version=3 -filetype=obj < %t.ll | llvm-dwarfdump -v - \
+; RUN:   | FileCheck %s --check-prefix=DWARF2
+
+; This was derived manually from:
+; int inc(int i) {
+;  return i+1;
+; }
+
+; DWARF2: .debug_info
+; DWARF2: DW_TAG_formal_parameter
+; DWARF2-NEXT: DW_AT_name {{.*}}"i"
+; DWARF2-NOT:      DW_AT_location
+
+; CHECK: .debug_loc contents:
+; CHECK: 0x00000000:
+; CHECK-NEXT:   [0x0000000000000000, 0x0000000000000004): DW_OP_breg0 RAX+0, DW_OP_constu 0xffffffff, DW_OP_and, DW_OP_constu 0x1, DW_OP_minus, DW_OP_stack_value
+;        rax+0, constu 0xffffffff, and, constu 0x00000001, minus, stack-value
+
+source_filename = "minus.c"
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+define i32 @inc(i32 %i) local_unnamed_addr #1 !dbg !7 {
+entry:
+  %add = add nsw i32 %i, 1, !dbg !15
+  tail call void @llvm.dbg.value(metadata i32 %add, metadata !12, metadata !13), !dbg !14
+  ret i32 %add, !dbg !16
+}
+
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4, !5}
+!llvm.ident = !{!6}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 4.0.0 (trunk 286322) (llvm/trunk 286305)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "minus.c", directory: "/tmp")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{i32 1, !"PIC Level", i32 2}
+!6 = !{!"clang version 4.0.0 (trunk 286322) (llvm/trunk 286305)"}
+!7 = distinct !DISubprogram(name: "inc", scope: !1, file: !1, line: 1, type: !8, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !11)
+!8 = !DISubroutineType(types: !9)
+!9 = !{!10, !10}
+!10 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!11 = !{!12}
+!12 = !DILocalVariable(name: "i", arg: 1, scope: !7, file: !1, line: 1, type: !10)
+!13 = !DIExpression(DW_OP_constu, 1, DW_OP_minus, DW_OP_stack_value)
+!14 = !DILocation(line: 1, column: 13, scope: !7)
+!15 = !DILocation(line: 2, column: 11, scope: !7)
+!16 = !DILocation(line: 2, column: 3, scope: !7)
diff --git a/test/DebugInfo/X86/dwarf-aranges-no-dwarf-labels.ll b/test/DebugInfo/X86/dwarf-aranges-no-dwarf-labels.ll
new file mode 100644
index 0000000..8197d2f
--- /dev/null
+++ b/test/DebugInfo/X86/dwarf-aranges-no-dwarf-labels.ll
@@ -0,0 +1,95 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -generate-arange-section < %t.ll | FileCheck %s
+
+; CHECK: .short  2 # DWARF Arange version number
+; CHECK: # Segment Size
+; CHECK-NOT: debug_loc
+; CHECK: .quad global
+; CHECK-NOT: debug_loc
+; CHECK: # ARange terminator
+
+; --- Source code ---
+; Generated with "clang -g -O1 -S -emit-llvm"
+
+; int global = 2;
+; int foo(int bar) { return bar; }
+; int foo2(int bar2) { return bar2; }
+
+; int main() {
+;   return foo(2) + foo2(1) + global;
+; }
+
+; ModuleID = 'tmp/debug_ranges/a.cc'
+source_filename = "test/DebugInfo/X86/dwarf-aranges-no-dwarf-labels.ll"
+target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+@global = global i32 2, align 4, !dbg !0
+
+; Function Attrs: nounwind readnone uwtable
+define i32 @_Z3fooi(i32 %bar) #0 !dbg !9 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 %bar, metadata !13, metadata !14), !dbg !15
+  ret i32 %bar, !dbg !15
+}
+
+; Function Attrs: nounwind readnone uwtable
+define i32 @_Z4foo2i(i32 %bar2) #0 !dbg !16 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 %bar2, metadata !18, metadata !14), !dbg !19
+  ret i32 %bar2, !dbg !19
+}
+
+; Function Attrs: nounwind readonly uwtable
+define i32 @main() #1 !dbg !20 {
+entry:
+  %call = tail call i32 @_Z3fooi(i32 2), !dbg !23
+  %call1 = tail call i32 @_Z4foo2i(i32 1), !dbg !23
+  %add = add nsw i32 %call1, %call, !dbg !23
+  %0 = load i32, i32* @global, align 4, !dbg !23, !tbaa !24
+  %add2 = add nsw i32 %add, %0, !dbg !23
+  ret i32 %add2, !dbg !23
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #2
+
+attributes #0 = { nounwind readnone uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readonly uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #2 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!4}
+!llvm.module.flags = !{!7, !8}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "global", scope: null, file: !2, line: 1, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "tmp/debug_ranges/a.cc", directory: "/")
+!3 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!4 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.4 (191881)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !5, retainedTypes: !5, globals: !6, imports: !5)
+!5 = !{}
+!6 = !{!0}
+!7 = !{i32 2, !"Dwarf Version", i32 4}
+!8 = !{i32 1, !"Debug Info Version", i32 3}
+!9 = distinct !DISubprogram(name: "foo", linkageName: "_Z3fooi", scope: !2, file: !2, line: 2, type: !10, isLocal: false, isDefinition: true, scopeLine: 2, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !4, retainedNodes: !12)
+!10 = !DISubroutineType(types: !11)
+!11 = !{!3, !3}
+!12 = !{!13}
+!13 = !DILocalVariable(name: "bar", arg: 1, scope: !9, file: !2, line: 2, type: !3)
+!14 = !DIExpression()
+!15 = !DILocation(line: 2, scope: !9)
+!16 = distinct !DISubprogram(name: "foo2", linkageName: "_Z4foo2i", scope: !2, file: !2, line: 3, type: !10, isLocal: false, isDefinition: true, scopeLine: 3, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !4, retainedNodes: !17)
+!17 = !{!18}
+!18 = !DILocalVariable(name: "bar2", arg: 1, scope: !16, file: !2, line: 3, type: !3)
+!19 = !DILocation(line: 3, scope: !16)
+!20 = distinct !DISubprogram(name: "main", scope: !2, file: !2, line: 5, type: !21, isLocal: false, isDefinition: true, scopeLine: 5, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !4, retainedNodes: !5)
+!21 = !DISubroutineType(types: !22)
+!22 = !{!3}
+!23 = !DILocation(line: 6, scope: !20)
+!24 = !{!25, !25, i64 0}
+!25 = !{!"int", !26}
+!26 = !{!"omnipotent char", !27}
+!27 = !{!"Simple C/C++ TBAA"}
+
diff --git a/test/DebugInfo/X86/dwarf-linkage-names.ll b/test/DebugInfo/X86/dwarf-linkage-names.ll
new file mode 100644
index 0000000..472d571
--- /dev/null
+++ b/test/DebugInfo/X86/dwarf-linkage-names.ll
@@ -0,0 +1,80 @@
+; DWARF linkage name attributes are optional; verify they are missing for
+; PS4 triple or when tuning for SCE.
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -O0 -mtriple=x86_64-unknown-unknown < %t.ll | FileCheck %s -check-prefix LINKAGE1
+; RUN: llc -O0 -mtriple=x86_64-unknown-unknown < %t.ll | FileCheck %s -check-prefix LINKAGE2
+; RUN: llc -O0 -mtriple=x86_64-scei-ps4 < %t.ll | FileCheck %s -check-prefix NOLINKAGE
+; RUN: llc -O0 -mtriple=x86_64-unknown-unknown -debugger-tune=sce < %t.ll | FileCheck %s -check-prefix NOLINKAGE
+
+; $ clang++ -emit-llvm -S -g dwarf-linkage-names.cpp
+; namespace test {
+;  int global_var;
+;  int bar() { return global_var; }
+;};
+
+; With linkage names, we get an attribute for the declaration (first) entry
+; for the global variable, and one for the function.
+
+; This assumes the variable will appear before the function.
+; LINKAGE1: .section .debug_info
+; LINKAGE1: DW_TAG_variable
+; LINKAGE1-NOT: DW_TAG
+; LINKAGE1: {{DW_AT_(MIPS_)?linkage_name}}
+; LINKAGE1: DW_TAG_subprogram
+; LINKAGE1-NOT: DW_TAG
+; LINKAGE1: {{DW_AT_(MIPS_)?linkage_name}}
+; LINKAGE1: .section
+
+; Also verify we see the mangled names. We do this as a separate pass to
+; avoid depending on the order of .debug_info and .debug_str sections.
+
+; LINKAGE2-DAG: .asciz   "_ZN4test10global_varE"
+; LINKAGE2-DAG: .asciz   "_ZN4test3barEv"
+
+; Without linkage names, verify there aren't any linkage-name attributes,
+; and no mangled names.
+
+; NOLINKAGE-NOT: {{DW_AT_(MIPS_)?linkage_name}}
+; NOLINKAGE-NOT: .asciz   "_ZN4test10global_varE"
+; NOLINKAGE-NOT: .asciz   "_ZN4test3barEv"
+
+source_filename = "test/DebugInfo/X86/dwarf-linkage-names.ll"
+
+@_ZN4test10global_varE = global i32 0, align 4, !dbg !0
+
+; Function Attrs: nounwind uwtable
+define i32 @_ZN4test3barEv() #0 !dbg !11 {
+entry:
+  %0 = load i32, i32* @_ZN4test10global_varE, align 4, !dbg !14
+  ret i32 %0, !dbg !15
+}
+
+attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!5}
+!llvm.module.flags = !{!8, !9}
+!llvm.ident = !{!10}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "global_var", linkageName: "_ZN4test10global_varE", scope: !2, file: !3, line: 2, type: !4, isLocal: false, isDefinition: true)
+!2 = !DINamespace(name: "test", scope: null)
+!3 = !DIFile(filename: "dwarf-linkage-names.cpp", directory: "/home/probinson/projects/scratch")
+!4 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!5 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !3, producer: "clang version 3.8.0 (trunk 244662)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !6, globals: !7)
+!6 = !{}
+!7 = !{!0}
+!8 = !{i32 2, !"Dwarf Version", i32 4}
+!9 = !{i32 2, !"Debug Info Version", i32 3}
+!10 = !{!"clang version 3.8.0 (trunk 244662)"}
+!11 = distinct !DISubprogram(name: "bar", linkageName: "_ZN4test3barEv", scope: !2, file: !3, line: 3, type: !12, isLocal: false, isDefinition: true, scopeLine: 3, flags: DIFlagPrototyped, isOptimized: false, unit: !5, retainedNodes: !6)
+!12 = !DISubroutineType(types: !13)
+!13 = !{!4}
+!14 = !DILocation(line: 3, column: 21, scope: !11)
+!15 = !DILocation(line: 3, column: 14, scope: !11)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/dwarf-pubnames-split.ll b/test/DebugInfo/X86/dwarf-pubnames-split.ll
new file mode 100644
index 0000000..b75d3bb
--- /dev/null
+++ b/test/DebugInfo/X86/dwarf-pubnames-split.ll
@@ -0,0 +1,43 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-pc-linux-gnu -split-dwarf-file=foo.dwo %t.ll -o - | FileCheck %s
+; Derived from:
+
+; int main (void) {
+;    return 0;
+; }
+
+; Check that we get a symbol off of the debug_info section when using split dwarf and pubnames.
+
+; CHECK: .LpubTypes_begin0:
+; CHECK-NEXT: .short    2                       # DWARF Version
+; CHECK-NEXT: .long     .Lcu_begin0             # Offset of Compilation Unit Info
+
+; Function Attrs: nounwind uwtable
+define i32 @main() #0 !dbg !4 {
+entry:
+  %retval = alloca i32, align 4
+  store i32 0, i32* %retval
+  ret i32 0, !dbg !10
+}
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!9, !11}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.4 (trunk 189287) (llvm/trunk 189296)", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "foo.c", directory: "/usr/local/google/home/echristo/tmp")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "main", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 1, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "foo.c", directory: "/usr/local/google/home/echristo/tmp")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = !{i32 2, !"Dwarf Version", i32 3}
+!10 = !DILocation(line: 2, scope: !4)
+!11 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/earlydup-crash.ll b/test/DebugInfo/X86/earlydup-crash.ll
new file mode 100644
index 0000000..369116f
--- /dev/null
+++ b/test/DebugInfo/X86/earlydup-crash.ll
@@ -0,0 +1,99 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc %t.ll -mtriple=i386-apple-macosx10.6.7 -o /dev/null
+
+; This used to crash because early dup was not ignoring debug instructions.
+
+%struct.cpp_dir = type { %struct.cpp_dir*, i8*, i32, i8, i8**, i8*, i8* (i8*, %struct.cpp_dir*)*, i64, i32, i8 }
+
+declare void @llvm.dbg.value(metadata, metadata, metadata) nounwind readnone
+
+define internal i8* @framework_construct_pathname(i8* %fname, %struct.cpp_dir* %dir) nounwind ssp !dbg !2 {
+entry:
+  br i1 undef, label %bb33, label %bb
+
+bb:                                               ; preds = %entry
+  %tmp = icmp eq i32 undef, 0
+  %tmp1 = add i32 0, 11
+  call void @llvm.dbg.value(metadata i32 %tmp1, metadata !0, metadata !DIExpression()), !dbg !DILocation(scope: !1)
+  br i1 undef, label %bb18, label %bb31.preheader
+
+bb31.preheader:                                   ; preds = %bb19, %bb
+  %tmp2 = getelementptr inbounds i8, i8* %fname, i32 0
+  br label %bb31
+
+bb18:                                             ; preds = %bb
+  %tmp3 = icmp eq i32 undef, 0
+  br i1 %tmp3, label %bb19, label %bb33
+
+bb19:                                             ; preds = %bb18
+  call void @foobar(i32 0)
+  br label %bb31.preheader
+
+bb22:                                             ; preds = %bb31
+  %tmp4 = add i32 0, %tmp1
+  call void @foobar(i32 %tmp4)
+  br i1 undef, label %bb33, label %bb31
+
+bb31:                                             ; preds = %bb22, %bb31.preheader
+  br i1 false, label %bb33, label %bb22
+
+bb33:                                             ; preds = %bb31, %bb22, %bb18, %entry
+  ret i8* undef
+}
+
+declare void @foobar(i32)
+
+!llvm.dbg.cu = !{!4}
+!llvm.module.flags = !{!47}
+!0 = !DILocalVariable(name: "frname_len", line: 517, scope: !1, file: !3, type: !38)
+!1 = distinct !DILexicalBlock(line: 515, column: 0, file: !44, scope: !2)
+!2 = distinct !DISubprogram(name: "framework_construct_pathname", line: 515, isLocal: true, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !4, file: !44, scope: null, type: !5)
+!3 = !DIFile(filename: "darwin-c.c", directory: "/Users/espindola/llvm/build-llvm-gcc/gcc/../../llvm-gcc-4.2/gcc/config")
+!4 = distinct !DICompileUnit(language: DW_LANG_C89, producer: "4.2.1 (Based on Apple Inc. build 5658) (LLVM build)", isOptimized: true, emissionKind: FullDebug, file: !44, enums: !46, retainedTypes: !46)
+!5 = !DISubroutineType(types: !6)
+!6 = !{!7, !9, !11}
+!7 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 32, align: 32, file: !44, scope: !3, baseType: !8)
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "char", size: 8, align: 8, encoding: DW_ATE_signed_char)
+!9 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 32, align: 32, file: !44, scope: !3, baseType: !10)
+!10 = !DIDerivedType(tag: DW_TAG_const_type, size: 8, align: 8, file: !44, scope: !3, baseType: !8)
+!11 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 32, align: 32, file: !44, scope: !3, baseType: !12)
+!12 = !DIDerivedType(tag: DW_TAG_typedef, name: "cpp_dir", line: 45, file: !41, scope: !13, baseType: !14)
+!13 = !DIFile(filename: "cpplib.h", directory: "/Users/espindola/llvm/build-llvm-gcc/gcc/../../llvm-gcc-4.2/gcc/../libcpp/include")
+!14 = !DICompositeType(tag: DW_TAG_structure_type, name: "cpp_dir", line: 43, size: 352, align: 32, file: !41, scope: !3, elements: !15)
+!15 = !{!16, !18, !19, !21, !23, !25, !27, !29, !33, !36}
+!16 = !DIDerivedType(tag: DW_TAG_member, name: "next", line: 572, size: 32, align: 32, file: !41, scope: !14, baseType: !17)
+!17 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 32, align: 32, file: !44, scope: !3, baseType: !14)
+!18 = !DIDerivedType(tag: DW_TAG_member, name: "name", line: 575, size: 32, align: 32, offset: 32, file: !41, scope: !14, baseType: !7)
+!19 = !DIDerivedType(tag: DW_TAG_member, name: "len", line: 576, size: 32, align: 32, offset: 64, file: !41, scope: !14, baseType: !20)
+!20 = !DIBasicType(tag: DW_TAG_base_type, name: "unsigned int", size: 32, align: 32, encoding: DW_ATE_unsigned)
+!21 = !DIDerivedType(tag: DW_TAG_member, name: "sysp", line: 580, size: 8, align: 8, offset: 96, file: !41, scope: !14, baseType: !22)
+!22 = !DIBasicType(tag: DW_TAG_base_type, name: "unsigned char", size: 8, align: 8, encoding: DW_ATE_unsigned_char)
+!23 = !DIDerivedType(tag: DW_TAG_member, name: "name_map", line: 584, size: 32, align: 32, offset: 128, file: !41, scope: !14, baseType: !24)
+!24 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 32, align: 32, file: !44, scope: !3, baseType: !9)
+!25 = !DIDerivedType(tag: DW_TAG_member, name: "header_map", line: 590, size: 32, align: 32, offset: 160, file: !41, scope: !14, baseType: !26)
+!26 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 32, align: 32, file: !44, scope: !3, baseType: null)
+!27 = !DIDerivedType(tag: DW_TAG_member, name: "construct", line: 597, size: 32, align: 32, offset: 192, file: !41, scope: !14, baseType: !28)
+!28 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 32, align: 32, file: !44, scope: !3, baseType: !5)
+!29 = !DIDerivedType(tag: DW_TAG_member, name: "ino", line: 601, size: 64, align: 64, offset: 224, file: !41, scope: !14, baseType: !30)
+!30 = !DIDerivedType(tag: DW_TAG_typedef, name: "ino_t", line: 141, file: !42, scope: !31, baseType: !32)
+!31 = !DIFile(filename: "types.h", directory: "/usr/include/sys")
+!32 = !DIBasicType(tag: DW_TAG_base_type, name: "long long unsigned int", size: 64, align: 64, encoding: DW_ATE_unsigned)
+!33 = !DIDerivedType(tag: DW_TAG_member, name: "dev", line: 602, size: 32, align: 32, offset: 288, file: !41, scope: !14, baseType: !34)
+!34 = !DIDerivedType(tag: DW_TAG_typedef, name: "dev_t", line: 107, file: !42, scope: !31, baseType: !35)
+!35 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!36 = !DIDerivedType(tag: DW_TAG_member, name: "user_supplied_p", line: 605, size: 8, align: 8, offset: 320, file: !41, scope: !14, baseType: !37)
+!37 = !DIBasicType(tag: DW_TAG_base_type, name: "_Bool", size: 8, align: 8, encoding: DW_ATE_boolean)
+!38 = !DIDerivedType(tag: DW_TAG_typedef, name: "size_t", line: 326, file: !43, scope: !39, baseType: !40)
+!39 = !DIFile(filename: "stddef.h", directory: "/Users/espindola/llvm/build-llvm-gcc/./prev-gcc/include")
+!40 = !DIBasicType(tag: DW_TAG_base_type, name: "long unsigned int", size: 32, align: 32, encoding: DW_ATE_unsigned)
+!41 = !DIFile(filename: "cpplib.h", directory: "/Users/espindola/llvm/build-llvm-gcc/gcc/../../llvm-gcc-4.2/gcc/../libcpp/include")
+!42 = !DIFile(filename: "types.h", directory: "/usr/include/sys")
+!43 = !DIFile(filename: "stddef.h", directory: "/Users/espindola/llvm/build-llvm-gcc/./prev-gcc/include")
+!44 = !DIFile(filename: "darwin-c.c", directory: "/Users/espindola/llvm/build-llvm-gcc/gcc/../../llvm-gcc-4.2/gcc/config")
+!46 = !{}
+!47 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/ending-run.ll b/test/DebugInfo/X86/ending-run.ll
new file mode 100644
index 0000000..bb5315b
--- /dev/null
+++ b/test/DebugInfo/X86/ending-run.ll
@@ -0,0 +1,53 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin -filetype=obj %t.ll -o %t
+; RUN: llvm-dwarfdump -debug-line %t | FileCheck %s
+
+; Check that the line table starts at 7, not 4, but that the first
+; statement isn't until line 8.
+
+; CHECK-NOT: 0x0000000000000000      7      0      1   0  0  is_stmt
+; CHECK: 0x0000000000000000      7      0      1   0
+; CHECK: 0x0000000000000004      8     18      1   0  0  is_stmt prologue_end
+
+define i32 @callee(i32 %x) nounwind uwtable ssp !dbg !5 {
+entry:
+  %x.addr = alloca i32, align 4
+  %y = alloca i32, align 4
+  store i32 %x, i32* %x.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %x.addr, metadata !12, metadata !DIExpression()), !dbg !13
+  call void @llvm.dbg.declare(metadata i32* %y, metadata !14, metadata !DIExpression()), !dbg !16
+  %0 = load i32, i32* %x.addr, align 4, !dbg !17
+  %1 = load i32, i32* %x.addr, align 4, !dbg !17
+  %mul = mul nsw i32 %0, %1, !dbg !17
+  store i32 %mul, i32* %y, align 4, !dbg !17
+  %2 = load i32, i32* %y, align 4, !dbg !18
+  %sub = sub nsw i32 %2, 2, !dbg !18
+  ret i32 %sub, !dbg !18
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!20}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.1 (trunk 153921) (llvm/trunk 153916)", isOptimized: false, emissionKind: FullDebug, file: !19, enums: !1, retainedTypes: !1, globals: !1, imports:  !1)
+!1 = !{}
+!5 = distinct !DISubprogram(name: "callee", line: 4, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !0, scopeLine: 7, file: !19, scope: !6, type: !7)
+!6 = !DIFile(filename: "ending-run.c", directory: "/Users/echristo/tmp")
+!7 = !DISubroutineType(types: !8)
+!8 = !{!9, !9}
+!9 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!12 = !DILocalVariable(name: "x", line: 5, arg: 1, scope: !5, file: !6, type: !9)
+!13 = !DILocation(line: 5, column: 5, scope: !5)
+!14 = !DILocalVariable(name: "y", line: 8, scope: !15, file: !6, type: !9)
+!15 = distinct !DILexicalBlock(line: 7, column: 1, file: !19, scope: !5)
+!16 = !DILocation(line: 8, column: 9, scope: !15)
+!17 = !DILocation(line: 8, column: 18, scope: !15)
+!18 = !DILocation(line: 9, column: 5, scope: !15)
+!19 = !DIFile(filename: "ending-run.c", directory: "/Users/echristo/tmp")
+!20 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/enum-class.ll b/test/DebugInfo/X86/enum-class.ll
new file mode 100644
index 0000000..03046a9
--- /dev/null
+++ b/test/DebugInfo/X86/enum-class.ll
@@ -0,0 +1,55 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -O0 -mtriple=x86_64-apple-darwin %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -v -debug-info %t | FileCheck %s
+
+source_filename = "test/DebugInfo/X86/enum-class.ll"
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
+
+@a = global i32 0, align 4, !dbg !0
+@b = global i64 0, align 8, !dbg !7
+@c = global i32 0, align 4, !dbg !13
+
+!llvm.dbg.cu = !{!18}
+!llvm.module.flags = !{!22}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "a", scope: null, file: !2, line: 4, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "foo.cpp", directory: "/Users/echristo/tmp")
+!3 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "A", file: !2, line: 1, baseType: !4, size: 32, flags: DIFlagFixedEnum, align: 32, elements: !5)
+!4 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!5 = !{!6}
+!6 = !DIEnumerator(name: "A1", value: 1)
+!7 = !DIGlobalVariableExpression(var: !8, expr: !DIExpression()) ; [ DW_TAG_enumerator ]
+!8 = !DIGlobalVariable(name: "b", scope: null, file: !2, line: 5, type: !9, isLocal: false, isDefinition: true)
+!9 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "B", file: !2, line: 2, baseType: !10, size: 64, flags: DIFlagFixedEnum, align: 64, elements: !11)
+!10 = !DIBasicType(name: "long unsigned int", size: 64, align: 64, encoding: DW_ATE_unsigned)
+!11 = !{!12}
+!12 = !DIEnumerator(name: "B1", value: 1) ; [ DW_TAG_enumerator ]
+!13 = !DIGlobalVariableExpression(var: !14, expr: !DIExpression())
+!14 = !DIGlobalVariable(name: "c", scope: null, file: !2, line: 6, type: !15, isLocal: false, isDefinition: true)
+!15 = !DICompositeType(tag: DW_TAG_enumeration_type, name: "C", file: !2, line: 3, size: 32, align: 32, elements: !16)
+!16 = !{!17}
+!17 = !DIEnumerator(name: "C1", value: 1) ; [ DW_TAG_enumerator ]
+!18 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.2 (trunk 157269) (llvm/trunk 157264)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !19, retainedTypes: !20, globals: !21, imports: !20)
+!19 = !{!3, !9, !15}
+!20 = !{}
+!21 = !{!0, !7, !13}
+!22 = !{i32 1, !"Debug Info Version", i32 3}
+
+; CHECK: DW_TAG_enumeration_type [{{.*}}]
+; CHECK: DW_AT_type [DW_FORM_ref4]
+; CHECK: DW_AT_enum_class [DW_FORM_flag_present] (true)
+; CHECK: DW_AT_name [DW_FORM_strp]      ( .debug_str[{{.*}}] = "A")
+
+; CHECK: DW_TAG_enumeration_type [{{.*}}] *
+; CHECK: DW_AT_type [DW_FORM_ref4]
+; CHECK: DW_AT_enum_class [DW_FORM_flag_present] (true)
+; CHECK: DW_AT_name [DW_FORM_strp]          ( .debug_str[{{.*}}] = "B")
+
+; CHECK: DW_TAG_enumeration_type
+; CHECK-NOT: DW_AT_enum_class
+; CHECK: DW_AT_name [DW_FORM_strp]      ( .debug_str[{{.*}}] = "C")
diff --git a/test/DebugInfo/X86/fi-expr.ll b/test/DebugInfo/X86/fi-expr.ll
new file mode 100644
index 0000000..2434abf
--- /dev/null
+++ b/test/DebugInfo/X86/fi-expr.ll
@@ -0,0 +1,42 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin -o - %t.ll -filetype=obj \
+; RUN:   | llvm-dwarfdump -v -debug-info - | FileCheck %s
+; A hand-crafted FrameIndex location with a DW_OP_deref.
+; CHECK: DW_TAG_formal_parameter
+;                                          fbreg -8, deref
+; CHECK-NEXT: DW_AT_location {{.*}} (DW_OP_fbreg -8, DW_OP_deref)
+; CHECK-NEXT: DW_AT_name {{.*}} "foo"
+
+define void @f(i8* %bar) !dbg !6 {
+entry:
+  %foo.addr = alloca i8*
+  store i8* %bar, i8** %foo.addr
+  call void @llvm.dbg.declare(metadata i8** %foo.addr, metadata !12, metadata !13), !dbg !14
+  ret void, !dbg !15
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata)
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "t.c", directory: "/")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!6 = distinct !DISubprogram(name: "f", scope: !1, file: !1, line: 1, type: !7, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!7 = !DISubroutineType(types: !8)
+!8 = !{null, !9}
+!9 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !10, size: 64)
+!10 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !11)
+!11 = !DIBasicType(name: "char", size: 8, encoding: DW_ATE_signed_char)
+!12 = !DILocalVariable(name: "foo", arg: 1, scope: !6, file: !1, line: 1, type: !10)
+!13 = !DIExpression(DW_OP_deref)
+!14 = !DILocation(line: 1, scope: !6)
+!15 = !DILocation(line: 1, scope: !6)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/float_const.ll b/test/DebugInfo/X86/float_const.ll
new file mode 100644
index 0000000..2ad0400
--- /dev/null
+++ b/test/DebugInfo/X86/float_const.ll
@@ -0,0 +1,58 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple < %t.ll -filetype=obj | llvm-dwarfdump -v -debug-info - | FileCheck %s
+; from (at -Os):
+; void foo() {
+;   float a = 3.14;
+;   *(int *)&a = 0;
+; }
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind optsize readnone uwtable
+define void @foo() #0 !dbg !7 {
+entry:
+  tail call void @llvm.dbg.declare(metadata float* undef, metadata !13, metadata !19), !dbg !20
+  tail call void @llvm.dbg.value(metadata i32 1078523331, metadata !13, metadata !19), !dbg !20
+  tail call void @llvm.dbg.value(metadata i32 0, metadata !13, metadata !19), !dbg !20
+; CHECK:  DW_AT_const_value [DW_FORM_sdata]    (0)
+; CHECK-NEXT: DW_AT_name {{.*}}"a"
+  ret void, !dbg !21
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind optsize readnone uwtable }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!15, !16, !17}
+!llvm.ident = !{!18}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.7.0 (trunk 227686)", isOptimized: true, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !3, globals: !2, imports: !2)
+!1 = !DIFile(filename: "foo.c", directory: "")
+!2 = !{}
+!3 = !{!4}
+!4 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !5)
+!5 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!7 = distinct !DISubprogram(name: "foo", line: 1, isLocal: false, isDefinition: true, isOptimized: true, unit: !0, scopeLine: 1, file: !8, scope: !9, type: !10, retainedNodes: !12)
+!8 = !DIFile(filename: "foo.c", directory: "")
+!9 = !DIFile(filename: "foo.c", directory: "")
+!10 = !DISubroutineType(types: !11)
+!11 = !{null}
+!12 = !{!13}
+!13 = !DILocalVariable(name: "a", line: 2, scope: !7, file: !9, type: !14)
+!14 = !DIBasicType(tag: DW_TAG_base_type, name: "float", size: 32, align: 32, encoding: DW_ATE_float)
+!15 = !{i32 2, !"Dwarf Version", i32 2}
+!16 = !{i32 2, !"Debug Info Version", i32 3}
+!17 = !{i32 1, !"PIC Level", i32 2}
+!18 = !{!"clang version 3.7.0 (trunk 227686)"}
+!19 = !DIExpression()
+!20 = !DILocation(line: 2, column: 9, scope: !7)
+!21 = !DILocation(line: 4, column: 1, scope: !7)
diff --git a/test/DebugInfo/X86/frame-register.ll b/test/DebugInfo/X86/frame-register.ll
new file mode 100644
index 0000000..33724c3
--- /dev/null
+++ b/test/DebugInfo/X86/frame-register.ll
@@ -0,0 +1,62 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple %t.ll -filetype=obj -o - | llvm-dwarfdump -v --debug-info - | FileCheck %s
+; CHECK: DW_TAG_variable
+; CHECK-NEXT: DW_AT_location [DW_FORM_exprloc]      (DW_OP_fbreg +0)
+; CHECK-NEXT: DW_AT_name {{.*}}"i"
+
+target datalayout = "e-m:e-p:32:32-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind uwtable
+declare i32 @foo(i32 %i) #0
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+; Function Attrs: nounwind uwtable
+define i32 @main() #0 !dbg !9 {
+entry:
+  %retval = alloca i32, align 4
+  %i = alloca i32, align 4
+  store i32 0, i32* %retval
+  call void @llvm.dbg.declare(metadata i32* %i, metadata !20, metadata !16), !dbg !21
+  store i32 20, i32* %i, align 4, !dbg !21
+  %0 = load i32, i32* %i, align 4, !dbg !22
+  %call = call i32 @foo(i32 %0), !dbg !23
+  ret i32 %call, !dbg !24
+}
+
+attributes #0 = { nounwind uwtable  }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!12, !13}
+!llvm.ident = !{!14}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.7.0", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "x.c", directory: "")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "foo", line: 2, isLocal: false, isDefinition: true, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 3, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "x.c", directory: "")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8, !8}
+!8 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = distinct !DISubprogram(name: "main", line: 8, isLocal: false, isDefinition: true, isOptimized: false, unit: !0, scopeLine: 9, file: !1, scope: !5, type: !10, retainedNodes: !2)
+!10 = !DISubroutineType(types: !11)
+!11 = !{!8}
+!12 = !{i32 2, !"Dwarf Version", i32 4}
+!13 = !{i32 2, !"Debug Info Version", i32 3}
+!14 = !{!"clang version 3.7.0"}
+!15 = !DILocalVariable(name: "i", line: 2, arg: 1, scope: !4, file: !5, type: !8)
+!16 = !DIExpression()
+!17 = !DILocation(line: 2, column: 10, scope: !4)
+!18 = !DILocation(line: 4, column: 10, scope: !4)
+!19 = !DILocation(line: 4, column: 3, scope: !4)
+!20 = !DILocalVariable(name: "i", line: 10, scope: !9, file: !5, type: !8)
+!21 = !DILocation(line: 10, column: 7, scope: !9)
+!22 = !DILocation(line: 11, column: 15, scope: !9)
+!23 = !DILocation(line: 11, column: 10, scope: !9)
+!24 = !DILocation(line: 11, column: 3, scope: !9)
diff --git a/test/DebugInfo/X86/ghost-sdnode-dbgvalues.ll b/test/DebugInfo/X86/ghost-sdnode-dbgvalues.ll
new file mode 100644
index 0000000..9ce1cfd
--- /dev/null
+++ b/test/DebugInfo/X86/ghost-sdnode-dbgvalues.ll
@@ -0,0 +1,110 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-macosx10.10.0 -o %t %t.ll
+
+; Testcase generated from:
+; #include <stdint.h>
+; int foo(int a) {
+;     int b = (int16_t)a + 8;
+;     int c = (int16_t)b + 8;
+;     int d = (int16_t)c + 8;
+;     int e = (int16_t)d + 8;
+;     int f = (int16_t)e + 8;
+;     return f;
+; }
+; by emitting the IR and then manually applying mem2reg to it.
+
+; This testcase would trigger the assert commited along with it if the
+; fix of r221709 isn't applied. There is no other check except the successful
+; run of llc.
+; What happened before r221709, is that SDDbgInfo (the data structure helping
+; SelectionDAG to keep track of dbg.values) kept a map keyed by SDNode pointers.
+; This map was never purged when the SDNodes were deallocated and thus if a new
+; SDNode was allocated in the same memory, it would have an entry in the SDDbgInfo
+; map upon creation (Reallocation in the same memory can happen easily as
+; SelectionDAG uses a Recycling allocator). This behavior could turn into a
+; pathological memory consumption explosion if the DAG combiner hit the 'right'
+; allocation patterns as could be seen in PR20893.
+; By nature, this test could bitrot quite easily. If it doesn't trigger an assert
+; when run with r221709 reverted, then it really doesn't test anything anymore.
+
+; Function Attrs: nounwind ssp uwtable
+define i32 @foo(i32 %a) #0 !dbg !8 {
+entry:
+  call void @llvm.dbg.value(metadata i32 %a, metadata !16, metadata !17), !dbg !18
+  %conv = trunc i32 %a to i16, !dbg !19
+  %conv1 = sext i16 %conv to i32, !dbg !19
+  %add = add nsw i32 %conv1, 8, !dbg !19
+  call void @llvm.dbg.value(metadata i32 %add, metadata !20, metadata !17), !dbg !21
+  %conv2 = trunc i32 %add to i16, !dbg !22
+  %conv3 = sext i16 %conv2 to i32, !dbg !22
+  %add4 = add nsw i32 %conv3, 8, !dbg !22
+  call void @llvm.dbg.value(metadata i32 %add4, metadata !23, metadata !17), !dbg !24
+  %conv5 = trunc i32 %add4 to i16, !dbg !25
+  %conv6 = sext i16 %conv5 to i32, !dbg !25
+  %add7 = add nsw i32 %conv6, 8, !dbg !25
+  call void @llvm.dbg.value(metadata i32 %add7, metadata !26, metadata !17), !dbg !27
+  %conv8 = trunc i32 %add7 to i16, !dbg !28
+  %conv9 = sext i16 %conv8 to i32, !dbg !28
+  %add10 = add nsw i32 %conv9, 8, !dbg !28
+  call void @llvm.dbg.value(metadata i32 %add10, metadata !29, metadata !17), !dbg !30
+  %conv11 = trunc i32 %add10 to i16, !dbg !31
+  %conv12 = sext i16 %conv11 to i32, !dbg !31
+  %add13 = add nsw i32 %conv12, 8, !dbg !31
+  call void @llvm.dbg.value(metadata i32 %add13, metadata !32, metadata !17), !dbg !33
+  ret i32 %add13, !dbg !34
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!13, !14}
+!llvm.ident = !{!15}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.6.0 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !3, globals: !2, imports: !2)
+!1 = !DIFile(filename: "ghost-sdnode-dbgvalues.c", directory: "/tmp")
+!2 = !{}
+!3 = !{!4}
+!4 = !DIDerivedType(tag: DW_TAG_typedef, name: "int16_t", line: 30, file: !5, baseType: !6)
+!5 = !DIFile(filename: "/usr/include/sys/_types/_int16_t.h", directory: "/tmp")
+!6 = !DIBasicType(tag: DW_TAG_base_type, name: "short", size: 16, align: 16, encoding: DW_ATE_signed)
+!8 = distinct !DISubprogram(name: "foo", line: 3, isLocal: false, isDefinition: true, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 3, file: !1, scope: !9, type: !10, retainedNodes: !2)
+!9 = !DIFile(filename: "ghost-sdnode-dbgvalues.c", directory: "/tmp")
+!10 = !DISubroutineType(types: !11)
+!11 = !{!12, !12}
+!12 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!13 = !{i32 2, !"Dwarf Version", i32 2}
+!14 = !{i32 2, !"Debug Info Version", i32 3}
+!15 = !{!"clang version 3.6.0 "}
+!16 = !DILocalVariable(name: "a", line: 3, arg: 1, scope: !8, file: !9, type: !12)
+!17 = !DIExpression()
+!18 = !DILocation(line: 3, column: 13, scope: !8)
+!19 = !DILocation(line: 4, column: 5, scope: !8)
+!20 = !DILocalVariable(name: "b", line: 4, scope: !8, file: !9, type: !12)
+!21 = !DILocation(line: 4, column: 9, scope: !8)
+!22 = !DILocation(line: 5, column: 5, scope: !8)
+!23 = !DILocalVariable(name: "c", line: 5, scope: !8, file: !9, type: !12)
+!24 = !DILocation(line: 5, column: 9, scope: !8)
+!25 = !DILocation(line: 6, column: 5, scope: !8)
+!26 = !DILocalVariable(name: "d", line: 6, scope: !8, file: !9, type: !12)
+!27 = !DILocation(line: 6, column: 9, scope: !8)
+!28 = !DILocation(line: 7, column: 5, scope: !8)
+!29 = !DILocalVariable(name: "e", line: 7, scope: !8, file: !9, type: !12)
+!30 = !DILocation(line: 7, column: 9, scope: !8)
+!31 = !DILocation(line: 8, column: 5, scope: !8)
+!32 = !DILocalVariable(name: "f", line: 8, scope: !8, file: !9, type: !12)
+!33 = !DILocation(line: 8, column: 9, scope: !8)
+!34 = !DILocation(line: 9, column: 5, scope: !8)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/header.ll b/test/DebugInfo/X86/header.ll
new file mode 100644
index 0000000..c15b024
--- /dev/null
+++ b/test/DebugInfo/X86/header.ll
@@ -0,0 +1,34 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple x86_64-pc-linux < %t.ll  | FileCheck %s
+
+; Test that we don't pollute the start of the file with debug sections
+
+; CHECK:       .text
+; CHECK-NEXT: .file	"<stdin>"
+; CHECK-NEXT: .globl	f
+; CHECK-NEXT: .p2align	4, 0x90
+; CHECK-NEXT: .type	f,@function
+; CHECK-NEXT: f:                                      # @f
+
+; CHECK: .section .debug_str
+
+define void @f() !dbg !4 {
+  ret void, !dbg !9
+}
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!7, !8}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "foo", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "/foo/test.c", directory: "/foo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "f", scope: !1, file: !1, line: 1, type: !5, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !2)
+!5 = !DISubroutineType(types: !6)
+!6 = !{null}
+!7 = !{i32 2, !"Dwarf Version", i32 4}
+!8 = !{i32 2, !"Debug Info Version", i32 3}
+!9 = !DILocation(line: 1, column: 15, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/inline-member-function.ll b/test/DebugInfo/X86/inline-member-function.ll
new file mode 100644
index 0000000..dce5a40
--- /dev/null
+++ b/test/DebugInfo/X86/inline-member-function.ll
@@ -0,0 +1,105 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-linux -O0 -filetype=obj < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck %s
+
+; From source:
+; struct foo {
+;   int __attribute__((always_inline)) func(int x) { return x + 2; }
+; };
+
+; int i;
+
+; int main() {
+;   return foo().func(i);
+; }
+
+; CHECK: DW_TAG_structure_type
+; CHECK:   DW_TAG_subprogram
+
+; But make sure we emit DW_AT_object_pointer on the abstract definition.
+; CHECK: [[ABSTRACT_ORIGIN:.*]]: DW_TAG_subprogram
+; CHECK-NOT: {{NULL|TAG}}
+; CHECK: DW_AT_specification {{.*}} "_ZN3foo4funcEi"
+; CHECK-NOT: {{NULL|TAG}}
+; CHECK: DW_AT_object_pointer
+
+; Ensure we omit DW_AT_object_pointer on inlined subroutines.
+; CHECK: DW_TAG_inlined_subroutine
+; CHECK-NEXT: DW_AT_abstract_origin {{.*}} {[[ABSTRACT_ORIGIN]]} "_ZN3foo4funcEi"
+; CHECK-NOT: NULL
+; CHECK-NOT: DW_AT_object_pointer
+; CHECK: DW_TAG_formal_parameter
+; CHECK-NOT: DW_AT_artificial
+; CHECK: DW_TAG
+
+source_filename = "test/DebugInfo/X86/inline-member-function.ll"
+
+%struct.foo = type { i8 }
+
+@i = global i32 0, align 4, !dbg !0
+
+; Function Attrs: uwtable
+define i32 @main() #0 !dbg !17 {
+entry:
+  %this.addr.i = alloca %struct.foo*, align 8
+  %x.addr.i = alloca i32, align 4
+  %retval = alloca i32, align 4
+  %tmp = alloca %struct.foo, align 1
+  store i32 0, i32* %retval
+  %0 = load i32, i32* @i, align 4, !dbg !20
+  store %struct.foo* %tmp, %struct.foo** %this.addr.i, align 8
+  call void @llvm.dbg.declare(metadata %struct.foo** %this.addr.i, metadata !21, metadata !24), !dbg !25
+  store i32 %0, i32* %x.addr.i, align 4
+  call void @llvm.dbg.declare(metadata i32* %x.addr.i, metadata !26, metadata !24), !dbg !27
+  %this1.i = load %struct.foo*, %struct.foo** %this.addr.i
+  %1 = load i32, i32* %x.addr.i, align 4, !dbg !27
+  %add.i = add nsw i32 %1, 2, !dbg !27
+  ret i32 %add.i, !dbg !20
+}
+
+; Function Attrs: nounwind readnone
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+attributes #0 = { uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!4}
+!llvm.module.flags = !{!14, !15}
+!llvm.ident = !{!16}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "i", scope: null, file: !2, line: 5, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "inline.cpp", directory: "/tmp/dbginfo")
+!3 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!4 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.5.0 ", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !5, retainedTypes: !6, globals: !13, imports: !5)
+!5 = !{}
+!6 = !{!7}
+!7 = !DICompositeType(tag: DW_TAG_structure_type, name: "foo", file: !2, line: 1, size: 8, align: 8, elements: !8, identifier: "_ZTS3foo")
+!8 = !{!9}
+!9 = !DISubprogram(name: "func", linkageName: "_ZN3foo4funcEi", scope: !7, file: !2, line: 2, type: !10, isLocal: false, isDefinition: false, scopeLine: 2, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false)
+!10 = !DISubroutineType(types: !11)
+!11 = !{!3, !12, !3}
+!12 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !7, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!13 = !{!0}
+!14 = !{i32 2, !"Dwarf Version", i32 4}
+!15 = !{i32 1, !"Debug Info Version", i32 3}
+!16 = !{!"clang version 3.5.0 "}
+!17 = distinct !DISubprogram(name: "main", scope: !2, file: !2, line: 7, type: !18, isLocal: false, isDefinition: true, scopeLine: 7, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !4, retainedNodes: !5)
+!18 = !DISubroutineType(types: !19)
+!19 = !{!3}
+!20 = !DILocation(line: 8, scope: !17)
+!21 = !DILocalVariable(name: "this", arg: 1, scope: !22, type: !23, flags: DIFlagArtificial | DIFlagObjectPointer)
+!22 = distinct !DISubprogram(name: "func", linkageName: "_ZN3foo4funcEi", scope: !7, file: !2, line: 2, type: !10, isLocal: false, isDefinition: true, scopeLine: 2, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !4, declaration: !9, retainedNodes: !5)
+!23 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !7, size: 64, align: 64)
+!24 = !DIExpression()
+!25 = !DILocation(line: 0, scope: !22, inlinedAt: !20)
+!26 = !DILocalVariable(name: "x", arg: 2, scope: !22, file: !2, line: 2, type: !3)
+!27 = !DILocation(line: 2, scope: !22, inlinedAt: !20)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/inlined-formal-parameter.ll b/test/DebugInfo/X86/inlined-formal-parameter.ll
new file mode 100644
index 0000000..9adbe5c
--- /dev/null
+++ b/test/DebugInfo/X86/inlined-formal-parameter.ll
@@ -0,0 +1,79 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj -o %t.o %t.ll
+; RUN: llvm-dwarfdump -v %t.o | FileCheck %s
+
+; Testcase generated using 'clang -g -O2 -S -emit-llvm' from the following:
+;; void sink(void);
+;; static __attribute__((always_inline)) void bar(int a) { sink(); }
+;; void foo(void) {
+;;   bar(0);
+;;   bar(0);
+;; }
+
+; Check that we have formal parameters for 'a' in both inlined subroutines.
+; CHECK: .debug_info
+; CHECK:       DW_TAG_inlined_subroutine
+; CHECK-NEXT:    DW_AT_abstract_origin {{.*}} "bar"
+; CHECK:         DW_TAG_formal_parameter
+; CHECK-NEXT:      DW_AT_const_value
+; CHECK-NEXT:      DW_AT_abstract_origin {{.*}} "a"
+; CHECK:       DW_TAG_inlined_subroutine
+; CHECK-NEXT:    DW_AT_abstract_origin {{.*}} "bar"
+; CHECK:         DW_TAG_formal_parameter
+; CHECK-NEXT:      DW_AT_location [DW_FORM_data4]	(
+; CHECK-NEXT:        {{.*}}, {{.*}}: DW_OP_consts +0)
+; CHECK-NEXT:      DW_AT_abstract_origin {{.*}} "a"
+
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind ssp uwtable
+define void @foo() #0 !dbg !4 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 0, metadata !12, metadata !17) #3, !dbg !18
+  tail call void @sink() #3, !dbg !20
+  tail call void @llvm.dbg.value(metadata i32 0, metadata !12, metadata !17) #3, !dbg !21
+  tail call void @sink() #3, !dbg !23
+  ret void, !dbg !24
+}
+
+declare void @sink()
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #2
+
+attributes #0 = { nounwind ssp uwtable  }
+attributes #2 = { nounwind readnone }
+attributes #3 = { nounwind }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!13, !14, !15}
+!llvm.ident = !{!16}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 3.7.0 (trunk 235110) (llvm/trunk 235108)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "t.c", directory: "/path/to/dir")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 3, type: !5, isLocal: false, isDefinition: true, scopeLine: 3, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !2)
+!5 = !DISubroutineType(types: !6)
+!6 = !{null}
+!7 = distinct !DISubprogram(name: "bar", scope: !1, file: !1, line: 2, type: !8, isLocal: true, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !11)
+!8 = !DISubroutineType(types: !9)
+!9 = !{null, !10}
+!10 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!11 = !{!12}
+!12 = !DILocalVariable(name: "a", arg: 1, scope: !7, file: !1, line: 2, type: !10)
+!13 = !{i32 2, !"Dwarf Version", i32 2}
+!14 = !{i32 2, !"Debug Info Version", i32 3}
+!15 = !{i32 1, !"PIC Level", i32 2}
+!16 = !{!"clang version 3.7.0 (trunk 235110) (llvm/trunk 235108)"}
+!17 = !DIExpression()
+!18 = !DILocation(line: 2, column: 52, scope: !7, inlinedAt: !19)
+!19 = distinct !DILocation(line: 4, column: 3, scope: !4)
+!20 = !DILocation(line: 2, column: 57, scope: !7, inlinedAt: !19)
+!21 = !DILocation(line: 2, column: 52, scope: !7, inlinedAt: !22)
+!22 = distinct !DILocation(line: 5, column: 3, scope: !4)
+!23 = !DILocation(line: 2, column: 57, scope: !7, inlinedAt: !22)
+!24 = !DILocation(line: 6, column: 1, scope: !4)
diff --git a/test/DebugInfo/X86/isel-cse-line.ll b/test/DebugInfo/X86/isel-cse-line.ll
new file mode 100644
index 0000000..f650999
--- /dev/null
+++ b/test/DebugInfo/X86/isel-cse-line.ll
@@ -0,0 +1,109 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=asm -fast-isel=false -O0 < %t.ll | FileCheck %s
+;
+; Generated by:
+; clang -emit-llvm -S -g test.cpp
+
+; typedef double         fp_t;
+; typedef unsigned long  int_t;
+;
+; int_t glb_start      = 17;
+; int_t glb_end        = 42;
+;
+; int main()
+; {
+;   int_t start = glb_start;
+;   int_t end   = glb_end;
+;
+;   fp_t dbl_start = (fp_t) start;
+;   fp_t dbl_end   = (fp_t) end;
+;
+;   return 0;
+; }
+
+; SelectionDAG performs CSE on constant pool loads. Make sure line numbers
+; from such nodes are not propagated. Doing so results in oscillating line numbers.
+
+; CHECK: .loc 1 12
+; CHECK: .loc 1 13
+; CHECK-NOT: .loc 1 12
+
+; ModuleID = 't.cpp'
+source_filename = "test/DebugInfo/X86/isel-cse-line.ll"
+target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+@glb_start = global i64 17, align 8, !dbg !0
+@glb_end = global i64 42, align 8, !dbg !9
+
+define i32 @main() !dbg !16 {
+  %1 = alloca i32, align 4
+  %2 = alloca i64, align 8
+  %3 = alloca i64, align 8
+  %4 = alloca double, align 8
+  %5 = alloca double, align 8
+  store i32 0, i32* %1, align 4
+  call void @llvm.dbg.declare(metadata i64* %2, metadata !20, metadata !21), !dbg !22
+  %6 = load i64, i64* @glb_start, align 8, !dbg !23
+  store i64 %6, i64* %2, align 8, !dbg !22
+  call void @llvm.dbg.declare(metadata i64* %3, metadata !24, metadata !21), !dbg !25
+  %7 = load i64, i64* @glb_end, align 8, !dbg !26
+  store i64 %7, i64* %3, align 8, !dbg !25
+  call void @llvm.dbg.declare(metadata double* %4, metadata !27, metadata !21), !dbg !28
+  %8 = load i64, i64* %2, align 8, !dbg !29
+  %9 = uitofp i64 %8 to double, !dbg !29
+  store double %9, double* %4, align 8, !dbg !28
+  call void @llvm.dbg.declare(metadata double* %5, metadata !30, metadata !21), !dbg !31
+  %10 = load i64, i64* %3, align 8, !dbg !32
+  %11 = uitofp i64 %10 to double, !dbg !32
+  store double %11, double* %5, align 8, !dbg !31
+  ret i32 0, !dbg !33
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #0
+
+attributes #0 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!13, !14}
+!llvm.ident = !{!15}
+
+!0 = distinct !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "glb_start", scope: !2, file: !3, line: 4, type: !11, isLocal: false, isDefinition: true)
+!2 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !3, producer: "clang version 3.9.0 (trunk 268246)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, retainedTypes: !5, globals: !8)
+!3 = !DIFile(filename: "/home/wpieb/test/D12094.cpp", directory: "/home/wpieb/build/llvm/trunk/llvm-RelWithDebInfo")
+!4 = !{}
+!5 = !{!6}
+!6 = !DIDerivedType(tag: DW_TAG_typedef, name: "fp_t", file: !3, line: 1, baseType: !7)
+!7 = !DIBasicType(name: "double", size: 64, align: 64, encoding: DW_ATE_float)
+!8 = !{!0, !9}
+!9 = distinct !DIGlobalVariableExpression(var: !10, expr: !DIExpression())
+!10 = !DIGlobalVariable(name: "glb_end", scope: !2, file: !3, line: 5, type: !11, isLocal: false, isDefinition: true)
+!11 = !DIDerivedType(tag: DW_TAG_typedef, name: "int_t", file: !3, line: 2, baseType: !12)
+!12 = !DIBasicType(name: "long unsigned int", size: 64, align: 64, encoding: DW_ATE_unsigned)
+!13 = !{i32 2, !"Dwarf Version", i32 4}
+!14 = !{i32 2, !"Debug Info Version", i32 3}
+!15 = !{!"clang version 3.9.0 (trunk 268246)"}
+!16 = distinct !DISubprogram(name: "main", scope: !3, file: !3, line: 7, type: !17, isLocal: false, isDefinition: true, scopeLine: 8, flags: DIFlagPrototyped, isOptimized: false, unit: !2, retainedNodes: !4)
+!17 = !DISubroutineType(types: !18)
+!18 = !{!19}
+!19 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!20 = !DILocalVariable(name: "start", scope: !16, file: !3, line: 9, type: !11)
+!21 = !DIExpression()
+!22 = !DILocation(line: 9, column: 9, scope: !16)
+!23 = !DILocation(line: 9, column: 17, scope: !16)
+!24 = !DILocalVariable(name: "end", scope: !16, file: !3, line: 10, type: !11)
+!25 = !DILocation(line: 10, column: 9, scope: !16)
+!26 = !DILocation(line: 10, column: 17, scope: !16)
+!27 = !DILocalVariable(name: "dbl_start", scope: !16, file: !3, line: 12, type: !6)
+!28 = !DILocation(line: 12, column: 8, scope: !16)
+!29 = !DILocation(line: 12, column: 27, scope: !16)
+!30 = !DILocalVariable(name: "dbl_end", scope: !16, file: !3, line: 13, type: !6)
+!31 = !DILocation(line: 13, column: 8, scope: !16)
+!32 = !DILocation(line: 13, column: 27, scope: !16)
+!33 = !DILocation(line: 15, column: 3, scope: !16)
+
diff --git a/test/DebugInfo/X86/lexical_block.ll b/test/DebugInfo/X86/lexical_block.ll
new file mode 100644
index 0000000..6fb58fe
--- /dev/null
+++ b/test/DebugInfo/X86/lexical_block.ll
@@ -0,0 +1,72 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-linux -O0 -filetype=obj < %t.ll \
+; RUN:     | llvm-dwarfdump -v -debug-info - | FileCheck --check-prefix=CHECK --check-prefix=CHECK-V4 %s
+; RUN: llc -mtriple=x86_64-linux -dwarf-version=3 -O0 -filetype=obj < %t.ll \
+; RUN:     | llvm-dwarfdump -v -debug-info - | FileCheck --check-prefix=CHECK --check-prefix=CHECK-V3 %s
+
+; Check that we emit DW_TAG_lexical_block and that it has the right encoding
+; depending on the dwarf version.
+
+; CHECK: DW_TAG_lexical_block
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_low_pc [DW_FORM_addr]
+; CHECK-NOT: DW_TAG
+; CHECK-V4: DW_AT_high_pc [DW_FORM_data4]
+; CHECK-V3: DW_AT_high_pc [DW_FORM_addr]
+
+; Test case produced from:
+; void b() {
+;   if (int i = 3)
+;     return;
+; }
+
+; Function Attrs: nounwind uwtable
+define void @_Z1bv() #0 !dbg !4 {
+entry:
+  %i = alloca i32, align 4
+  call void @llvm.dbg.declare(metadata i32* %i, metadata !11, metadata !DIExpression()), !dbg !14
+  store i32 3, i32* %i, align 4, !dbg !14
+  %0 = load i32, i32* %i, align 4, !dbg !14
+  %tobool = icmp ne i32 %0, 0, !dbg !14
+  br i1 %tobool, label %if.then, label %if.end, !dbg !14
+
+if.then:                                          ; preds = %entry
+  br label %if.end, !dbg !15
+
+if.end:                                           ; preds = %if.then, %entry
+  ret void, !dbg !16
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!8, !9}
+!llvm.ident = !{!10}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.5.0 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "lexical_block.cpp", directory: "/tmp/dbginfo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "b", linkageName: "_Z1bv", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 1, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "lexical_block.cpp", directory: "/tmp/dbginfo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{null}
+!8 = !{i32 2, !"Dwarf Version", i32 4}
+!9 = !{i32 1, !"Debug Info Version", i32 3}
+!10 = !{!"clang version 3.5.0 "}
+!11 = !DILocalVariable(name: "i", line: 2, scope: !12, file: !5, type: !13)
+!12 = distinct !DILexicalBlock(line: 2, column: 0, file: !1, scope: !4)
+!13 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!14 = !DILocation(line: 2, scope: !12)
+!15 = !DILocation(line: 3, scope: !12)
+!16 = !DILocation(line: 4, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/linkage-name.ll b/test/DebugInfo/X86/linkage-name.ll
new file mode 100644
index 0000000..0c92532
--- /dev/null
+++ b/test/DebugInfo/X86/linkage-name.ll
@@ -0,0 +1,67 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-macosx %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -v -debug-info %t | FileCheck %s
+
+; CHECK: DW_TAG_subprogram [9] *
+; CHECK-NOT: DW_AT_{{(MIPS_)?}}linkage_name
+; CHECK: DW_AT_specification
+
+source_filename = "test/DebugInfo/X86/linkage-name.ll"
+
+%class.A = type { i8 }
+
+@a = global %class.A zeroinitializer, align 1, !dbg !0
+
+; Function Attrs: nounwind ssp uwtable
+define i32 @_ZN1A1aEi(%class.A* %this, i32 %b) #0 align 2 !dbg !14 {
+entry:
+  %this.addr = alloca %class.A*, align 8
+  %b.addr = alloca i32, align 4
+  store %class.A* %this, %class.A** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %class.A** %this.addr, metadata !15, metadata !17), !dbg !18
+  store i32 %b, i32* %b.addr, align 4
+  call void @llvm.dbg.declare(metadata i32* %b.addr, metadata !19, metadata !17), !dbg !20
+  %this1 = load %class.A*, %class.A** %this.addr
+  %0 = load i32, i32* %b.addr, align 4, !dbg !21
+  ret i32 %0, !dbg !21
+}
+
+; Function Attrs: nounwind readnone
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind ssp uwtable }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!10}
+!llvm.module.flags = !{!13}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "a", scope: null, file: !2, line: 9, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "foo.cpp", directory: "/Users/echristo")
+!3 = !DICompositeType(tag: DW_TAG_class_type, name: "A", file: !2, line: 1, size: 8, align: 8, elements: !4)
+!4 = !{!5}
+!5 = !DISubprogram(name: "a", linkageName: "_ZN1A1aEi", scope: !3, file: !2, line: 2, type: !6, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrivate | DIFlagPrototyped, isOptimized: false)
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8, !9, !8}
+!8 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!9 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !3, size: 64, align: 64, flags: DIFlagArtificial)
+!10 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.1 (trunk 152691) (llvm/trunk 152692)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !11, retainedTypes: !11, globals: !12, imports: !11)
+!11 = !{}
+!12 = !{!0}
+!13 = !{i32 1, !"Debug Info Version", i32 3}
+!14 = distinct !DISubprogram(name: "a", linkageName: "_ZN1A1aEi", scope: null, file: !2, line: 5, type: !6, isLocal: false, isDefinition: true, scopeLine: 5, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !10, declaration: !5)
+!15 = !DILocalVariable(name: "this", arg: 1, scope: !14, file: !2, line: 5, type: !16, flags: DIFlagArtificial)
+!16 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !3, size: 64, align: 64)
+!17 = !DIExpression()
+!18 = !DILocation(line: 5, column: 8, scope: !14)
+!19 = !DILocalVariable(name: "b", arg: 2, scope: !14, file: !2, line: 5, type: !8)
+!20 = !DILocation(line: 5, column: 14, scope: !14)
+!21 = !DILocation(line: 6, column: 4, scope: !22)
+!22 = distinct !DILexicalBlock(scope: !14, file: !2, line: 5, column: 17)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/live-debug-variables.ll b/test/DebugInfo/X86/live-debug-variables.ll
new file mode 100644
index 0000000..0ac825c
--- /dev/null
+++ b/test/DebugInfo/X86/live-debug-variables.ll
@@ -0,0 +1,87 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-linux-gnu -filetype=obj -o - %t.ll | llvm-dwarfdump -debug-loc - | FileCheck %s
+
+; The test inlines the function F four times, with each inlined variable for
+; "i4" sharing the same virtual register. This means the live interval of the
+; register spans all of the inlined callsites, extending beyond the lexical
+; scope of each. Later during register allocation the live interval is split
+; into multiple intervals. Check that this does not generate multiple entries
+; within the debug location (see PR33730).
+;
+; Generated from:
+;
+; extern int foobar(int, int, int, int, int);
+; 
+; int F(int i1, int i2, int i3, int i4, int i5) {
+;   return foobar(i1, i2, i3, i4, i5);
+; }
+; 
+; int foo(int a, int b, int c, int d, int e) {
+;   return F(a,b,c,d,e) +
+;          F(a,b,c,d,e) +
+;          F(a,b,c,d,e) +
+;          F(a,b,c,d,e);
+; }
+
+; CHECK:      .debug_loc contents:
+; CHECK-NEXT: 0x00000000:
+;   We currently emit an entry for the function prologue, too, which could be optimized away.
+; CHECK:              [0x000000000000001f, 0x000000000000003c): DW_OP_reg3 RBX
+;   We should only have one entry inside the function.
+; CHECK-NOT: :
+
+declare i32 @foobar(i32, i32, i32, i32, i32)
+
+define i32 @foo(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e) !dbg !25 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 %d, i64 0, metadata !15, metadata !17) #3, !dbg !41
+  %call.i = tail call i32 @foobar(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e) #3, !dbg !43
+  %call.i21 = tail call i32 @foobar(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e) #3, !dbg !50
+  %add = add nsw i32 %call.i21, %call.i, !dbg !51
+  %call.i22 = tail call i32 @foobar(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e) #3, !dbg !58
+  %add3 = add nsw i32 %add, %call.i22, !dbg !59
+  %call.i23 = tail call i32 @foobar(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e) #3, !dbg !66
+  %add5 = add nsw i32 %add3, %call.i23, !dbg !67
+  ret i32 %add5, !dbg !68
+}
+
+declare void @llvm.dbg.value(metadata, i64, metadata, metadata)
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4, !5}
+!llvm.ident = !{!6}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 6.0.0 (trunk 308976)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "foo.c", directory: "")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{i32 1, !"wchar_size", i32 4}
+!6 = !{!"clang version 6.0.0 (trunk 308976)"}
+!7 = distinct !DISubprogram(name: "F", scope: !1, file: !1, line: 3, type: !8, isLocal: false, isDefinition: true, scopeLine: 3, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !11)
+!8 = !DISubroutineType(types: !9)
+!9 = !{!10, !10, !10, !10, !10, !10}
+!10 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!11 = !{!15}
+!15 = !DILocalVariable(name: "i4", arg: 4, scope: !7, file: !1, line: 3, type: !10)
+!17 = !DIExpression()
+!25 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 7, type: !8, isLocal: false, isDefinition: true, scopeLine: 7, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !26)
+!26 = !{}
+!38 = distinct !DILocation(line: 8, column: 10, scope: !25)
+!41 = !DILocation(line: 3, column: 35, scope: !7, inlinedAt: !38)
+!43 = !DILocation(line: 4, column: 10, scope: !7, inlinedAt: !38)
+!45 = distinct !DILocation(line: 9, column: 10, scope: !25)
+!50 = !DILocation(line: 4, column: 10, scope: !7, inlinedAt: !45)
+!51 = !DILocation(line: 8, column: 23, scope: !25)
+!53 = distinct !DILocation(line: 10, column: 10, scope: !25)
+!58 = !DILocation(line: 4, column: 10, scope: !7, inlinedAt: !53)
+!59 = !DILocation(line: 9, column: 23, scope: !25)
+!61 = distinct !DILocation(line: 11, column: 10, scope: !25)
+!66 = !DILocation(line: 4, column: 10, scope: !7, inlinedAt: !61)
+!67 = !DILocation(line: 10, column: 23, scope: !25)
+!68 = !DILocation(line: 8, column: 3, scope: !25)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/low-pc-cu.ll b/test/DebugInfo/X86/low-pc-cu.ll
new file mode 100644
index 0000000..921e5d2
--- /dev/null
+++ b/test/DebugInfo/X86/low-pc-cu.ll
@@ -0,0 +1,51 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin -filetype=obj < %t.ll \
+; RUN:     | llvm-dwarfdump -v -debug-info - | FileCheck %s --check-prefix=CHECK --check-prefix=CHECK-V4
+; RUN: llc -mtriple=x86_64-apple-darwin -filetype=obj -dwarf-version=3 < %t.ll \
+; RUN:     | llvm-dwarfdump -v -debug-info - | FileCheck %s --check-prefix=CHECK --check-prefix=CHECK-V3
+
+
+; Check that we use DW_AT_low_pc and that it has the right encoding depending
+; on dwarf version.
+
+; CHECK: DW_TAG_compile_unit [1]
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_low_pc [DW_FORM_addr]       (0x0000000000000000)
+; CHECK-NOT: DW_TAG
+; CHECK-V3: DW_AT_high_pc [DW_FORM_addr]
+; CHECK-V4: DW_AT_high_pc [DW_FORM_data4]
+; CHECK: DW_TAG_subprogram [2]
+; CHECK-NOT: DW_TAG
+; CHECK: DW_AT_low_pc [DW_FORM_addr]
+; CHECK-NOT: DW_TAG
+; CHECK-V3: DW_AT_high_pc [DW_FORM_addr]
+; CHECK-V4: DW_AT_high_pc [DW_FORM_data4]
+
+; Function Attrs: nounwind uwtable
+define void @z() #0 !dbg !4 {
+entry:
+  ret void, !dbg !11
+}
+
+attributes #0 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!8, !9}
+!llvm.ident = !{!10}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.5.0 (trunk 204164) (llvm/trunk 204183)", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "z.c", directory: "/usr/local/google/home/echristo")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "z", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 1, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "z.c", directory: "/usr/local/google/home/echristo")
+!6 = !DISubroutineType(types: !7)
+!7 = !{null}
+!8 = !{i32 2, !"Dwarf Version", i32 4}
+!9 = !{i32 1, !"Debug Info Version", i32 3}
+!10 = !{!"clang version 3.5.0 (trunk 204164) (llvm/trunk 204183)"}
+!11 = !DILocation(line: 1, scope: !4)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/mi-print.ll b/test/DebugInfo/X86/mi-print.ll
new file mode 100644
index 0000000..0b37a49
--- /dev/null
+++ b/test/DebugInfo/X86/mi-print.ll
@@ -0,0 +1,59 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -debug -mtriple x86_64-apple-darwin < %t.ll -o /dev/null 2>&1 | FileCheck %s
+; REQUIRES: asserts
+; Check that llc -debug actually prints variables and locations, rather than
+; crashing.
+
+; CHECK: DBG_VALUE
+
+; Generated using `clang -g -O2 -S -emit-llvm -g` on the following source:
+;
+; static int foo(int x) { return x; }
+; int bar(int x) { return foo(x); }
+
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind readnone ssp uwtable
+define i32 @bar(i32 %x) #0 !dbg !4 {
+entry:
+  tail call void @llvm.dbg.value(metadata i32 %x, metadata !9, metadata !17), !dbg !18
+  tail call void @llvm.dbg.value(metadata i32 %x, metadata !19, metadata !17), !dbg !21
+  ret i32 %x, !dbg !22
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind readnone ssp uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="core2" "unsafe-fp-math"="false" "use-soft-float"="false" }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!13, !14, !15}
+!llvm.ident = !{!16}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 3.7.0 (trunk 233919) (llvm/trunk 233920)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "t.c", directory: "/Users/dexonsmith/data/llvm/debug-info/test/DebugInfo/X86")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "bar", scope: !1, file: !1, line: 2, type: !5, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !8)
+!5 = !DISubroutineType(types: !6)
+!6 = !{!7, !7}
+!7 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!8 = !{!9}
+!9 = !DILocalVariable(name: "x", arg: 1, scope: !4, file: !1, line: 2, type: !7)
+!10 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 1, type: !5, isLocal: true, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !11)
+!11 = !{!12}
+!12 = !DILocalVariable(name: "x", arg: 1, scope: !10, file: !1, line: 1, type: !7)
+!13 = !{i32 2, !"Dwarf Version", i32 2}
+!14 = !{i32 2, !"Debug Info Version", i32 3}
+!15 = !{i32 1, !"PIC Level", i32 2}
+!16 = !{!"clang version 3.7.0 (trunk 233919) (llvm/trunk 233920)"}
+!17 = !DIExpression()
+!18 = !DILocation(line: 2, column: 13, scope: !4)
+!19 = !DILocalVariable(name: "x", arg: 1, scope: !10, file: !1, line: 1, type: !7)
+!20 = distinct !DILocation(line: 2, column: 25, scope: !4)
+!21 = !DILocation(line: 1, column: 20, scope: !10, inlinedAt: !20)
+!22 = !DILocation(line: 2, column: 18, scope: !4)
diff --git a/test/DebugInfo/X86/missing-file-line.ll b/test/DebugInfo/X86/missing-file-line.ll
new file mode 100644
index 0000000..40919b6
--- /dev/null
+++ b/test/DebugInfo/X86/missing-file-line.ll
@@ -0,0 +1,60 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-linux-gnu -filetype=obj %t.ll -o - | llvm-dwarfdump -all - | FileCheck %s
+
+; Test that we accept and generate DWARF entities for DW_TAG_structure_type,
+; DW_TAG_member and DW_TAG_typedef with no source location. These can come up
+; in some languages with predefined types.
+
+target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+%struct.S = type { %struct.S* }
+
+define void @f() !dbg !4 {
+  %x = alloca %struct.S, align 8
+  ; CHECK: DW_TAG_typedef
+  ; CHECK-NOT: DW_AT_decl_file
+  ; CHECK-NOT: DW_AT_decl_line
+
+  ; CHECK: DW_TAG_structure_type
+  ; CHECK-NOT: DW_AT_decl_file
+  ; CHECK-NOT: DW_AT_decl_line
+
+  ; CHECK: DW_TAG_member
+  ; CHECK-NOT: DW_AT_decl_file
+  ; CHECK-NOT: DW_AT_decl_line
+
+  ; CHECK: {{DW_TAG|NULL}}
+  call void @llvm.dbg.declare(metadata %struct.S* %x, metadata !10, metadata !16), !dbg !17
+  ret void, !dbg !18
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!7, !8}
+!llvm.ident = !{!9}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "file.c", directory: "/dir")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "f", scope: !1, file: !1, line: 7, type: !5, isLocal: false, isDefinition: true, scopeLine: 7, isOptimized: false, unit: !0, retainedNodes: !2)
+!5 = !DISubroutineType(types: !6)
+!6 = !{null}
+!7 = !{i32 2, !"Dwarf Version", i32 4}
+!8 = !{i32 2, !"Debug Info Version", i32 3}
+!9 = !{!"clang"}
+!10 = !DILocalVariable(name: "x", scope: !4, file: !1, line: 8, type: !11)
+!11 = !DIDerivedType(tag: DW_TAG_typedef, name: "SS", baseType: !12)
+!12 = !DICompositeType(tag: DW_TAG_structure_type, name: "S", size: 64, align: 64, elements: !13)
+!13 = !{!14}
+!14 = !DIDerivedType(tag: DW_TAG_member, name: "s", scope: !12, baseType: !15, size: 64, align: 64)
+!15 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !12, size: 64, align: 64)
+!16 = !DIExpression()
+!17 = !DILocation(line: 8, column: 6, scope: !4)
+!18 = !DILocation(line: 9, column: 1, scope: !4)
diff --git a/test/DebugInfo/X86/mixed-nodebug-cu.ll b/test/DebugInfo/X86/mixed-nodebug-cu.ll
new file mode 100644
index 0000000..7548195
--- /dev/null
+++ b/test/DebugInfo/X86/mixed-nodebug-cu.ll
@@ -0,0 +1,52 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -debug-info %t | FileCheck %s
+; CHECK: DW_TAG_compile_unit
+; CHECK:   DW_TAG_subprogram
+; CHECK:     DW_AT_name{{.*}}"f"
+; CHECK-NOT: DW_TAG_compile_unit
+;
+; created from
+;   void f() {} // compile with -g
+;   void g() {} // compile with -Rpass=inline
+; and llvm-linking the result.
+
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind ssp uwtable
+define void @f() #0 !dbg !4 {
+entry:
+  ret void, !dbg !15
+}
+
+; Function Attrs: nounwind ssp uwtable
+define void @g() #0 !dbg !9 {
+entry:
+  ret void, !dbg !16
+}
+
+attributes #0 = { nounwind ssp uwtable }
+
+!llvm.dbg.cu = !{!0, !7}
+!llvm.ident = !{!11, !11}
+!llvm.module.flags = !{!12, !13, !14}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 3.9.0 (trunk 265328) (llvm/trunk 265330)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "test.c", directory: "/Volumes/Data/llvm")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "f", scope: !1, file: !1, line: 1, type: !5, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: false, unit: !0, retainedNodes: !2)
+!5 = !DISubroutineType(types: !6)
+!6 = !{null}
+!7 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 3.9.0 (trunk 265328) (llvm/trunk 265330)", isOptimized: false, runtimeVersion: 0, emissionKind: NoDebug, enums: !2)
+!9 = distinct !DISubprogram(name: "g", scope: !1, file: !1, line: 1, type: !10, isLocal: false, isDefinition: true, scopeLine: 1, isOptimized: false, unit: !7, retainedNodes: !2)
+!10 = !DISubroutineType(types: !2)
+!11 = !{!"clang version 3.9.0 (trunk 265328) (llvm/trunk 265330)"}
+!12 = !{i32 2, !"Dwarf Version", i32 2}
+!13 = !{i32 2, !"Debug Info Version", i32 3}
+!14 = !{i32 1, !"PIC Level", i32 2}
+!15 = !DILocation(line: 1, column: 12, scope: !4)
+!16 = !DILocation(line: 1, column: 12, scope: !9)
diff --git a/test/DebugInfo/X86/partial-constant.ll b/test/DebugInfo/X86/partial-constant.ll
new file mode 100644
index 0000000..e763858
--- /dev/null
+++ b/test/DebugInfo/X86/partial-constant.ll
@@ -0,0 +1,87 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj < %t.ll | llvm-dwarfdump -v - | FileCheck %s
+; Generated at -O2 from:
+; bool c();
+; void f();
+; bool start() {
+;   bool result = c();
+;   if (!c()) {
+;     result = false;
+;     goto exit;
+;   }
+;   f();
+;   result = true;
+; exit:
+;   return result;
+; }
+;
+; The constant should NOT be available for the entire function.
+; CHECK-NOT: DW_AT_const_value
+; CHECK: .debug_loc contents:
+; CHECK-NEXT: 0x00000000:
+; CHECK-NEXT:   {{.*}}: DW_OP_constu 0x1, DW_OP_stack_value
+
+source_filename = "test.ii"
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: noimplicitfloat noredzone nounwind optsize
+define zeroext i1 @_Z5startv() local_unnamed_addr #0 !dbg !7 {
+entry:
+  %call = tail call zeroext i1 @_Z1cv() #3, !dbg !13
+  %call1 = tail call zeroext i1 @_Z1cv() #3, !dbg !14
+  br i1 %call1, label %if.end, label %exit, !dbg !16
+
+if.end:                                           ; preds = %entry
+  tail call void @_Z1fv() #3, !dbg !17
+  tail call void @llvm.dbg.value(metadata i8 1, metadata !12, metadata !18), !dbg !19
+  br label %exit, !dbg !20
+
+exit:                                             ; preds = %entry, %if.end
+  %result.0 = phi i1 [ true, %if.end ], [ false, %entry ]
+  ret i1 %result.0, !dbg !21
+}
+
+; Function Attrs: noimplicitfloat noredzone optsize
+declare zeroext i1 @_Z1cv() local_unnamed_addr #1
+
+; Function Attrs: noimplicitfloat noredzone optsize
+declare void @_Z1fv() local_unnamed_addr #1
+
+; Function Attrs: nounwind readnone speculatable
+declare void @llvm.dbg.value(metadata, metadata, metadata) #2
+
+attributes #0 = { noimplicitfloat noredzone nounwind optsize }
+attributes #1 = { noimplicitfloat noredzone optsize }
+attributes #2 = { nounwind readnone speculatable }
+attributes #3 = { nobuiltin noimplicitfloat noredzone nounwind optsize }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4, !5}
+!llvm.ident = !{!6}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 5.0.0 (trunk 303873) (llvm/trunk 303897)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "test.ii", directory: "/")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{i32 1, !"wchar_size", i32 4}
+!6 = !{!"clang version 5.0.0 (trunk 303873) (llvm/trunk 303897)"}
+!7 = distinct !DISubprogram(name: "start", linkageName: "_Z5startv", scope: !1, file: !1, line: 3, type: !8, isLocal: false, isDefinition: true, scopeLine: 3, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !11)
+!8 = !DISubroutineType(types: !9)
+!9 = !{!10}
+!10 = !DIBasicType(name: "bool", size: 8, encoding: DW_ATE_boolean)
+!11 = !{!12}
+!12 = !DILocalVariable(name: "result", scope: !7, file: !1, line: 4, type: !10)
+!13 = !DILocation(line: 4, column: 17, scope: !7)
+!14 = !DILocation(line: 5, column: 8, scope: !15)
+!15 = distinct !DILexicalBlock(scope: !7, file: !1, line: 5, column: 7)
+!16 = !DILocation(line: 5, column: 7, scope: !7)
+!17 = !DILocation(line: 9, column: 3, scope: !7)
+!18 = !DIExpression()
+!19 = !DILocation(line: 4, column: 8, scope: !7)
+!20 = !DILocation(line: 10, column: 3, scope: !7)
+!21 = !DILocation(line: 12, column: 3, scope: !7)
diff --git a/test/DebugInfo/X86/pr13303.ll b/test/DebugInfo/X86/pr13303.ll
new file mode 100644
index 0000000..b9aec63
--- /dev/null
+++ b/test/DebugInfo/X86/pr13303.ll
@@ -0,0 +1,34 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc %t.ll -o %t -filetype=obj -mtriple=x86_64-unknown-linux-gnu
+; RUN: llvm-dwarfdump -debug-line %t | FileCheck %s
+; PR13303
+
+; Check that the prologue ends with is_stmt here.
+; CHECK: 0x0000000000000000 {{.*}} is_stmt
+
+define i32 @main() nounwind uwtable !dbg !5 {
+entry:
+  %retval = alloca i32, align 4
+  store i32 0, i32* %retval
+  ret i32 0, !dbg !10
+}
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!13}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.2 (trunk 160143)", isOptimized: false, emissionKind: FullDebug, file: !12, enums: !1, retainedTypes: !1, globals: !1, imports:  !1)
+!1 = !{}
+!5 = distinct !DISubprogram(name: "main", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, isOptimized: false, unit: !0, scopeLine: 1, file: !12, scope: !6, type: !7, retainedNodes: !1)
+!6 = !DIFile(filename: "PR13303.c", directory: "/home/probinson")
+!7 = !DISubroutineType(types: !8)
+!8 = !{!9}
+!9 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!10 = !DILocation(line: 1, column: 14, scope: !11)
+!11 = distinct !DILexicalBlock(line: 1, column: 12, file: !12, scope: !5)
+!12 = !DIFile(filename: "PR13303.c", directory: "/home/probinson")
+!13 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/processes-relocations.ll b/test/DebugInfo/X86/processes-relocations.ll
new file mode 100644
index 0000000..a9d057d
--- /dev/null
+++ b/test/DebugInfo/X86/processes-relocations.ll
@@ -0,0 +1,27 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -filetype=obj -O0 < %t.ll -mtriple x86_64-none-linux | \
+; RUN:     llvm-dwarfdump - 2>&1 | FileCheck %s
+; RUN: llc -filetype=obj -O0 < %t.ll -mtriple i386-none-linux | \
+; RUN:     llvm-dwarfdump - 2>&1 | FileCheck %s
+; RUN: llc -filetype=obj -O0 < %t.ll -mtriple x86_64-none-mingw32 | \
+; RUN:     llvm-dwarfdump - 2>&1 | FileCheck %s
+; RUN: llc -filetype=obj -O0 < %t.ll -mtriple i386-none-mingw32 | \
+; RUN:     llvm-dwarfdump - 2>&1 | FileCheck %s
+
+; CHECK-NOT: failed to compute relocation
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+!llvm.ident = !{!5}
+
+!0 = distinct !DICompileUnit(file: !1, language: DW_LANG_C99, producer: "clang version 3.6.0 ", isOptimized: false, enums: !2, retainedTypes: !2, globals: !2, imports: !2, emissionKind: FullDebug)
+!1 = !DIFile(filename: "empty.c", directory: "/a")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{!"clang version 3.6.0 "}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/reference-argument.ll b/test/DebugInfo/X86/reference-argument.ll
new file mode 100644
index 0000000..ecb9854
--- /dev/null
+++ b/test/DebugInfo/X86/reference-argument.ll
@@ -0,0 +1,111 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-macosx10.9.0 -filetype=obj -O0 < %t.ll \
+; RUN:   | llvm-dwarfdump -v -debug-info - | FileCheck %s
+; ModuleID = 'aggregate-indirect-arg.cpp'
+; extracted from debuginfo-tests/aggregate-indirect-arg.cpp
+
+; v should be a pointer.
+; CHECK:  .debug_info contents:
+; CHECK:   DW_TAG_subprogram
+; CHECK:     DW_AT_specification {{.*}} "_ZN1A3fooE4SVal"
+; CHECK-NOT: DW_TAG_subprogram
+; CHECK:     DW_TAG_formal_parameter
+; CHECK:       DW_AT_name {{.*}} "this"
+; CHECK-NOT:   DW_TAG_subprogram
+; CHECK:     DW_TAG_formal_parameter
+; CHECK-NEXT:  DW_AT_location {{.*}}(DW_OP_breg4 RSI+0)
+; CHECK-NEXT:  DW_AT_name {{.*}} "v"
+
+target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+%class.SVal = type { i8*, i32 }
+%class.A = type { i8 }
+
+declare void @_Z3barR4SVal(%class.SVal* %v)
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+declare i32 @main()
+; Function Attrs: nounwind ssp uwtable
+define linkonce_odr void @_ZN1A3fooE4SVal(%class.A* %this, %class.SVal* %v) nounwind ssp uwtable align 2 !dbg !35 {
+entry:
+  %this.addr = alloca %class.A*, align 8
+  store %class.A* %this, %class.A** %this.addr, align 8
+  call void @llvm.dbg.declare(metadata %class.A** %this.addr, metadata !59, metadata !DIExpression()), !dbg !61
+  call void @llvm.dbg.value(metadata %class.SVal* %v, metadata !62, metadata !DIExpression(DW_OP_deref)), !dbg !61
+  %this1 = load %class.A*, %class.A** %this.addr
+  call void @_Z3barR4SVal(%class.SVal* %v), !dbg !61
+  ret void, !dbg !61
+}
+declare void @_ZN4SValD1Ev(%class.SVal* %this)
+declare void @_ZN4SValD2Ev(%class.SVal* %this)
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!47, !68}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang version 3.4 ", isOptimized: false, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "aggregate-indirect-arg.cpp", directory: "")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "bar", linkageName: "_Z3barR4SVal", line: 19, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 19, file: !1, scope: !5, type: !6, retainedNodes: !2)
+!5 = !DIFile(filename: "aggregate-indirect-arg.cpp", directory: "")
+!6 = !DISubroutineType(types: !7)
+!7 = !{null, !8}
+!8 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !9)
+!9 = !DICompositeType(tag: DW_TAG_class_type, name: "SVal", line: 12, size: 128, align: 64, file: !1, elements: !10)
+!10 = !{!11, !14, !16, !21, !23}
+!11 = !DIDerivedType(tag: DW_TAG_member, name: "Data", line: 15, size: 64, align: 64, file: !1, scope: !9, baseType: !12)
+!12 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !13)
+!13 = !DIDerivedType(tag: DW_TAG_const_type, baseType: null)
+!14 = !DIDerivedType(tag: DW_TAG_member, name: "Kind", line: 16, size: 32, align: 32, offset: 64, file: !1, scope: !9, baseType: !15)
+!15 = !DIBasicType(tag: DW_TAG_base_type, name: "unsigned int", size: 32, align: 32, encoding: DW_ATE_unsigned)
+!16 = !DISubprogram(name: "~SVal", line: 14, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, scopeLine: 14, file: !1, scope: !9, type: !17)
+!17 = !DISubroutineType(types: !18)
+!18 = !{null, !19}
+!19 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer, baseType: !9)
+!21 = !DISubprogram(name: "SVal", line: 12, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false, scopeLine: 12, file: !1, scope: !9, type: !17)
+!23 = !DISubprogram(name: "SVal", line: 12, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false, scopeLine: 12, file: !1, scope: !9, type: !24)
+!24 = !DISubroutineType(types: !25)
+!25 = !{null, !19, !26}
+!26 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !27)
+!27 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !9)
+!29 = distinct !DISubprogram(name: "main", line: 25, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 25, file: !1, scope: !5, type: !30, retainedNodes: !2)
+!30 = !DISubroutineType(types: !31)
+!31 = !{!32}
+!32 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!33 = distinct !DISubprogram(name: "~SVal", linkageName: "_ZN4SValD1Ev", line: 14, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 14, file: !1, scope: null, type: !17, declaration: !16, retainedNodes: !2)
+!34 = distinct !DISubprogram(name: "~SVal", linkageName: "_ZN4SValD2Ev", line: 14, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 14, file: !1, scope: null, type: !17, declaration: !16, retainedNodes: !2)
+!35 = distinct !DISubprogram(name: "foo", linkageName: "_ZN1A3fooE4SVal", line: 22, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 22, file: !1, scope: null, type: !36, declaration: !41, retainedNodes: !2)
+!36 = !DISubroutineType(types: !37)
+!37 = !{null, !38, !9}
+!38 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer, baseType: !39)
+!39 = !DICompositeType(tag: DW_TAG_class_type, name: "A", line: 20, size: 8, align: 8, file: !1, elements: !40)
+!40 = !{!41, !43}
+!41 = !DISubprogram(name: "foo", linkageName: "_ZN1A3fooE4SVal", line: 22, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, scopeLine: 22, file: !1, scope: !39, type: !36)
+!43 = !DISubprogram(name: "A", line: 20, isLocal: false, isDefinition: false, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false, scopeLine: 20, file: !1, scope: !39, type: !44)
+!44 = !DISubroutineType(types: !45)
+!45 = !{null, !38}
+!47 = !{i32 2, !"Dwarf Version", i32 3}
+!48 = !DILocalVariable(name: "v", line: 19, arg: 1, scope: !4, file: !5, type: !8)
+!49 = !DILocation(line: 19, scope: !4)
+!50 = !DILocalVariable(name: "v", line: 26, scope: !29, file: !5, type: !9)
+!51 = !DILocation(line: 26, scope: !29)
+!52 = !DILocation(line: 27, scope: !29)
+!53 = !DILocation(line: 28, scope: !29)
+!54 = !DILocalVariable(name: "a", line: 29, scope: !29, file: !5, type: !39)
+!55 = !DILocation(line: 29, scope: !29)
+!56 = !DILocation(line: 30, scope: !29)
+!57 = !DILocation(line: 31, scope: !29)
+!58 = !DILocation(line: 32, scope: !29)
+!59 = !DILocalVariable(name: "this", line: 22, arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !35, file: !5, type: !60)
+!60 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !39)
+!61 = !DILocation(line: 22, scope: !35)
+!62 = !DILocalVariable(name: "v", line: 22, arg: 2, scope: !35, file: !5, type: !9)
+!63 = !DILocalVariable(name: "this", line: 14, arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !33, file: !5, type: !64)
+!64 = !DIDerivedType(tag: DW_TAG_pointer_type, size: 64, align: 64, baseType: !9)
+!65 = !DILocation(line: 14, scope: !33)
+!66 = !DILocalVariable(name: "this", line: 14, arg: 1, flags: DIFlagArtificial | DIFlagObjectPointer, scope: !34, file: !5, type: !64)
+!67 = !DILocation(line: 14, scope: !34)
+!68 = !{i32 1, !"Debug Info Version", i32 3}
diff --git a/test/DebugInfo/X86/rematerialize.ll b/test/DebugInfo/X86/rematerialize.ll
new file mode 100644
index 0000000..3d74e8f
--- /dev/null
+++ b/test/DebugInfo/X86/rematerialize.ll
@@ -0,0 +1,100 @@
+; REQUIRES: object-emission
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -O2 -filetype=obj -mtriple=x86_64-unknown-linux-gnu < %t.ll \
+; RUN: | llvm-dwarfdump -debug-line - | FileCheck %s
+;
+; Generated with clang -O2 -g from
+;
+; typedef float __m128 __attribute__((__vector_size__(16)));
+; 
+; extern __m128 doSomething(__m128, __m128);
+; 
+; 
+; __m128 foo(__m128 X) {     // line 6
+;   const __m128 V = {0.5f, 0.5f, 0.5f, 0.5f};  // line 7
+;   __m128 Sub = X - V;  // line 8
+;   __m128 Add = X + V;  // line 9
+; 
+;   __m128 Result = doSomething(Add, Sub);  // line 11
+; 
+;   return V - Result;  // line 13
+; }
+;
+;
+; We want to see line 13 after line 11 without any other line in between.
+; CHECK:       0x{{[0-9a-f]*}} 11
+; CHECK-NOT:   0x{{[0-9a-f]*}}  8
+; CHECK-NOT:   0x{{[0-9a-f]*}}  9
+; CHECK:       0x{{[0-9a-f]*}} 13
+; CHECK-NOT:   0x{{[0-9a-f]*}}  8
+; CHECK-NOT:   0x{{[0-9a-f]*}}  9
+
+; ModuleID = 'test.c'
+source_filename = "test.c"
+; target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind uwtable
+define <4 x float> @foo(<4 x float> %X) local_unnamed_addr #0 !dbg !6 {
+entry:
+  tail call void @llvm.dbg.value(metadata <4 x float> %X, metadata !15, metadata !21), !dbg !22
+  tail call void @llvm.dbg.value(metadata <4 x float> <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>, metadata !16, metadata !21), !dbg !23
+  %sub = fadd <4 x float> %X, <float -5.000000e-01, float -5.000000e-01, float -5.000000e-01, float -5.000000e-01>, !dbg !24
+  tail call void @llvm.dbg.value(metadata <4 x float> %sub, metadata !18, metadata !21), !dbg !25
+  %add = fadd <4 x float> %X, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>, !dbg !26
+  tail call void @llvm.dbg.value(metadata <4 x float> %add, metadata !19, metadata !21), !dbg !27
+  %call = tail call <4 x float> @doSomething(<4 x float> %add, <4 x float> %sub) #3, !dbg !28
+  tail call void @llvm.dbg.value(metadata <4 x float> %call, metadata !20, metadata !21), !dbg !29
+  %sub1 = fsub <4 x float> <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>, %call, !dbg !30
+  ret <4 x float> %sub1, !dbg !31
+}
+
+declare <4 x float> @doSomething(<4 x float>, <4 x float>) local_unnamed_addr #1
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #2
+
+attributes #0 = { nounwind uwtable }
+attributes #1 = { nounwind uwtable }
+attributes #2 = { nounwind readnone }
+attributes #3 = { nounwind }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+!llvm.ident = !{!5}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 4.0.0 (trunk 278291)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "test.c", directory: "/home/test")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{!"clang version 4.0.0 (trunk 278291)"}
+!6 = distinct !DISubprogram(name: "foo", scope: !1, file: !1, line: 6, type: !7, isLocal: false, isDefinition: true, scopeLine: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !14)
+!7 = !DISubroutineType(types: !8)
+!8 = !{!9, !9}
+!9 = !DIDerivedType(tag: DW_TAG_typedef, name: "__m128", file: !1, line: 1, baseType: !10)
+!10 = !DICompositeType(tag: DW_TAG_array_type, baseType: !11, size: 128, align: 128, flags: DIFlagVector, elements: !12)
+!11 = !DIBasicType(name: "float", size: 32, align: 32, encoding: DW_ATE_float)
+!12 = !{!13}
+!13 = !DISubrange(count: 4)
+!14 = !{!15, !16, !18, !19, !20}
+!15 = !DILocalVariable(name: "X", arg: 1, scope: !6, file: !1, line: 6, type: !9)
+!16 = !DILocalVariable(name: "V", scope: !6, file: !1, line: 7, type: !17)
+!17 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !9)
+!18 = !DILocalVariable(name: "Sub", scope: !6, file: !1, line: 8, type: !9)
+!19 = !DILocalVariable(name: "Add", scope: !6, file: !1, line: 9, type: !9)
+!20 = !DILocalVariable(name: "Result", scope: !6, file: !1, line: 11, type: !9)
+!21 = !DIExpression()
+!22 = !DILocation(line: 6, column: 19, scope: !6)
+!23 = !DILocation(line: 7, column: 16, scope: !6)
+!24 = !DILocation(line: 8, column: 18, scope: !6)
+!25 = !DILocation(line: 8, column: 10, scope: !6)
+!26 = !DILocation(line: 9, column: 18, scope: !6)
+!27 = !DILocation(line: 9, column: 10, scope: !6)
+!28 = !DILocation(line: 11, column: 19, scope: !6)
+!29 = !DILocation(line: 11, column: 10, scope: !6)
+!30 = !DILocation(line: 13, column: 12, scope: !6)
+!31 = !DILocation(line: 13, column: 3, scope: !6)
diff --git a/test/DebugInfo/X86/single-dbg_value.ll b/test/DebugInfo/X86/single-dbg_value.ll
new file mode 100644
index 0000000..6a099c6
--- /dev/null
+++ b/test/DebugInfo/X86/single-dbg_value.ll
@@ -0,0 +1,75 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -stop-after=livedebugvalues -o - %t.ll \
+; RUN:   | FileCheck %s --check-prefix=SANITY
+; RUN: llc -mtriple=%triple -march=x86-64 -o - %t.ll -filetype=obj \
+; RUN:   | llvm-dwarfdump -v -all - | FileCheck %s
+;
+; CHECK: .debug_info contents:
+; CHECK: DW_TAG_variable
+; CHECK-NEXT:   DW_AT_location [DW_FORM_data4] (
+; CHECK-NEXT:     {{.*}}: DW_OP_reg0 RAX)
+; CHECK-NEXT:   DW_AT_name{{.*}}"a"
+
+; SANITY: DBG_VALUE
+; SANITY-NOT: DBG_VALUE
+
+; Compiled with -O:
+;   void h(int);
+;   int g();
+;   void f() {
+;     h(0);
+;     int a = g();
+;     h(a);
+;   }
+
+; ModuleID = 'test.ll'
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: nounwind ssp uwtable
+define void @f() #0 !dbg !4 {
+entry:
+  tail call void @h(i32 0) #2, !dbg !14
+  %call = tail call i32 (...) @g() #2, !dbg !15
+  tail call void @llvm.dbg.value(metadata i32 %call, metadata !8, metadata !16), !dbg !17
+  tail call void @h(i32 %call) #2, !dbg !18
+  ret void, !dbg !19
+}
+
+declare void @h(i32)
+
+declare i32 @g(...)
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind ssp uwtable "no-frame-pointer-elim"="true" }
+attributes #1 = { nounwind readnone }
+attributes #2 = { nounwind }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!10, !11, !12}
+!llvm.ident = !{!13}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 3.9.0 ", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "test.c", directory: "/Volumes/Data/llvm")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "f", scope: !1, file: !1, line: 3, type: !5, isLocal: false, isDefinition: true, scopeLine: 3, isOptimized: true, unit: !0, retainedNodes: !7)
+!5 = !DISubroutineType(types: !6)
+!6 = !{null}
+!7 = !{!8}
+!8 = !DILocalVariable(name: "a", scope: !4, file: !1, line: 5, type: !9)
+!9 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!10 = !{i32 2, !"Dwarf Version", i32 2}
+!11 = !{i32 2, !"Debug Info Version", i32 3}
+!12 = !{i32 1, !"PIC Level", i32 2}
+!13 = !{!"clang version 3.9.0 "}
+!14 = !DILocation(line: 4, column: 3, scope: !4)
+!15 = !DILocation(line: 5, column: 11, scope: !4)
+!16 = !DIExpression()
+!17 = !DILocation(line: 5, column: 7, scope: !4)
+!18 = !DILocation(line: 6, column: 3, scope: !4)
+!19 = !DILocation(line: 7, column: 1, scope: !4)
diff --git a/test/DebugInfo/X86/single-fi.ll b/test/DebugInfo/X86/single-fi.ll
new file mode 100644
index 0000000..be221a4
--- /dev/null
+++ b/test/DebugInfo/X86/single-fi.ll
@@ -0,0 +1,46 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-apple-darwin -o - %t.ll -filetype=obj \
+; RUN:   | llvm-dwarfdump -v -debug-info - | FileCheck %s
+; A single FI location. This used to trigger an assertion in debug libstdc++.
+; CHECK: DW_TAG_formal_parameter
+;                                          fbreg -8
+; CHECK-NEXT: DW_AT_location {{.*}} (DW_OP_fbreg -8)
+; CHECK-NEXT: DW_AT_name {{.*}} "dipsy"
+define void @tinkywinky(i8* %dipsy) !dbg !6 {
+entry:
+  %dipsy.addr = alloca i8*
+  store i8* %dipsy, i8** %dipsy.addr
+  call void @llvm.dbg.declare(metadata i8** %dipsy.addr, metadata !12, metadata
+!13), !dbg !14
+  ret void, !dbg !15
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata)
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+!llvm.ident = !{!5}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 5.0.0 (trunk 297917) (llvm/trunk 297929)", isOptimized: false,
+runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "teletubbies.c", directory: "/home/davide/work/llvm/build-clang/bin")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{!"clang version 5.0.0 (trunk 297917) (llvm/trunk 297929)"}
+!6 = distinct !DISubprogram(name: "tinkywinky", scope: !1, file: !1, line: 1, type: !7, isLocal: false, isDefinition: true, scopeLine: 1, flags:
+DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!7 = !DISubroutineType(types: !8)
+!8 = !{null, !9}
+!9 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !10, size: 64)
+!10 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !11)
+!11 = !DIBasicType(name: "char", size: 8, encoding: DW_ATE_signed_char)
+!12 = !DILocalVariable(name: "dipsy", arg: 1, scope: !6, file: !1, line: 1, type: !9)
+!13 = !DIExpression()
+!14 = !DILocation(line: 1, column: 29, scope: !6)
+!15 = !DILocation(line: 1, column: 37, scope: !6)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/split-dwarf-multiple-cu-hash.ll b/test/DebugInfo/X86/split-dwarf-multiple-cu-hash.ll
new file mode 100644
index 0000000..e8530e4
--- /dev/null
+++ b/test/DebugInfo/X86/split-dwarf-multiple-cu-hash.ll
@@ -0,0 +1,50 @@
+; RUN: rm -rf %t && mkdir -p %t
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -split-dwarf-file=foo.dwo  %t.ll -filetype=obj -o %t/a.o
+; RUN: llc -mtriple=%triple -split-dwarf-file=bar.dwo  %t.ll -filetype=obj -o %t/b.o
+; RUN: llvm-dwarfdump -debug-info %t/a.o %t/b.o | FileCheck %s
+
+; CHECK: .debug_info contents:
+; CHECK: dwo_id {{.*}}([[HASH:.*]])
+; CHECK-NOT: dwo_id {{.*}}([[HASH]])
+; CHECK: .debug_info.dwo contents:
+
+target triple = "spir64-unknown-unknown"
+
+; Function Attrs: noinline nounwind uwtable
+define void @_Z1av() #0 !dbg !9 {
+entry:
+  ret void, !dbg !12
+}
+
+; Function Attrs: noinline nounwind uwtable
+define void @_Z1bv() #0 !dbg !13 {
+entry:
+  ret void, !dbg !14
+}
+
+attributes #0 = { noinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0, !3}
+!llvm.ident = !{!5, !5}
+!llvm.module.flags = !{!6, !7, !8}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 5.0.0 (trunk 304107) (llvm/trunk 304109)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "a.cpp", directory: "/usr/local/google/home/blaikie/dev/scratch")
+!2 = !{}
+!3 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !4, producer: "clang version 5.0.0 (trunk 304107) (llvm/trunk 304109)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!4 = !DIFile(filename: "b.cpp", directory: "/usr/local/google/home/blaikie/dev/scratch")
+!5 = !{!"clang version 5.0.0 (trunk 304107) (llvm/trunk 304109)"}
+!6 = !{i32 2, !"Dwarf Version", i32 4}
+!7 = !{i32 2, !"Debug Info Version", i32 3}
+!8 = !{i32 1, !"wchar_size", i32 4}
+!9 = distinct !DISubprogram(name: "a", linkageName: "_Z1av", scope: !1, file: !1, line: 1, type: !10, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!10 = !DISubroutineType(types: !11)
+!11 = !{null}
+!12 = !DILocation(line: 2, column: 1, scope: !9)
+!13 = distinct !DISubprogram(name: "b", linkageName: "_Z1bv", scope: !4, file: !4, line: 1, type: !10, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: false, unit: !3, retainedNodes: !2)
+!14 = !DILocation(line: 2, column: 1, scope: !13)
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/split-dwarf-omit-empty.ll b/test/DebugInfo/X86/split-dwarf-omit-empty.ll
new file mode 100644
index 0000000..5569d93
--- /dev/null
+++ b/test/DebugInfo/X86/split-dwarf-omit-empty.ll
@@ -0,0 +1,61 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -split-dwarf-file=foo.dwo  %t.ll -filetype=obj -o - | llvm-dwarfdump -debug-info - | FileCheck %s
+
+; Created from:
+; a.cpp:
+;   void f1();
+;   inline __attribute__((always_inline)) __attribute__((used)) void f2() { f1(); }
+; b.cpp:
+;   void f2();
+;   void f3() {
+;     f2();
+;   }
+; $ clang++ -fno-split-dwarf-inlining {a,b}.cpp -emit-llvm -S -g
+; $ llvm-link {a,b}.ll -S -o ab.ll
+; Then strip out the @llvm.used global, so no out of line definition of 'f2'
+; will be emitted. This emulates something more like the available_externally
+; import performed by ThinLTO.
+
+; CHECK: .debug_info contents:
+; CHECK: Compile Unit
+; CHECK-NOT: Compile Unit
+; CHECK: .debug_info.dwo contents:
+
+target triple = "spir64-unknown-unknown"
+
+declare void @_Z2f1v()
+
+; Function Attrs: noinline norecurse uwtable
+define i32 @main() !dbg !9 {
+entry:
+  call void @_Z2f1v(), !dbg !13
+  ret i32 0, !dbg !18
+}
+
+!llvm.dbg.cu = !{!0, !3}
+!llvm.ident = !{!5, !5}
+!llvm.module.flags = !{!6, !7, !8}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 5.0.0 (trunk 304054) (llvm/trunk 304080)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, splitDebugInlining: false)
+!1 = !DIFile(filename: "a.cpp", directory: "/usr/local/google/home/blaikie/dev/scratch")
+!2 = !{}
+!3 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !4, producer: "clang version 5.0.0 (trunk 304054) (llvm/trunk 304080)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, splitDebugInlining: false)
+!4 = !DIFile(filename: "b.cpp", directory: "/usr/local/google/home/blaikie/dev/scratch")
+!5 = !{!"clang version 5.0.0 (trunk 304054) (llvm/trunk 304080)"}
+!6 = !{i32 2, !"Dwarf Version", i32 4}
+!7 = !{i32 2, !"Debug Info Version", i32 3}
+!8 = !{i32 1, !"wchar_size", i32 4}
+!9 = distinct !DISubprogram(name: "main", scope: !4, file: !4, line: 2, type: !10, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: false, unit: !3, retainedNodes: !2)
+!10 = !DISubroutineType(types: !11)
+!11 = !{!12}
+!12 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!13 = !DILocation(line: 2, column: 73, scope: !14, inlinedAt: !17)
+!14 = distinct !DISubprogram(name: "f2", linkageName: "_Z2f2v", scope: !1, file: !1, line: 2, type: !15, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!15 = !DISubroutineType(types: !16)
+!16 = !{null}
+!17 = distinct !DILocation(line: 3, column: 3, scope: !9)
+!18 = !DILocation(line: 4, column: 1, scope: !9)
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/static_member_array.ll b/test/DebugInfo/X86/static_member_array.ll
new file mode 100644
index 0000000..ec15066
--- /dev/null
+++ b/test/DebugInfo/X86/static_member_array.ll
@@ -0,0 +1,78 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple %t.ll -filetype=obj -o - | llvm-dwarfdump -v -debug-info - | FileCheck %s
+; Generated from:
+;
+; struct A {
+;   static int fully_specified;
+;   static int smem[];
+; };
+;  
+; int A::fully_specified;
+; int A::smem[] = { 0, 1, 2, 3 };
+;
+; CHECK: DW_TAG_variable
+; CHECK-NEXT: DW_AT_specification{{.*}}"fully_specified"
+; CHECK-NOT:  DW_AT_type
+; CHECK: DW_TAG_structure_type
+; CHECK: DW_TAG_member
+; CHECK: DW_TAG_member
+; CHECK-NEXT:   DW_AT_name {{.*}} "smem"
+; CHECK-NEXT:   DW_AT_type {{.*}} {0x[[GENERIC:[0-9]+]]}
+;
+; CHECK: 0x[[GENERIC]]: DW_TAG_array_type
+; CHECK-NOT:  DW_TAG
+; CHECK-NOT:  NULL
+; CHECK: DW_TAG_subrange_type
+; CHECK-NOT:  DW_AT_count
+; CHECK:  NULL
+;
+; CHECK: DW_TAG_variable
+; CHECK-NEXT: DW_AT_specification {{.*}}"smem"
+; CHECK-NEXT: DW_AT_type {{.*}} {0x[[SPECIFIC:[0-9]+]]}
+;
+; CHECK: 0x[[SPECIFIC]]: DW_TAG_array_type
+; CHECK-NOT:  DW_TAG
+; CHECK-NOT:  NULL
+; CHECK: DW_TAG_subrange_type
+; CHECK-NOT:  DW_TAG
+; CHECK-NOT:  NULL
+; CHECK:  DW_AT_count {{.*}} (0x04)
+
+source_filename = "static_member_array.cpp"
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+@_ZN1A15fully_specifiedE = global i32 0, align 4, !dbg !0
+@_ZN1A4smemE = global [4 x i32] [i32 0, i32 1, i32 2, i32 3], align 16, !dbg !6
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!19, !20, !21}
+!llvm.ident = !{!22}
+
+!0 = distinct !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "fully_specified", linkageName: "_ZN1A15fully_specifiedE", scope: !2, file: !3, line: 7, type: !9, isLocal: false, isDefinition: true, declaration: !15)
+!2 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !3, producer: "clang version 4.0.0 (trunk 286129) (llvm/trunk 286128)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, globals: !5)
+!3 = !DIFile(filename: "static_member_array.cpp", directory: "/Volumes/Data/radar/28706946")
+!4 = !{}
+!5 = !{!0, !6}
+!6 = distinct !DIGlobalVariableExpression(var: !7, expr: !DIExpression())
+!7 = !DIGlobalVariable(name: "smem", linkageName: "_ZN1A4smemE", scope: !2, file: !3, line: 8, type: !8, isLocal: false, isDefinition: true, declaration: !12)
+!8 = !DICompositeType(tag: DW_TAG_array_type, baseType: !9, size: 128, elements: !10)
+!9 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!10 = !{!11}
+!11 = !DISubrange(count: 4)
+!12 = !DIDerivedType(tag: DW_TAG_member, name: "smem", scope: !13, file: !3, line: 4, baseType: !16, flags: DIFlagStaticMember)
+!13 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "A", file: !3, line: 1, size: 8, elements: !14, identifier: "_ZTS1A")
+!14 = !{!15, !12}
+!15 = !DIDerivedType(tag: DW_TAG_member, name: "fully_specified", scope: !13, file: !3, line: 3, baseType: !9, flags: DIFlagStaticMember)
+!16 = !DICompositeType(tag: DW_TAG_array_type, baseType: !9, elements: !17)
+!17 = !{!18}
+!18 = !DISubrange(count: -1)
+!19 = !{i32 2, !"Dwarf Version", i32 4}
+!20 = !{i32 2, !"Debug Info Version", i32 3}
+!21 = !{i32 1, !"PIC Level", i32 2}
+!22 = !{!"clang version 4.0.0 (trunk 286129) (llvm/trunk 286128)"}
+
diff --git a/test/DebugInfo/X86/stmt-list.ll b/test/DebugInfo/X86/stmt-list.ll
new file mode 100644
index 0000000..4414ccd
--- /dev/null
+++ b/test/DebugInfo/X86/stmt-list.ll
@@ -0,0 +1,29 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple x86_64-pc-linux-gnu < %t.ll | FileCheck %s
+
+; CHECK:      .long   .Lline_table_start0          # DW_AT_stmt_list
+
+; CHECK:      .section        .debug_line,"",@progbits
+; CHECK-NEXT: .Lline_table_start0:
+
+define void @f() !dbg !0 {
+entry:
+  ret void
+}
+
+!llvm.dbg.cu = !{!2}
+!llvm.module.flags = !{!7}
+!5 = !{!0}
+
+!0 = distinct !DISubprogram(name: "f", line: 1, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: true, unit: !2, scopeLine: 1, file: !6, scope: !1, type: !3)
+!1 = !DIFile(filename: "test2.c", directory: "/home/espindola/llvm")
+!2 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.0 ()", isOptimized: true, emissionKind: FullDebug, file: !6, enums: !{}, retainedTypes: !{})
+!3 = !DISubroutineType(types: !4)
+!4 = !{null}
+!6 = !DIFile(filename: "test2.c", directory: "/home/espindola/llvm")
+!7 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/subrange-type.ll b/test/DebugInfo/X86/subrange-type.ll
new file mode 100644
index 0000000..7184a4f
--- /dev/null
+++ b/test/DebugInfo/X86/subrange-type.ll
@@ -0,0 +1,45 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -O0 %t.ll -mtriple=x86_64-unknown-linux-gnu -filetype=obj -o %t
+; RUN: llvm-dwarfdump -v -debug-info %t | FileCheck %s
+
+; Make sure that the base type from the subrange type has a name.
+; CHECK: DW_TAG_subrange_type
+; CHECK-NEXT: DW_AT_type [DW_FORM_ref4]     (cu + 0x{{[0-9a-f]+}} => {[[SUBTYPE:0x[0-9a-f]*]]}
+; CHECK: [[SUBTYPE]]: DW_TAG_base_type
+; CHECK-NEXT: DW_AT_name
+
+define i32 @main() nounwind uwtable !dbg !5 {
+entry:
+  %retval = alloca i32, align 4
+  %i = alloca [2 x i32], align 4
+  store i32 0, i32* %retval
+  call void @llvm.dbg.declare(metadata [2 x i32]* %i, metadata !10, metadata !DIExpression()), !dbg !15
+  ret i32 0, !dbg !16
+}
+
+declare void @llvm.dbg.declare(metadata, metadata, metadata) nounwind readnone
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!18}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.3 (trunk 171472) (llvm/trunk 171487)", isOptimized: false, emissionKind: FullDebug, file: !17, enums: !1, retainedTypes: !1, globals: !1, imports:  !1)
+!1 = !{}
+!5 = distinct !DISubprogram(name: "main", line: 2, isLocal: false, isDefinition: true, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, scopeLine: 3, file: !6, scope: !6, type: !7, retainedNodes: !1)
+!6 = !DIFile(filename: "foo.c", directory: "/usr/local/google/home/echristo/tmp")
+!7 = !DISubroutineType(types: !8)
+!8 = !{!9}
+!9 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!10 = !DILocalVariable(name: "i", line: 4, scope: !11, file: !6, type: !12)
+!11 = distinct !DILexicalBlock(line: 3, column: 0, file: !6, scope: !5)
+!12 = !DICompositeType(tag: DW_TAG_array_type, size: 64, align: 32, baseType: !9, elements: !13)
+!13 = !{!14}
+!14 = !DISubrange(count: 2)
+!15 = !DILocation(line: 4, scope: !11)
+!16 = !DILocation(line: 6, scope: !11)
+!17 = !DIFile(filename: "foo.c", directory: "/usr/local/google/home/echristo/tmp")
+!18 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/tail-merge.ll b/test/DebugInfo/X86/tail-merge.ll
new file mode 100644
index 0000000..33d6454
--- /dev/null
+++ b/test/DebugInfo/X86/tail-merge.ll
@@ -0,0 +1,80 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc %t.ll -mtriple=x86_64-unknown-unknown -use-unknown-locations=Enable -o - | FileCheck %s
+
+; Generated with "clang -gline-tables-only -c -emit-llvm -o - | opt -sroa -S"
+; from source:
+;
+; extern int foo(int);
+; extern int bar(int);
+;
+; int test(int a, int b) {
+;   if(b)
+;     a += foo(a);
+;   else
+;     a += bar(a);
+;   return a;
+; }
+
+; When tail-merging the debug location of the common tail should be removed.
+
+; CHECK-LABEL: test:
+; CHECK: movl	%edi, [[REG:%.*]]
+; CHECK: testl	%esi, %esi
+; CHECK: je	[[ELSE:.LBB[0-9]+_[0-9]+]]
+; CHECK: .loc	1 6 10
+; CHECK: callq	foo
+; CHECK: jmp	[[TAIL:.LBB[0-9]+_[0-9]+]]
+; CHECK: [[ELSE]]:
+; CHECK: .loc	1 8 10
+; CHECK: callq	bar
+; CHECK: [[TAIL]]:
+; CHECK: .loc	1 0
+; CHECK: addl	[[REG]], %eax
+; CHECK: .loc	1 9 3
+
+target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+define i32 @test(i32 %a, i32 %b) !dbg !6 {
+entry:
+  %tobool = icmp ne i32 %b, 0, !dbg !8
+  br i1 %tobool, label %if.then, label %if.else, !dbg !8
+
+if.then:                                          ; preds = %entry
+  %call = call i32 @foo(i32 %a), !dbg !9
+  %add = add nsw i32 %a, %call, !dbg !10
+  br label %if.end, !dbg !11
+
+if.else:                                          ; preds = %entry
+  %call1 = call i32 @bar(i32 %a), !dbg !12
+  %add2 = add nsw i32 %a, %call1, !dbg !13
+  br label %if.end
+
+if.end:                                           ; preds = %if.else, %if.then
+  %a.addr.0 = phi i32 [ %add, %if.then ], [ %add2, %if.else ]
+  ret i32 %a.addr.0, !dbg !14
+}
+
+declare i32 @foo(i32)
+declare i32 @bar(i32)
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "", isOptimized: false, runtimeVersion: 0, emissionKind: LineTablesOnly, enums: !2)
+!1 = !DIFile(filename: "test.c", directory: "")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!6 = distinct !DISubprogram(name: "test", scope: !1, file: !1, line: 4, type: !7, isLocal: false, isDefinition: true, scopeLine: 4, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!7 = !DISubroutineType(types: !2)
+!8 = !DILocation(line: 5, column: 6, scope: !6)
+!9 = !DILocation(line: 6, column: 10, scope: !6)
+!10 = !DILocation(line: 6, column: 7, scope: !6)
+!11 = !DILocation(line: 6, column: 5, scope: !6)
+!12 = !DILocation(line: 8, column: 10, scope: !6)
+!13 = !DILocation(line: 8, column: 7, scope: !6)
+!14 = !DILocation(line: 9, column: 3, scope: !6)
diff --git a/test/DebugInfo/X86/this-stack_value.ll b/test/DebugInfo/X86/this-stack_value.ll
new file mode 100644
index 0000000..4a48dc0
--- /dev/null
+++ b/test/DebugInfo/X86/this-stack_value.ll
@@ -0,0 +1,127 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=asm -o - %t.ll | FileCheck %s --check-prefix=ASM
+; RUN: llc -mtriple=%triple -filetype=obj -o - %t.ll | llvm-dwarfdump -v --debug-info - | FileCheck %s
+;
+; Generated at -O2 from:
+;   struct B;
+;   class A {
+;     int a1 = 23;
+;     int a2 = 42;
+;   };
+;   struct B {
+;     A a;
+;     int b = 48;
+;   };
+;    
+;   B *getB() { return new B(); }
+;
+; The inlined A::this pointer has the same location as B::this, but it may not be
+; modified by the debugger.
+;
+; ASM: [DW_OP_stack_value]
+; CHECK:  DW_AT_location {{.*}} (DW_OP_breg0 RAX+0, DW_OP_stack_value)
+
+source_filename = "ab.cpp"
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+%struct.B = type { %class.A, i32 }
+%class.A = type { i32, i32 }
+
+; Function Attrs: ssp uwtable
+define noalias nonnull %struct.B* @_Z4getBv() local_unnamed_addr #0 !dbg !7 {
+entry:
+  %call = tail call i8* @_Znwm(i64 12) #3, !dbg !20
+  %0 = bitcast i8* %call to %struct.B*, !dbg !20
+  tail call void @llvm.dbg.value(metadata %struct.B* %0, metadata !21, metadata !28), !dbg !29
+  tail call void @llvm.dbg.value(metadata %struct.B* %0, metadata !31, metadata !28), !dbg !34
+  tail call void @llvm.dbg.value(metadata %struct.B* %0, metadata !36, metadata !44), !dbg !45
+  tail call void @llvm.dbg.value(metadata %struct.B* %0, metadata !47, metadata !44), !dbg !50
+  %a1.i.i.i.i = bitcast i8* %call to i32*, !dbg !52
+  store i32 23, i32* %a1.i.i.i.i, align 4, !dbg !52, !tbaa !53
+  %a2.i.i.i.i = getelementptr inbounds i8, i8* %call, i64 4, !dbg !58
+  %1 = bitcast i8* %a2.i.i.i.i to i32*, !dbg !58
+  store i32 42, i32* %1, align 4, !dbg !58, !tbaa !59
+  %b.i.i = getelementptr inbounds i8, i8* %call, i64 8, !dbg !60
+  %2 = bitcast i8* %b.i.i to i32*, !dbg !60
+  store i32 48, i32* %2, align 4, !dbg !60, !tbaa !61
+  ret %struct.B* %0, !dbg !63
+}
+
+declare noalias nonnull i8* @_Znwm(i64) local_unnamed_addr #1
+declare void @llvm.dbg.value(metadata, metadata, metadata) #2
+
+attributes #0 = { ssp uwtable }
+attributes #1 = { nobuiltin }
+attributes #2 = { nounwind readnone }
+attributes #3 = { builtin }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4, !5}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version 5.0.0 (trunk 301093) (llvm/trunk 301093)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)
+!1 = !DIFile(filename: "ab.cpp", directory: "/")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = !{i32 1, !"PIC Level", i32 2}
+!7 = distinct !DISubprogram(name: "getB", linkageName: "_Z4getBv", scope: !1, file: !1, line: 11, type: !8, isLocal: false, isDefinition: true, scopeLine: 11, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !2)
+!8 = !DISubroutineType(types: !9)
+!9 = !{!10}
+!10 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !11, size: 64)
+!11 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "B", file: !1, line: 6, size: 96, elements: !12, identifier: "_ZTS1B")
+!12 = !{!13, !19}
+!13 = !DIDerivedType(tag: DW_TAG_member, name: "a", scope: !11, file: !1, line: 7, baseType: !14, size: 64)
+!14 = distinct !DICompositeType(tag: DW_TAG_class_type, name: "A", file: !1, line: 2, size: 64, elements: !15, identifier: "_ZTS1A")
+!15 = !{!16, !18}
+!16 = !DIDerivedType(tag: DW_TAG_member, name: "a1", scope: !14, file: !1, line: 3, baseType: !17, size: 32)
+!17 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!18 = !DIDerivedType(tag: DW_TAG_member, name: "a2", scope: !14, file: !1, line: 4, baseType: !17, size: 32, offset: 32)
+!19 = !DIDerivedType(tag: DW_TAG_member, name: "b", scope: !11, file: !1, line: 8, baseType: !17, size: 32, offset: 64)
+!20 = !DILocation(line: 11, column: 20, scope: !7)
+!21 = !DILocalVariable(name: "this", arg: 1, scope: !22, type: !10, flags: DIFlagArtificial | DIFlagObjectPointer)
+!22 = distinct !DISubprogram(name: "B", linkageName: "_ZN1BC1Ev", scope: !11, file: !1, line: 6, type: !23, isLocal: false, isDefinition: true, scopeLine: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: true, unit: !0, declaration: !26, retainedNodes: !27)
+!23 = !DISubroutineType(types: !24)
+!24 = !{null, !25}
+!25 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !11, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!26 = !DISubprogram(name: "B", scope: !11, type: !23, isLocal: false, isDefinition: false, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: true)
+!27 = !{!21}
+!28 = !DIExpression()
+!29 = !DILocation(line: 0, scope: !22, inlinedAt: !30)
+!30 = distinct !DILocation(line: 11, column: 24, scope: !7)
+!31 = !DILocalVariable(name: "this", arg: 1, scope: !32, type: !10, flags: DIFlagArtificial | DIFlagObjectPointer)
+!32 = distinct !DISubprogram(name: "B", linkageName: "_ZN1BC2Ev", scope: !11, file: !1, line: 6, type: !23, isLocal: false, isDefinition: true, scopeLine: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: true, unit: !0, declaration: !26, retainedNodes: !33)
+!33 = !{!31}
+!34 = !DILocation(line: 0, scope: !32, inlinedAt: !35)
+!35 = distinct !DILocation(line: 6, column: 8, scope: !22, inlinedAt: !30)
+!36 = !DILocalVariable(name: "this", arg: 1, scope: !37, type: !43, flags: DIFlagArtificial | DIFlagObjectPointer)
+!37 = distinct !DISubprogram(name: "A", linkageName: "_ZN1AC1Ev", scope: !14, file: !1, line: 2, type: !38, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: true, unit: !0, declaration: !41, retainedNodes: !42)
+!38 = !DISubroutineType(types: !39)
+!39 = !{null, !40}
+!40 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !14, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!41 = !DISubprogram(name: "A", scope: !14, type: !38, isLocal: false, isDefinition: false, flags: DIFlagPublic | DIFlagArtificial | DIFlagPrototyped, isOptimized: true)
+!42 = !{!36}
+!43 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !14, size: 64)
+!44 = !DIExpression(DW_OP_stack_value)
+!45 = !DILocation(line: 0, scope: !37, inlinedAt: !46)
+!46 = distinct !DILocation(line: 6, column: 8, scope: !32, inlinedAt: !35)
+!47 = !DILocalVariable(name: "this", arg: 1, scope: !48, type: !43, flags: DIFlagArtificial | DIFlagObjectPointer)
+!48 = distinct !DISubprogram(name: "A", linkageName: "_ZN1AC2Ev", scope: !14, file: !1, line: 2, type: !38, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: true, unit: !0, declaration: !41, retainedNodes: !49)
+!49 = !{!47}
+!50 = !DILocation(line: 0, scope: !48, inlinedAt: !51)
+!51 = distinct !DILocation(line: 2, column: 7, scope: !37, inlinedAt: !46)
+!52 = !DILocation(line: 3, column: 7, scope: !48, inlinedAt: !51)
+!53 = !{!54, !55, i64 0}
+!54 = !{!"_ZTS1A", !55, i64 0, !55, i64 4}
+!55 = !{!"int", !56, i64 0}
+!56 = !{!"omnipotent char", !57, i64 0}
+!57 = !{!"Simple C++ TBAA"}
+!58 = !DILocation(line: 4, column: 7, scope: !48, inlinedAt: !51)
+!59 = !{!54, !55, i64 4}
+!60 = !DILocation(line: 8, column: 7, scope: !32, inlinedAt: !35)
+!61 = !{!62, !55, i64 8}
+!62 = !{!"_ZTS1B", !54, i64 0, !55, i64 8}
+!63 = !DILocation(line: 11, column: 13, scope: !7)
diff --git a/test/DebugInfo/X86/type_units_with_addresses.ll b/test/DebugInfo/X86/type_units_with_addresses.ll
new file mode 100644
index 0000000..0b25ee5
--- /dev/null
+++ b/test/DebugInfo/X86/type_units_with_addresses.ll
@@ -0,0 +1,163 @@
+; REQUIRES: object-emission
+
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -split-dwarf-file=foo.dwo -filetype=obj -O0 -generate-type-units -mtriple=x86_64-unknown-linux-gnu < %t.ll \
+; RUN:     | llvm-dwarfdump -v - | FileCheck %s
+
+; RUN: llc -filetype=obj -O0 -generate-type-units -mtriple=x86_64-unknown-linux-gnu < %t.ll \
+; RUN:     | llvm-dwarfdump -v - | FileCheck --check-prefix=SINGLE %s
+
+; Test case built from:
+;int i;
+;
+;template <int *I>
+;struct S1 {};
+;
+;S1<&i> s1;
+;
+;template <int *I>
+;struct S2_1 {};
+;
+;struct S2 {
+;  S2_1<&i> s2_1;
+;};
+;
+;S2 s2;
+;
+;template <int *I>
+;struct S3_1 {};
+;
+;struct S3_2 {};
+;
+;struct S3 {
+;  S3_1<&i> s3_1;
+;  S3_2 s3_2;
+;};
+;
+;S3 s3;
+;
+;struct S4_1 {};
+;
+;template <int *T>
+;struct S4_2 {};
+;
+;struct S4 {
+;  S4_1 s4_1;
+;  S4_2<&::i> s4_2;
+;};
+;
+;S4 s4;
+
+; CHECK: .debug_info.dwo contents:
+
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_name {{.*}}"S1<&i>"
+
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_name {{.*}}"S2"
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_name {{.*}}"S2_1<&i>"
+
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_name {{.*}}"S3"
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_name {{.*}}"S3_1<&i>"
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_declaration
+; CHECK-NEXT: DW_AT_signature
+
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_name {{.*}}"S4"
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_declaration
+; CHECK-NEXT: DW_AT_signature
+; CHECK: DW_TAG_structure_type
+; CHECK-NEXT: DW_AT_name {{.*}}"S4_2<&i>"
+
+; SINGLE: .debug_info contents:
+
+; SINGLE: DW_TAG_structure_type
+; SINGLE-NEXT: DW_AT_declaration
+; SINGLE-NEXT: DW_AT_signature
+
+; SINGLE: DW_TAG_structure_type
+; SINGLE-NEXT: DW_AT_declaration
+; SINGLE-NEXT: DW_AT_signature
+
+; SINGLE: DW_TAG_structure_type
+; SINGLE-NEXT: DW_AT_declaration
+; SINGLE-NEXT: DW_AT_signature
+
+; SINGLE: DW_TAG_structure_type
+; SINGLE-NEXT: DW_AT_declaration
+; SINGLE-NEXT: DW_AT_signature
+
+source_filename = "test/DebugInfo/X86/type_units_with_addresses.ll"
+
+%struct.S1 = type { i8 }
+%struct.S2 = type { %struct.S2_1 }
+%struct.S2_1 = type { i8 }
+%struct.S3 = type { %struct.S3_1, %struct.S3_2 }
+%struct.S3_1 = type { i8 }
+%struct.S3_2 = type { i8 }
+%struct.S4 = type { %struct.S4_1, %struct.S4_2 }
+%struct.S4_1 = type { i8 }
+%struct.S4_2 = type { i8 }
+
+@i = global i32 0, align 4, !dbg !0
+@a = global %struct.S1 zeroinitializer, align 1, !dbg !4
+@s2 = global %struct.S2 zeroinitializer, align 1, !dbg !11
+@s3 = global %struct.S3 zeroinitializer, align 1, !dbg !17
+@s4 = global %struct.S4 zeroinitializer, align 1, !dbg !25
+
+!llvm.dbg.cu = !{!35}
+!llvm.module.flags = !{!38, !39}
+!llvm.ident = !{!40}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "i", scope: null, file: !2, line: 1, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "tu.cpp", directory: "/tmp/dbginfo")
+!3 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!4 = !DIGlobalVariableExpression(var: !5, expr: !DIExpression())
+!5 = !DIGlobalVariable(name: "a", scope: null, file: !2, line: 6, type: !6, isLocal: false, isDefinition: true)
+!6 = !DICompositeType(tag: DW_TAG_structure_type, name: "S1<&i>", file: !2, line: 4, size: 8, align: 8, elements: !7, templateParams: !8, identifier: "_ZTS2S1IXadL_Z1iEEE")
+!7 = !{}
+!8 = !{!9}
+!9 = !DITemplateValueParameter(name: "I", type: !10, value: i32* @i)
+!10 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !3, size: 64, align: 64)
+!11 = !DIGlobalVariableExpression(var: !12, expr: !DIExpression())
+!12 = !DIGlobalVariable(name: "s2", scope: null, file: !2, line: 15, type: !13, isLocal: false, isDefinition: true)
+!13 = !DICompositeType(tag: DW_TAG_structure_type, name: "S2", file: !2, line: 11, size: 8, align: 8, elements: !14, identifier: "_ZTS2S2")
+!14 = !{!15}
+!15 = !DIDerivedType(tag: DW_TAG_member, name: "s2_1", scope: !13, file: !2, line: 12, baseType: !16, size: 8, align: 8)
+!16 = !DICompositeType(tag: DW_TAG_structure_type, name: "S2_1<&i>", file: !2, line: 9, size: 8, align: 8, elements: !7, templateParams: !8, identifier: "_ZTS4S2_1IXadL_Z1iEEE")
+!17 = !DIGlobalVariableExpression(var: !18, expr: !DIExpression())
+!18 = !DIGlobalVariable(name: "s3", scope: null, file: !2, line: 27, type: !19, isLocal: false, isDefinition: true)
+!19 = !DICompositeType(tag: DW_TAG_structure_type, name: "S3", file: !2, line: 22, size: 16, align: 8, elements: !20, identifier: "_ZTS2S3")
+!20 = !{!21, !23}
+!21 = !DIDerivedType(tag: DW_TAG_member, name: "s3_1", scope: !19, file: !2, line: 23, baseType: !22, size: 8, align: 8)
+!22 = !DICompositeType(tag: DW_TAG_structure_type, name: "S3_1<&i>", file: !2, line: 18, size: 8, align: 8, elements: !7, templateParams: !8, identifier: "_ZTS4S3_1IXadL_Z1iEEE")
+!23 = !DIDerivedType(tag: DW_TAG_member, name: "s3_2", scope: !19, file: !2, line: 24, baseType: !24, size: 8, align: 8, offset: 8)
+!24 = !DICompositeType(tag: DW_TAG_structure_type, name: "S3_2", file: !2, line: 20, size: 8, align: 8, elements: !7, identifier: "_ZTS4S3_2")
+!25 = !DIGlobalVariableExpression(var: !26, expr: !DIExpression())
+!26 = !DIGlobalVariable(name: "s4", scope: null, file: !2, line: 39, type: !27, isLocal: false, isDefinition: true)
+!27 = !DICompositeType(tag: DW_TAG_structure_type, name: "S4", file: !2, line: 34, size: 16, align: 8, elements: !28, identifier: "_ZTS2S4")
+!28 = !{!29, !31}
+!29 = !DIDerivedType(tag: DW_TAG_member, name: "s4_1", scope: !27, file: !2, line: 35, baseType: !30, size: 8, align: 8)
+!30 = !DICompositeType(tag: DW_TAG_structure_type, name: "S4_1", file: !2, line: 29, size: 8, align: 8, elements: !7, identifier: "_ZTS4S4_1")
+!31 = !DIDerivedType(tag: DW_TAG_member, name: "s4_2", scope: !27, file: !2, line: 36, baseType: !32, size: 8, align: 8, offset: 8)
+!32 = !DICompositeType(tag: DW_TAG_structure_type, name: "S4_2<&i>", file: !2, line: 32, size: 8, align: 8, elements: !7, templateParams: !33, identifier: "_ZTS4S4_2IXadL_Z1iEEE")
+!33 = !{!34}
+!34 = !DITemplateValueParameter(name: "T", type: !10, value: i32* @i)
+!35 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !2, producer: "clang version 3.5.0 ", isOptimized: false, runtimeVersion: 0, splitDebugFilename: "tu.dwo", emissionKind: FullDebug, enums: !7, retainedTypes: !36, globals: !37, imports: !7)
+!36 = !{!6, !13, !16, !19, !22, !24, !27, !30, !32}
+!37 = !{!0, !4, !11, !17, !25}
+!38 = !{i32 2, !"Dwarf Version", i32 4}
+!39 = !{i32 1, !"Debug Info Version", i32 3}
+!40 = !{!"clang version 3.5.0 "}
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/unattached-global.ll b/test/DebugInfo/X86/unattached-global.ll
new file mode 100644
index 0000000..3b0fd47
--- /dev/null
+++ b/test/DebugInfo/X86/unattached-global.ll
@@ -0,0 +1,27 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj -o - %t.ll | llvm-dwarfdump - | FileCheck %s
+
+target datalayout = "e-p:64:64"
+target triple = "spir64-unknown-unknown"
+
+; CHECK: DW_TAG_variable
+; CHECK: DW_AT_name {{.*}}"a"
+; CHECK-NOT: DW_AT_location
+; CHECK: DW_TAG
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, producer: "clang", file: !5, globals: !1, emissionKind: FullDebug)
+!1 = !{!2}
+!2 = !DIGlobalVariableExpression(var: !3, expr: !4)
+!3 = distinct !DIGlobalVariable(name: "a", scope: null, isLocal: false, isDefinition: true, type: !6)
+!4 = !DIExpression(DW_OP_plus_uconst, 4)
+!5 = !DIFile(filename: "<stdin>", directory: "/")
+!6 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+
+!7 = !{i32 2, !"Dwarf Version", i32 2}
+!8 = !{i32 2, !"Debug Info Version", i32 3}
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!7, !8}
diff --git a/test/DebugInfo/X86/union-const.ll b/test/DebugInfo/X86/union-const.ll
new file mode 100644
index 0000000..b35e14b
--- /dev/null
+++ b/test/DebugInfo/X86/union-const.ll
@@ -0,0 +1,69 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple -filetype=obj < %t.ll | llvm-dwarfdump -v -debug-info - | FileCheck %s
+; CHECK: DW_TAG_variable
+; CHECK-NEXT: DW_AT_const_value [DW_FORM_udata]	(0)
+; CHECK-NEXT: DW_AT_name {{.*}}"a"
+;
+; ModuleID = 'union.c'
+; generated at -O1 from:
+; union mfi_evt {
+;   struct {
+;     int reserved;
+;   } members;
+; } mfi_aen_setup() {
+;   union mfi_evt a;
+;   a.members.reserved = 0;
+; }
+target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "spir64-unknown-unknown"
+
+%union.mfi_evt = type { %struct.anon }
+%struct.anon = type { i32 }
+
+; Function Attrs: nounwind readnone ssp uwtable
+define i32 @mfi_aen_setup() #0 !dbg !4 {
+entry:
+  tail call void @llvm.dbg.declare(metadata %union.mfi_evt* undef, metadata !16, metadata !21), !dbg !22
+  tail call void @llvm.dbg.value(metadata i32 0, metadata !16, metadata !21), !dbg !22
+  ret i32 undef, !dbg !23
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind readnone ssp uwtable }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!17, !18, !19}
+!llvm.ident = !{!20}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, producer: "clang version 3.7.0 (trunk 226915) (llvm/trunk 226905)", isOptimized: true, emissionKind: FullDebug, file: !1, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "union.c", directory: "")
+!2 = !{}
+!4 = distinct !DISubprogram(name: "mfi_aen_setup", line: 5, isLocal: false, isDefinition: true, isOptimized: true, unit: !0, scopeLine: 5, file: !1, scope: !5, type: !6, retainedNodes: !15)
+!5 = !DIFile(filename: "union.c", directory: "")
+!6 = !DISubroutineType(types: !7)
+!7 = !{!8}
+!8 = !DICompositeType(tag: DW_TAG_union_type, name: "mfi_evt", line: 1, size: 32, align: 32, file: !1, elements: !9)
+!9 = !{!10}
+!10 = !DIDerivedType(tag: DW_TAG_member, name: "members", line: 4, size: 32, align: 32, file: !1, scope: !8, baseType: !11)
+!11 = !DICompositeType(tag: DW_TAG_structure_type, line: 2, size: 32, align: 32, file: !1, scope: !8, elements: !12)
+!12 = !{!13}
+!13 = !DIDerivedType(tag: DW_TAG_member, name: "reserved", line: 3, size: 32, align: 32, file: !1, scope: !11, baseType: !14)
+!14 = !DIBasicType(tag: DW_TAG_base_type, name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!15 = !{!16}
+!16 = !DILocalVariable(name: "a", line: 6, scope: !4, file: !5, type: !8)
+!17 = !{i32 2, !"Dwarf Version", i32 2}
+!18 = !{i32 2, !"Debug Info Version", i32 3}
+!19 = !{i32 1, !"PIC Level", i32 2}
+!20 = !{!"clang version 3.7.0 (trunk 226915) (llvm/trunk 226905)"}
+!21 = !DIExpression()
+!22 = !DILocation(line: 6, column: 17, scope: !4)
+!23 = !DILocation(line: 8, column: 1, scope: !4)
diff --git a/test/DebugInfo/X86/union-template.ll b/test/DebugInfo/X86/union-template.ll
new file mode 100644
index 0000000..080ec47
--- /dev/null
+++ b/test/DebugInfo/X86/union-template.ll
@@ -0,0 +1,70 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -O0 -mtriple=x86_64-linux-gnu %t.ll -o %t -filetype=obj
+; RUN: llvm-dwarfdump -debug-info %t | FileCheck %s
+
+; Verify that we've emitted template arguments for the union
+; CHECK: DW_TAG_union_type
+; CHECK-NEXT: "Value<float>"
+; CHECK: DW_TAG_template_type_parameter
+; CHECK: "T"
+
+source_filename = "test/DebugInfo/X86/union-template.ll"
+
+%"union.PR15637::Value" = type { i32 }
+
+@_ZN7PR156371fE = global %"union.PR15637::Value" zeroinitializer, align 4, !dbg !0
+
+; Function Attrs: nounwind
+define void @_ZN7PR156371gEf(float %value) #0 !dbg !19 {
+entry:
+  %value.addr = alloca float, align 4
+  %tempValue = alloca %"union.PR15637::Value", align 4
+  store float %value, float* %value.addr, align 4
+  call void @llvm.dbg.declare(metadata float* %value.addr, metadata !22, metadata !23), !dbg !24
+  call void @llvm.dbg.declare(metadata %"union.PR15637::Value"* %tempValue, metadata !25, metadata !23), !dbg !26
+  ret void, !dbg !27
+}
+
+; Function Attrs: nounwind readnone
+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind }
+attributes #1 = { nounwind readnone }
+
+!llvm.dbg.cu = !{!15}
+!llvm.module.flags = !{!18}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "f", linkageName: "_ZN7PR156371fE", scope: !2, file: !3, line: 6, type: !4, isLocal: false, isDefinition: true)
+!2 = !DINamespace(name: "PR15637", scope: null)
+!3 = !DIFile(filename: "foo.cc", directory: "/usr/local/google/home/echristo/tmp")
+!4 = !DICompositeType(tag: DW_TAG_union_type, name: "Value<float>", scope: !2, file: !3, line: 2, size: 32, align: 32, elements: !5, templateParams: !12)
+!5 = !{!6, !8}
+!6 = !DIDerivedType(tag: DW_TAG_member, name: "a", scope: !4, file: !3, line: 2, baseType: !7, size: 32, align: 32)
+!7 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!8 = !DISubprogram(name: "Value", scope: !4, file: !3, line: 2, type: !9, isLocal: false, isDefinition: false, scopeLine: 2, virtualIndex: 6, flags: DIFlagArtificial | DIFlagPrototyped, isOptimized: false)
+!9 = !DISubroutineType(types: !10)
+!10 = !{null, !11}
+!11 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !4, size: 64, align: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!12 = !{!13}
+!13 = !DITemplateTypeParameter(name: "T", type: !14)
+!14 = !DIBasicType(name: "float", size: 32, align: 32, encoding: DW_ATE_float)
+!15 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !3, producer: "clang version 3.3 (trunk 178499) (llvm/trunk 178472)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !16, retainedTypes: !16, globals: !17, imports: !16)
+!16 = !{}
+!17 = !{!0}
+!18 = !{i32 1, !"Debug Info Version", i32 3}
+!19 = distinct !DISubprogram(name: "g", linkageName: "_ZN7PR156371gEf", scope: !2, file: !3, line: 3, type: !20, isLocal: false, isDefinition: true, scopeLine: 3, virtualIndex: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !15, retainedNodes: !16)
+!20 = !DISubroutineType(types: !21)
+!21 = !{null, !14}
+!22 = !DILocalVariable(name: "value", arg: 1, scope: !19, file: !3, line: 3, type: !14)
+!23 = !DIExpression()
+!24 = !DILocation(line: 3, scope: !19)
+!25 = !DILocalVariable(name: "tempValue", scope: !19, file: !3, line: 4, type: !4)
+!26 = !DILocation(line: 4, scope: !19)
+!27 = !DILocation(line: 5, scope: !19)
+
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/vector.ll b/test/DebugInfo/X86/vector.ll
new file mode 100644
index 0000000..034b389
--- /dev/null
+++ b/test/DebugInfo/X86/vector.ll
@@ -0,0 +1,37 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-linux-gnu -O0 -filetype=obj -o %t %t.ll
+; RUN: llvm-dwarfdump -debug-info %t | FileCheck %s
+
+; Generated from:
+; clang -g -S -emit-llvm -o foo.ll foo.c
+; typedef int v4si __attribute__((__vector_size__(16)));
+;
+; v4si a
+
+source_filename = "test/DebugInfo/X86/vector.ll"
+
+@a = common addrspace(1) global <4 x i32> zeroinitializer, align 16, !dbg !0
+
+!llvm.dbg.cu = !{!8}
+!llvm.module.flags = !{!11}
+
+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())
+!1 = !DIGlobalVariable(name: "a", scope: null, file: !2, line: 3, type: !3, isLocal: false, isDefinition: true)
+!2 = !DIFile(filename: "foo.c", directory: "/Users/echristo")
+!3 = !DIDerivedType(tag: DW_TAG_typedef, name: "v4si", file: !2, line: 1, baseType: !4)
+!4 = !DICompositeType(tag: DW_TAG_array_type, baseType: !5, size: 128, align: 128, flags: DIFlagVector, elements: !6)
+!5 = !DIBasicType(name: "int", size: 32, align: 32, encoding: DW_ATE_signed)
+!6 = !{!7}
+!7 = !DISubrange(count: 4)
+!8 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2, producer: "clang version 3.3 (trunk 171825) (llvm/trunk 171822)", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !9, retainedTypes: !9, globals: !10, imports: !9)
+!9 = !{}
+; Check that we get an array type with a vector attribute.
+; CHECK: DW_TAG_array_type
+; CHECK-NEXT: DW_AT_GNU_vector
+!10 = !{!0}
+!11 = !{i32 1, !"Debug Info Version", i32 3}
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/X86/xray-split-dwarf-interaction.ll b/test/DebugInfo/X86/xray-split-dwarf-interaction.ll
new file mode 100644
index 0000000..e07a463
--- /dev/null
+++ b/test/DebugInfo/X86/xray-split-dwarf-interaction.ll
@@ -0,0 +1,89 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv -spirv-mem2reg=false
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=x86_64-pc-linux -split-dwarf-file=input.dwo -O3 \
+; RUN:     -function-sections -data-sections \
+; RUN:     -relocation-model=pic -filetype=asm \
+; RUN:     -generate-type-units -o - %s | \
+; RUN:     FileCheck %s --check-prefix=CHECK-ASM
+; RUN: llc -mtriple=x86_64-pc-linux -split-dwarf-file=input.dwo -O3 \
+; RUN:     -function-sections -data-sections \
+; RUN:     -relocation-model=pic -filetype=obj \
+; RUN:     -generate-type-units -o - %s | \
+; RUN:     llvm-readelf -sections | \
+; RUN:     FileCheck %s --check-prefix=CHECK-ELF
+; Created from `clang++ -fxray-instrument -gsplit-dwarf -fdebug-types-section
+; -ffunction-sections -fdata-sections -emit-llvm -S input.cc`:
+; input.cc:
+;
+; class a {
+;   int b();
+; };
+; int a::b() {
+;   for (;;)
+;     ;
+; }
+;
+; In this test we want to make sure that the xray_instr_map section for
+; `a::b()` is actually associated with the function's symbol instead of the
+; .debug_types.dwo section.
+;
+; CHECK-ASM: xray_fn_idx,"awo",@progbits,_ZN1a1bEv,unique,1
+;
+; CHECK-ELF-DAG: [[FSECT:[0-9]+]]] .text._ZN1a1bEv PROGBITS
+; CHECK-ELF-DAG: [{{.*}}] .debug_types.dwo PROGBITS
+; CHECK-ELF-DAG: [{{.*}}] xray_instr_map PROGBITS {{.*}} {{.*}} {{.*}} {{.*}} WAL [[FSECT]]
+target triple = "spir64-unknown-unknown"
+
+%class.a = type { i8 }
+
+; Function Attrs: nounwind readnone uwtable
+define i32 @_ZN1a1bEv(%class.a* nocapture readnone) local_unnamed_addr #0 align 2 !dbg !8 {
+  tail call void @llvm.dbg.value(metadata %class.a* %0, metadata !17, metadata !DIExpression()), !dbg !19
+  br label %2, !dbg !20
+
+; <label>:2:                                      ; preds = %2, %1
+  br label %2, !dbg !21, !llvm.loop !25
+}
+
+
+; Function Attrs: nounwind readnone speculatable
+declare void @llvm.dbg.value(metadata, metadata, metadata) #1
+
+attributes #0 = { nounwind readnone uwtable "xray-instruction-threshold"="200" }
+attributes #1 = { nounwind readnone speculatable }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4, !5, !6}
+!llvm.ident = !{!7}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: "clang version trunk (trunk r312634)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, splitDebugInlining: false, debugInfoForProfiling: true)
+!1 = !DIFile(filename: "input.cc", directory: "/usr/local/google/home/dberris/tmp")
+!2 = !{}
+!3 = !{i32 2, !"Debug Info Version", i32 3}
+!4 = !{i32 1, !"wchar_size", i32 4}
+!5 = !{i32 7, !"PIC Level", i32 2}
+!6 = !{i32 7, !"PIE Level", i32 2}
+!7 = !{!"clang version trunk (trunk r312634)"}
+!8 = distinct !DISubprogram(name: "b", linkageName: "_ZN1a1bEv", scope: !9, file: !1, line: 4, type: !12, isLocal: false, isDefinition: true, scopeLine: 4, flags: DIFlagPrototyped, isOptimized: true, unit: !0, declaration: !11, retainedNodes: !16)
+!9 = distinct !DICompositeType(tag: DW_TAG_class_type, name: "a", file: !1, line: 1, size: 8, elements: !10, identifier: "_ZTS1a")
+!10 = !{!11}
+!11 = !DISubprogram(name: "b", linkageName: "_ZN1a1bEv", scope: !9, file: !1, line: 2, type: !12, isLocal: false, isDefinition: false, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: true)
+!12 = !DISubroutineType(types: !13)
+!13 = !{!14, !15}
+!14 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
+!15 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !9, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)
+!16 = !{!17}
+!17 = !DILocalVariable(name: "this", arg: 1, scope: !8, type: !18, flags: DIFlagArtificial | DIFlagObjectPointer)
+!18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !9, size: 64)
+!19 = !DILocation(line: 0, scope: !8)
+!20 = !DILocation(line: 5, column: 3, scope: !8)
+!21 = !DILocation(line: 5, column: 3, scope: !22)
+!22 = !DILexicalBlockFile(scope: !23, file: !1, discriminator: 2)
+!23 = distinct !DILexicalBlock(scope: !24, file: !1, line: 5, column: 3)
+!24 = distinct !DILexicalBlock(scope: !8, file: !1, line: 5, column: 3)
+!25 = distinct !{!25, !26, !27}
+!26 = !DILocation(line: 5, column: 3, scope: !24)
+!27 = !DILocation(line: 6, column: 5, scope: !24)
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/DebugInfo/lit.local.cfg b/test/DebugInfo/lit.local.cfg
new file mode 100644
index 0000000..eb016c7
--- /dev/null
+++ b/test/DebugInfo/lit.local.cfg
@@ -0,0 +1,2 @@
+config.suffixes = ['.ll']
+config.substitutions.append(('%triple', config.target_triple))
diff --git a/test/DebugInfo/omit-empty.ll b/test/DebugInfo/omit-empty.ll
new file mode 100644
index 0000000..48ff4c5
--- /dev/null
+++ b/test/DebugInfo/omit-empty.ll
@@ -0,0 +1,26 @@
+; RUN: llvm-as < %s -o %t.bc
+; RUN: llvm-spirv %t.bc -o %t.spv
+; RUN: llvm-spirv -r %t.spv -o - | llvm-dis -o %t.ll
+
+; RUN: llc -mtriple=%triple %t.ll -filetype=obj -o - | llvm-objdump -h - | FileCheck %s
+; REQUIRES: default_triple
+
+; CHECK-NOT: .debug_
+
+!llvm.dbg.cu = !{!0, !5}
+!llvm.module.flags = !{!3, !4}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "LLVM", isOptimized: false, runtimeVersion: 2, emissionKind: FullDebug, enums: !2, retainedTypes: !2, globals: !2, imports: !2)
+!1 = !DIFile(filename: "<stdin>", directory: "/")
+!2 = !{}
+!3 = !{i32 2, !"Dwarf Version", i32 4}
+!4 = !{i32 2, !"Debug Info Version", i32 3}
+!5 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "LLVM", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, imports: !6)
+!6 = !{!7}
+!7 = !DIImportedEntity(tag: DW_TAG_imported_module, scope: !8, entity: !8, file: !1, line: 3)
+!8 = distinct !DISubprogram(name: "f2", linkageName: "_Z2f2v", scope: !1, file: !1, line: 2, type: !9, isLocal: false, isDefinition: true, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: false, unit: !5, retainedNodes: !2)
+!9 = !DISubroutineType(types: !10)
+!10 = !{null}
+!11 = !DINamespace(name: "ns", scope: null)
+target triple = "spir64-unknown-unknown"
+target datalayout = "e-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-n8:16:32:64"
diff --git a/test/SingleOpLine.ll b/test/SingleOpLine.ll
new file mode 100644
index 0000000..db1b985
--- /dev/null
+++ b/test/SingleOpLine.ll
@@ -0,0 +1,45 @@
+; Source:
+; __kernel void test_kernel() { }
+
+; Command:
+; clang -cc1 -triple spir -O0 -debug-info-kind=line-tables-only -emit-llvm -o /tmp/SingleOpLine.ll /tmp/SingleOpLine.cl
+
+; RUN: llvm-as %s -o %t.bc
+; RUN: llvm-spirv %t.bc -spirv-text -o - | FileCheck %s
+
+; ModuleID = '/tmp/SingleOpLine.cl'
+source_filename = "/tmp/SingleOpLine.cl"
+target datalayout = "e-p:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
+target triple = "spir"
+
+; Function Attrs: convergent noinline nounwind optnone
+define spir_kernel void @test_kernel() #0 !dbg !8 !kernel_arg_addr_space !2 !kernel_arg_access_qual !2 !kernel_arg_type !2 !kernel_arg_base_type !2 !kernel_arg_type_qual !2 {
+entry:
+; CHECK: Line
+  ret void, !dbg !11
+}
+
+attributes #0 = { convergent noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "denorms-are-zero"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "uniform-work-group-size"="true" "unsafe-fp-math"="false" "use-soft-float"="false" }
+
+!llvm.dbg.cu = !{!0}
+!llvm.module.flags = !{!3, !4}
+!opencl.enable.FP_CONTRACT = !{}
+!opencl.ocl.version = !{!5}
+!opencl.spir.version = !{!6}
+!opencl.used.extensions = !{!2}
+!opencl.used.optional.core.features = !{!2}
+!opencl.compiler.options = !{!2}
+!llvm.ident = !{!7}
+
+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 8.0.0 (cfe/trunk)", isOptimized: false, runtimeVersion: 0, emissionKind: LineTablesOnly, enums: !2)
+!1 = !DIFile(filename: "/tmp/<stdin>", directory: "/tmp")
+!2 = !{}
+!3 = !{i32 2, !"Debug Info Version", i32 3}
+!4 = !{i32 1, !"wchar_size", i32 4}
+!5 = !{i32 1, i32 0}
+!6 = !{i32 1, i32 2}
+!7 = !{!"clang version 8.0.0 (cfe/trunk)"}
+!8 = distinct !DISubprogram(name: "test_kernel", scope: !9, file: !9, line: 1, type: !10, isLocal: false, isDefinition: true, scopeLine: 1, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)
+!9 = !DIFile(filename: "/tmp/SingleOpLine.cl", directory: "/tmp")
+!10 = !DISubroutineType(types: !2)
+!11 = !DILocation(line: 1, scope: !8)
diff --git a/test/lit.cfg.py b/test/lit.cfg.py
index 924f3f2..ac1f463 100644
--- a/test/lit.cfg.py
+++ b/test/lit.cfg.py
@@ -35,7 +35,7 @@ config.substitutions.append(('%PATH%', config.environment['PATH']))
 
 tool_dirs = [config.llvm_tools_dir, config.llvm_spirv_dir]
 
-tools = ['llvm-as', 'llvm-dis', 'llvm-spirv']
+tools = ['llc', 'llvm-as', 'llvm-dis', 'llvm-dwarfdump', 'llvm-objdump', 'llvm-readelf', 'llvm-readobj',  'llvm-spirv']
 
 llvm_config.add_tool_substitutions(tools, tool_dirs)
 
-- 
1.8.3.1

